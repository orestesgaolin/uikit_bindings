// ignore_for_file: unused_element, unused_field, return_of_invalid_type

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<instancetype Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external instancetype _NativeLibrary_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external bool _NativeLibrary_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external void _NativeLibrary_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1l4hxwm(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1pl9qdv(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>()
external void _NativeLibrary_protocolTrampoline_1l4hxwm(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCBlockImpl> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject> _NativeLibrary_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external ffi.Pointer<objc.ObjCObject> _NativeLibrary_protocolTrampoline_zi5eed(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_7ohnx8(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1bktu2(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGPoint)>()
external void _NativeLibrary_protocolTrampoline_1bktu2(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
);

@ffi.Native<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external CGAffineTransform _NativeLibrary_protocolTrampoline_8o6he9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1lznlw3(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, CGAffineTransform)>()
external void _NativeLibrary_protocolTrampoline_1lznlw3(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  CGAffineTransform arg1,
);

@ffi.Native<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _NativeLibrary_protocolTrampoline_ku69ws(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)
>()
external objc.CGPoint _NativeLibrary_protocolTrampoline_17ipln5(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGPoint arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
  objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)
>()
external objc.CGRect _NativeLibrary_protocolTrampoline_1sh7l9z(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external void _NativeLibrary_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external bool _NativeLibrary_protocolTrampoline_3su7tt(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_fjrv01(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
  )
>()
external void _NativeLibrary_protocolTrampoline_fjrv01(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGRect)>()
external ffi.Pointer<objc.ObjCObject> _NativeLibrary_protocolTrampoline_12thpau(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGRect arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_qvcerx(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<CGContext>,
  )
>()
external void _NativeLibrary_protocolTrampoline_qvcerx(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<CGContext> arg2,
);

@ffi.Native<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external objc.CGSize _NativeLibrary_protocolTrampoline_1j20mp(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)
>()
external objc.CGSize _NativeLibrary_protocolTrampoline_gnbb7x(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  objc.CGSize arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1rn6eap(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1rn6eap(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
>()
external void _NativeLibrary_protocolTrampoline_1rn6eap(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  objc.CGSize arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
  )
>()
external instancetype _NativeLibrary_protocolTrampoline_10z9f5k(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
);

@ffi.Native<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
external int _NativeLibrary_protocolTrampoline_1ldqghh(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObject> Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external ffi.Pointer<objc.ObjCObject> _NativeLibrary_protocolTrampoline_1q0i84(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1s56lr9(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_8acz2h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_8acz2h(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
  ffi.Void Function(
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Pointer<objc.ObjCObject>,
    ffi.Bool,
  )
>()
external void _NativeLibrary_protocolTrampoline_8acz2h(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
  ffi.Pointer<objc.ObjCObject> arg2,
  bool arg3,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_1cxqo1i(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_1cxqo1i(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_xtuoz7(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapListenerBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _NativeLibrary_wrapBlockingBlock_10lndml(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>, ffi.Bool)>()
external void _NativeLibrary_protocolTrampoline_10lndml(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  bool arg1,
);

final class CGVector extends ffi.Struct {
  @ffi.Double()
  external double dx;

  @ffi.Double()
  external double dy;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

enum NSSearchPathDirectory {
  NSApplicationDirectory(1),
  NSDemoApplicationDirectory(2),
  NSDeveloperApplicationDirectory(3),
  NSAdminApplicationDirectory(4),
  NSLibraryDirectory(5),
  NSDeveloperDirectory(6),
  NSUserDirectory(7),
  NSDocumentationDirectory(8),
  NSDocumentDirectory(9),
  NSCoreServiceDirectory(10),
  NSAutosavedInformationDirectory(11),
  NSDesktopDirectory(12),
  NSCachesDirectory(13),
  NSApplicationSupportDirectory(14),
  NSDownloadsDirectory(15),
  NSInputMethodsDirectory(16),
  NSMoviesDirectory(17),
  NSMusicDirectory(18),
  NSPicturesDirectory(19),
  NSPrinterDescriptionDirectory(20),
  NSSharedPublicDirectory(21),
  NSPreferencePanesDirectory(22),
  NSApplicationScriptsDirectory(23),
  NSItemReplacementDirectory(99),
  NSAllApplicationsDirectory(100),
  NSAllLibrariesDirectory(101),
  NSTrashDirectory(102);

  final int value;
  const NSSearchPathDirectory(this.value);

  static NSSearchPathDirectory fromValue(int value) => switch (value) {
    1 => NSApplicationDirectory,
    2 => NSDemoApplicationDirectory,
    3 => NSDeveloperApplicationDirectory,
    4 => NSAdminApplicationDirectory,
    5 => NSLibraryDirectory,
    6 => NSDeveloperDirectory,
    7 => NSUserDirectory,
    8 => NSDocumentationDirectory,
    9 => NSDocumentDirectory,
    10 => NSCoreServiceDirectory,
    11 => NSAutosavedInformationDirectory,
    12 => NSDesktopDirectory,
    13 => NSCachesDirectory,
    14 => NSApplicationSupportDirectory,
    15 => NSDownloadsDirectory,
    16 => NSInputMethodsDirectory,
    17 => NSMoviesDirectory,
    18 => NSMusicDirectory,
    19 => NSPicturesDirectory,
    20 => NSPrinterDescriptionDirectory,
    21 => NSSharedPublicDirectory,
    22 => NSPreferencePanesDirectory,
    23 => NSApplicationScriptsDirectory,
    99 => NSItemReplacementDirectory,
    100 => NSAllApplicationsDirectory,
    101 => NSAllLibrariesDirectory,
    102 => NSTrashDirectory,
    _ => throw ArgumentError('Unknown value for NSSearchPathDirectory: $value'),
  };
}

sealed class NSSearchPathDomainMask {
  static const NSUserDomainMask = 1;
  static const NSLocalDomainMask = 2;
  static const NSNetworkDomainMask = 4;
  static const NSSystemDomainMask = 8;
  static const NSAllDomainsMask = 65535;
}

sealed class NSVolumeEnumerationOptions {
  static const NSVolumeEnumerationSkipHiddenVolumes = 2;
  static const NSVolumeEnumerationProduceFileReferenceURLs = 4;
}

sealed class NSDirectoryEnumerationOptions {
  static const NSDirectoryEnumerationSkipsSubdirectoryDescendants = 1;
  static const NSDirectoryEnumerationSkipsPackageDescendants = 2;
  static const NSDirectoryEnumerationSkipsHiddenFiles = 4;
  static const NSDirectoryEnumerationIncludesDirectoriesPostOrder = 8;
  static const NSDirectoryEnumerationProducesRelativePathURLs = 16;
}

sealed class NSFileManagerItemReplacementOptions {
  static const NSFileManagerItemReplacementUsingNewMetadataOnly = 1;
  static const NSFileManagerItemReplacementWithoutDeletingBackupItem = 2;
}

enum NSURLRelationship {
  NSURLRelationshipContains(0),
  NSURLRelationshipSame(1),
  NSURLRelationshipOther(2);

  final int value;
  const NSURLRelationship(this.value);

  static NSURLRelationship fromValue(int value) => switch (value) {
    0 => NSURLRelationshipContains,
    1 => NSURLRelationshipSame,
    2 => NSURLRelationshipOther,
    _ => throw ArgumentError('Unknown value for NSURLRelationship: $value'),
  };
}

sealed class NSFileManagerUnmountOptions {
  static const NSFileManagerUnmountAllPartitionsAndEjectDisk = 1;
  static const NSFileManagerUnmountWithoutUI = 2;
}

enum NSFileManagerResumeSyncBehavior {
  NSFileManagerResumeSyncBehaviorPreserveLocalChanges(0),
  NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict(1),
  NSFileManagerResumeSyncBehaviorDropLocalChanges(2);

  final int value;
  const NSFileManagerResumeSyncBehavior(this.value);

  static NSFileManagerResumeSyncBehavior fromValue(int value) => switch (value) {
    0 => NSFileManagerResumeSyncBehaviorPreserveLocalChanges,
    1 => NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict,
    2 => NSFileManagerResumeSyncBehaviorDropLocalChanges,
    _ => throw ArgumentError('Unknown value for NSFileManagerResumeSyncBehavior: $value'),
  };
}

enum NSFileManagerUploadLocalVersionConflictPolicy {
  NSFileManagerUploadConflictPolicyDefault(0),
  NSFileManagerUploadConflictPolicyFailOnConflict(1);

  final int value;
  const NSFileManagerUploadLocalVersionConflictPolicy(this.value);

  static NSFileManagerUploadLocalVersionConflictPolicy fromValue(int value) => switch (value) {
    0 => NSFileManagerUploadConflictPolicyDefault,
    1 => NSFileManagerUploadConflictPolicyFailOnConflict,
    _ => throw ArgumentError('Unknown value for NSFileManagerUploadLocalVersionConflictPolicy: $value'),
  };
}

enum NSHTTPCookieAcceptPolicy {
  NSHTTPCookieAcceptPolicyAlways(0),
  NSHTTPCookieAcceptPolicyNever(1),
  NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain(2);

  final int value;
  const NSHTTPCookieAcceptPolicy(this.value);

  static NSHTTPCookieAcceptPolicy fromValue(int value) => switch (value) {
    0 => NSHTTPCookieAcceptPolicyAlways,
    1 => NSHTTPCookieAcceptPolicyNever,
    2 => NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain,
    _ => throw ArgumentError('Unknown value for NSHTTPCookieAcceptPolicy: $value'),
  };
}

final class __IOSurface extends ffi.Opaque {}

sealed class NSAlignmentOptions {
  static const NSAlignMinXInward = 1;
  static const NSAlignMinYInward = 2;
  static const NSAlignMaxXInward = 4;
  static const NSAlignMaxYInward = 8;
  static const NSAlignWidthInward = 16;
  static const NSAlignHeightInward = 32;
  static const NSAlignMinXOutward = 256;
  static const NSAlignMinYOutward = 512;
  static const NSAlignMaxXOutward = 1024;
  static const NSAlignMaxYOutward = 2048;
  static const NSAlignWidthOutward = 4096;
  static const NSAlignHeightOutward = 8192;
  static const NSAlignMinXNearest = 65536;
  static const NSAlignMinYNearest = 131072;
  static const NSAlignMaxXNearest = 262144;
  static const NSAlignMaxYNearest = 524288;
  static const NSAlignWidthNearest = 1048576;
  static const NSAlignHeightNearest = 2097152;
  static const NSAlignRectFlipped = -9223372036854775808;
  static const NSAlignAllEdgesInward = 15;
  static const NSAlignAllEdgesOutward = 3840;
  static const NSAlignAllEdgesNearest = 983040;
}

enum NSOperationQueuePriority {
  NSOperationQueuePriorityVeryLow(-8),
  NSOperationQueuePriorityLow(-4),
  NSOperationQueuePriorityNormal(0),
  NSOperationQueuePriorityHigh(4),
  NSOperationQueuePriorityVeryHigh(8);

  final int value;
  const NSOperationQueuePriority(this.value);

  static NSOperationQueuePriority fromValue(int value) => switch (value) {
    -8 => NSOperationQueuePriorityVeryLow,
    -4 => NSOperationQueuePriorityLow,
    0 => NSOperationQueuePriorityNormal,
    4 => NSOperationQueuePriorityHigh,
    8 => NSOperationQueuePriorityVeryHigh,
    _ => throw ArgumentError('Unknown value for NSOperationQueuePriority: $value'),
  };
}

enum NSURLCacheStoragePolicy {
  NSURLCacheStorageAllowed(0),
  NSURLCacheStorageAllowedInMemoryOnly(1),
  NSURLCacheStorageNotAllowed(2);

  final int value;
  const NSURLCacheStoragePolicy(this.value);

  static NSURLCacheStoragePolicy fromValue(int value) => switch (value) {
    0 => NSURLCacheStorageAllowed,
    1 => NSURLCacheStorageAllowedInMemoryOnly,
    2 => NSURLCacheStorageNotAllowed,
    _ => throw ArgumentError('Unknown value for NSURLCacheStoragePolicy: $value'),
  };
}

final class __SecIdentity extends ffi.Opaque {}

final class __SecTrust extends ffi.Opaque {}

enum tls_protocol_version_t {
  tls_protocol_version_TLSv10(769),
  tls_protocol_version_TLSv11(770),
  tls_protocol_version_TLSv12(771),
  tls_protocol_version_TLSv13(772),
  tls_protocol_version_DTLSv10(-257),
  tls_protocol_version_DTLSv12(-259);

  final int value;
  const tls_protocol_version_t(this.value);

  static tls_protocol_version_t fromValue(int value) => switch (value) {
    769 => tls_protocol_version_TLSv10,
    770 => tls_protocol_version_TLSv11,
    771 => tls_protocol_version_TLSv12,
    772 => tls_protocol_version_TLSv13,
    -257 => tls_protocol_version_DTLSv10,
    -259 => tls_protocol_version_DTLSv12,
    _ => throw ArgumentError('Unknown value for tls_protocol_version_t: $value'),
  };
}

enum SSLProtocol {
  kSSLProtocolUnknown(0),
  kTLSProtocol1(4),
  kTLSProtocol11(7),
  kTLSProtocol12(8),
  kDTLSProtocol1(9),
  kTLSProtocol13(10),
  kDTLSProtocol12(11),
  kTLSProtocolMaxSupported(999),
  kSSLProtocol2(1),
  kSSLProtocol3(2),
  kSSLProtocol3Only(3),
  kTLSProtocol1Only(5),
  kSSLProtocolAll(6);

  final int value;
  const SSLProtocol(this.value);

  static SSLProtocol fromValue(int value) => switch (value) {
    0 => kSSLProtocolUnknown,
    4 => kTLSProtocol1,
    7 => kTLSProtocol11,
    8 => kTLSProtocol12,
    9 => kDTLSProtocol1,
    10 => kTLSProtocol13,
    11 => kDTLSProtocol12,
    999 => kTLSProtocolMaxSupported,
    1 => kSSLProtocol2,
    2 => kSSLProtocol3,
    3 => kSSLProtocol3Only,
    5 => kTLSProtocol1Only,
    6 => kSSLProtocolAll,
    _ => throw ArgumentError('Unknown value for SSLProtocol: $value'),
  };
}

enum NSURLCredentialPersistence {
  NSURLCredentialPersistenceNone(0),
  NSURLCredentialPersistenceForSession(1),
  NSURLCredentialPersistencePermanent(2),
  NSURLCredentialPersistenceSynchronizable(3);

  final int value;
  const NSURLCredentialPersistence(this.value);

  static NSURLCredentialPersistence fromValue(int value) => switch (value) {
    0 => NSURLCredentialPersistenceNone,
    1 => NSURLCredentialPersistenceForSession,
    2 => NSURLCredentialPersistencePermanent,
    3 => NSURLCredentialPersistenceSynchronizable,
    _ => throw ArgumentError('Unknown value for NSURLCredentialPersistence: $value'),
  };
}

enum NSURLRequestCachePolicy {
  NSURLRequestUseProtocolCachePolicy(0),
  NSURLRequestReloadIgnoringLocalCacheData(1),
  NSURLRequestReloadIgnoringLocalAndRemoteCacheData(4),
  NSURLRequestReturnCacheDataElseLoad(2),
  NSURLRequestReturnCacheDataDontLoad(3),
  NSURLRequestReloadRevalidatingCacheData(5);

  static const NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData;

  final int value;
  const NSURLRequestCachePolicy(this.value);

  static NSURLRequestCachePolicy fromValue(int value) => switch (value) {
    0 => NSURLRequestUseProtocolCachePolicy,
    1 => NSURLRequestReloadIgnoringLocalCacheData,
    4 => NSURLRequestReloadIgnoringLocalAndRemoteCacheData,
    2 => NSURLRequestReturnCacheDataElseLoad,
    3 => NSURLRequestReturnCacheDataDontLoad,
    5 => NSURLRequestReloadRevalidatingCacheData,
    _ => throw ArgumentError('Unknown value for NSURLRequestCachePolicy: $value'),
  };

  @override
  String toString() {
    if (this == NSURLRequestReloadIgnoringLocalCacheData)
      return "NSURLRequestCachePolicy.NSURLRequestReloadIgnoringLocalCacheData, NSURLRequestCachePolicy.NSURLRequestReloadIgnoringCacheData";
    return super.toString();
  }
}

enum NSURLRequestNetworkServiceType {
  NSURLNetworkServiceTypeDefault(0),
  NSURLNetworkServiceTypeVoIP(1),
  NSURLNetworkServiceTypeVideo(2),
  NSURLNetworkServiceTypeBackground(3),
  NSURLNetworkServiceTypeVoice(4),
  NSURLNetworkServiceTypeResponsiveData(6),
  NSURLNetworkServiceTypeAVStreaming(8),
  NSURLNetworkServiceTypeResponsiveAV(9),
  NSURLNetworkServiceTypeCallSignaling(11);

  final int value;
  const NSURLRequestNetworkServiceType(this.value);

  static NSURLRequestNetworkServiceType fromValue(int value) => switch (value) {
    0 => NSURLNetworkServiceTypeDefault,
    1 => NSURLNetworkServiceTypeVoIP,
    2 => NSURLNetworkServiceTypeVideo,
    3 => NSURLNetworkServiceTypeBackground,
    4 => NSURLNetworkServiceTypeVoice,
    6 => NSURLNetworkServiceTypeResponsiveData,
    8 => NSURLNetworkServiceTypeAVStreaming,
    9 => NSURLNetworkServiceTypeResponsiveAV,
    11 => NSURLNetworkServiceTypeCallSignaling,
    _ => throw ArgumentError('Unknown value for NSURLRequestNetworkServiceType: $value'),
  };
}

enum NSURLRequestAttribution {
  NSURLRequestAttributionDeveloper(0),
  NSURLRequestAttributionUser(1);

  final int value;
  const NSURLRequestAttribution(this.value);

  static NSURLRequestAttribution fromValue(int value) => switch (value) {
    0 => NSURLRequestAttributionDeveloper,
    1 => NSURLRequestAttributionUser,
    _ => throw ArgumentError('Unknown value for NSURLRequestAttribution: $value'),
  };
}

/// WARNING: NSExtensionContext is a stub. To generate bindings for this class, include
/// NSExtensionContext in your config's objc-interfaces list.
///
/// NSExtensionContext
class NSExtensionContext extends objc.NSObject {
  NSExtensionContext._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSExtensionContext', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSExtensionContext] that points to the same underlying object as [other].
  NSExtensionContext.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExtensionContext] that wraps the given raw object pointer.
  NSExtensionContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: NSExtensionRequestHandling is a stub. To generate bindings for this class, include
/// NSExtensionRequestHandling in your config's objc-protocols list.
///
/// NSExtensionRequestHandling
interface class NSExtensionRequestHandling extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  NSExtensionRequestHandling._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [NSExtensionRequestHandling] that points to the same underlying object as [other].
  NSExtensionRequestHandling.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSExtensionRequestHandling] that wraps the given raw object pointer.
  NSExtensionRequestHandling.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

sealed class NSFileVersionAddingOptions {
  static const NSFileVersionAddingByMoving = 1;
}

sealed class NSFileVersionReplacingOptions {
  static const NSFileVersionReplacingByMoving = 1;
}

sealed class NSFileWrapperReadingOptions {
  static const NSFileWrapperReadingImmediate = 1;
  static const NSFileWrapperReadingWithoutMapping = 2;
}

sealed class NSFileWrapperWritingOptions {
  static const NSFileWrapperWritingAtomic = 1;
  static const NSFileWrapperWritingWithNameUpdating = 2;
}

sealed class NSNetServiceOptions {
  static const NSNetServiceNoAutoRename = 1;
  static const NSNetServiceListenForConnections = 2;
}

/// WARNING: NSUndoManager is a stub. To generate bindings for this class, include
/// NSUndoManager in your config's objc-interfaces list.
///
/// NSUndoManager
class NSUndoManager extends objc.NSObject {
  NSUndoManager._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUndoManager', iOS: (false, (3, 0, 0)), macOS: (false, (10, 0, 0)));
  }

  /// Constructs a [NSUndoManager] that points to the same underlying object as [other].
  NSUndoManager.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUndoManager] that wraps the given raw object pointer.
  NSUndoManager.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum NSURLSessionTaskState {
  NSURLSessionTaskStateRunning(0),
  NSURLSessionTaskStateSuspended(1),
  NSURLSessionTaskStateCanceling(2),
  NSURLSessionTaskStateCompleted(3);

  final int value;
  const NSURLSessionTaskState(this.value);

  static NSURLSessionTaskState fromValue(int value) => switch (value) {
    0 => NSURLSessionTaskStateRunning,
    1 => NSURLSessionTaskStateSuspended,
    2 => NSURLSessionTaskStateCanceling,
    3 => NSURLSessionTaskStateCompleted,
    _ => throw ArgumentError('Unknown value for NSURLSessionTaskState: $value'),
  };
}

enum NSURLSessionWebSocketMessageType {
  NSURLSessionWebSocketMessageTypeData(0),
  NSURLSessionWebSocketMessageTypeString(1);

  final int value;
  const NSURLSessionWebSocketMessageType(this.value);

  static NSURLSessionWebSocketMessageType fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketMessageTypeData,
    1 => NSURLSessionWebSocketMessageTypeString,
    _ => throw ArgumentError('Unknown value for NSURLSessionWebSocketMessageType: $value'),
  };
}

enum NSURLSessionWebSocketCloseCode {
  NSURLSessionWebSocketCloseCodeInvalid(0),
  NSURLSessionWebSocketCloseCodeNormalClosure(1000),
  NSURLSessionWebSocketCloseCodeGoingAway(1001),
  NSURLSessionWebSocketCloseCodeProtocolError(1002),
  NSURLSessionWebSocketCloseCodeUnsupportedData(1003),
  NSURLSessionWebSocketCloseCodeNoStatusReceived(1005),
  NSURLSessionWebSocketCloseCodeAbnormalClosure(1006),
  NSURLSessionWebSocketCloseCodeInvalidFramePayloadData(1007),
  NSURLSessionWebSocketCloseCodePolicyViolation(1008),
  NSURLSessionWebSocketCloseCodeMessageTooBig(1009),
  NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing(1010),
  NSURLSessionWebSocketCloseCodeInternalServerError(1011),
  NSURLSessionWebSocketCloseCodeTLSHandshakeFailure(1015);

  final int value;
  const NSURLSessionWebSocketCloseCode(this.value);

  static NSURLSessionWebSocketCloseCode fromValue(int value) => switch (value) {
    0 => NSURLSessionWebSocketCloseCodeInvalid,
    1000 => NSURLSessionWebSocketCloseCodeNormalClosure,
    1001 => NSURLSessionWebSocketCloseCodeGoingAway,
    1002 => NSURLSessionWebSocketCloseCodeProtocolError,
    1003 => NSURLSessionWebSocketCloseCodeUnsupportedData,
    1005 => NSURLSessionWebSocketCloseCodeNoStatusReceived,
    1006 => NSURLSessionWebSocketCloseCodeAbnormalClosure,
    1007 => NSURLSessionWebSocketCloseCodeInvalidFramePayloadData,
    1008 => NSURLSessionWebSocketCloseCodePolicyViolation,
    1009 => NSURLSessionWebSocketCloseCodeMessageTooBig,
    1010 => NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing,
    1011 => NSURLSessionWebSocketCloseCodeInternalServerError,
    1015 => NSURLSessionWebSocketCloseCodeTLSHandshakeFailure,
    _ => throw ArgumentError('Unknown value for NSURLSessionWebSocketCloseCode: $value'),
  };
}

enum NSURLSessionMultipathServiceType {
  NSURLSessionMultipathServiceTypeNone(0),
  NSURLSessionMultipathServiceTypeHandover(1),
  NSURLSessionMultipathServiceTypeInteractive(2),
  NSURLSessionMultipathServiceTypeAggregate(3);

  final int value;
  const NSURLSessionMultipathServiceType(this.value);

  static NSURLSessionMultipathServiceType fromValue(int value) => switch (value) {
    0 => NSURLSessionMultipathServiceTypeNone,
    1 => NSURLSessionMultipathServiceTypeHandover,
    2 => NSURLSessionMultipathServiceTypeInteractive,
    3 => NSURLSessionMultipathServiceTypeAggregate,
    _ => throw ArgumentError('Unknown value for NSURLSessionMultipathServiceType: $value'),
  };
}

enum NSURLSessionDelayedRequestDisposition {
  NSURLSessionDelayedRequestContinueLoading(0),
  NSURLSessionDelayedRequestUseNewRequest(1),
  NSURLSessionDelayedRequestCancel(2);

  final int value;
  const NSURLSessionDelayedRequestDisposition(this.value);

  static NSURLSessionDelayedRequestDisposition fromValue(int value) => switch (value) {
    0 => NSURLSessionDelayedRequestContinueLoading,
    1 => NSURLSessionDelayedRequestUseNewRequest,
    2 => NSURLSessionDelayedRequestCancel,
    _ => throw ArgumentError('Unknown value for NSURLSessionDelayedRequestDisposition: $value'),
  };
}

enum NSURLSessionAuthChallengeDisposition {
  NSURLSessionAuthChallengeUseCredential(0),
  NSURLSessionAuthChallengePerformDefaultHandling(1),
  NSURLSessionAuthChallengeCancelAuthenticationChallenge(2),
  NSURLSessionAuthChallengeRejectProtectionSpace(3);

  final int value;
  const NSURLSessionAuthChallengeDisposition(this.value);

  static NSURLSessionAuthChallengeDisposition fromValue(int value) => switch (value) {
    0 => NSURLSessionAuthChallengeUseCredential,
    1 => NSURLSessionAuthChallengePerformDefaultHandling,
    2 => NSURLSessionAuthChallengeCancelAuthenticationChallenge,
    3 => NSURLSessionAuthChallengeRejectProtectionSpace,
    _ => throw ArgumentError('Unknown value for NSURLSessionAuthChallengeDisposition: $value'),
  };
}

/// WARNING: NSUserActivity is a stub. To generate bindings for this class, include
/// NSUserActivity in your config's objc-interfaces list.
///
/// NSUserActivity
class NSUserActivity extends objc.NSObject {
  NSUserActivity._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSUserActivity', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
  }

  /// Constructs a [NSUserActivity] that points to the same underlying object as [other].
  NSUserActivity.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSUserActivity] that wraps the given raw object pointer.
  NSUserActivity.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UISceneActivationState {
  UISceneActivationStateUnattached(-1),
  UISceneActivationStateForegroundActive(0),
  UISceneActivationStateForegroundInactive(1),
  UISceneActivationStateBackground(2);

  final int value;
  const UISceneActivationState(this.value);

  static UISceneActivationState fromValue(int value) => switch (value) {
    -1 => UISceneActivationStateUnattached,
    0 => UISceneActivationStateForegroundActive,
    1 => UISceneActivationStateForegroundInactive,
    2 => UISceneActivationStateBackground,
    _ => throw ArgumentError('Unknown value for UISceneActivationState: $value'),
  };
}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGPath extends ffi.Opaque {}

final class CGLayer extends ffi.Opaque {}

final class __CGEvent extends ffi.Opaque {}

enum UIMenuElementState {
  UIMenuElementStateOff(0),
  UIMenuElementStateOn(1),
  UIMenuElementStateMixed(2);

  final int value;
  const UIMenuElementState(this.value);

  static UIMenuElementState fromValue(int value) => switch (value) {
    0 => UIMenuElementStateOff,
    1 => UIMenuElementStateOn,
    2 => UIMenuElementStateMixed,
    _ => throw ArgumentError('Unknown value for UIMenuElementState: $value'),
  };
}

sealed class UIMenuElementAttributes {
  static const UIMenuElementAttributesDisabled = 1;
  static const UIMenuElementAttributesDestructive = 2;
  static const UIMenuElementAttributesHidden = 4;
}

late final _class_UIMenuElement = objc.getClass("UIMenuElement");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_title = objc.registerName("title");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_subtitle = objc.registerName("subtitle");
late final _sel_setSubtitle_ = objc.registerName("setSubtitle:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _class_UIImage = objc.getClass("UIImage");

/// UIImage
class UIImage extends objc.ObjCObjectBase {
  UIImage._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIImage] that points to the same underlying object as [other].
  UIImage.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIImage] that wraps the given raw object pointer.
  UIImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIImage);
  }
}

extension UIImage$Methods on UIImage {}

late final _sel_image = objc.registerName("image");
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
  fromFunction(Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))?.ref.retainAndReturnPointer() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true,
        );
}

late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_supportsSecureCoding = objc.registerName("supportsSecureCoding");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
        false,
      ).cast();
  static bool _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
        false,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// UIMenuElement
class UIMenuElement extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIMenuElement._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenuElement', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenuElement] that points to the same underlying object as [other].
  UIMenuElement.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuElement] that wraps the given raw object pointer.
  UIMenuElement.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenuElement].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenuElement);
  }

  /// alloc
  static UIMenuElement alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_alloc);
    return UIMenuElement.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenuElement allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIMenuElement, _sel_allocWithZone_, zone);
    return UIMenuElement.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIMenuElement new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenuElement, _sel_new);
    return UIMenuElement.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenuElement, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenuElement constructed with the default `new` method.
  factory UIMenuElement() => new$();
}

extension UIMenuElement$Methods on UIMenuElement {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Image to be displayed alongside the element's title.
  UIImage? get image {
    objc.checkOsVersionInternal('UIMenuElement.image', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UIMenuElement init() {
    objc.checkOsVersionInternal('UIMenuElement.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenuElement.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIMenuElement? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIMenuElement.castFromPointer($ret, retain: false, release: true);
  }

  /// The element's subtitle.
  set subtitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UIMenuElement.setSubtitle:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSubtitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The element's subtitle.
  objc.NSString? get subtitle {
    objc.checkOsVersionInternal('UIMenuElement.subtitle', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subtitle);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// The element's title.
  objc.NSString get title {
    objc.checkOsVersionInternal('UIMenuElement.title', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class UIMenuOptions {
  /// Show children inline in parent, instead of hierarchically
  static const UIMenuOptionsDisplayInline = 1;

  /// Indicates whether the menu should be rendered with a destructive appearance in its parent
  static const UIMenuOptionsDestructive = 2;

  /// Indicates whether the menu (and any submenus) should only allow a single "on" menu item.
  static const UIMenuOptionsSingleSelection = 32;
}

late final _class_UIMenu = objc.getClass("UIMenu");
late final _sel_identifier = objc.registerName("identifier");
late final _sel_options = objc.registerName("options");
final _objc_msgSend_1cz0z8u = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_children = objc.registerName("children");
late final _sel_selectedElements = objc.registerName("selectedElements");
late final _sel_menuWithChildren_ = objc.registerName("menuWithChildren:");
late final _sel_menuWithTitle_children_ = objc.registerName("menuWithTitle:children:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_menuWithTitle_image_identifier_options_children_ = objc.registerName(
  "menuWithTitle:image:identifier:options:children:",
);
final _objc_msgSend_zjuvxo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_menuByReplacingChildren_ = objc.registerName("menuByReplacingChildren:");

/// UIMenu
class UIMenu extends UIMenuElement {
  UIMenu._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIMenu', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIMenu] that points to the same underlying object as [other].
  UIMenu.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenu] that wraps the given raw object pointer.
  UIMenu.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIMenu].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIMenu);
  }

  /// alloc
  static UIMenu alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_alloc);
    return UIMenu.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIMenu allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIMenu, _sel_allocWithZone_, zone);
    return UIMenu.castFromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract Creates a UIMenu with an empty title, nil image, automatically generated identifier, and default options.
  ///
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithChildren(objc.NSArray children) {
    objc.checkOsVersionInternal('UIMenu.menuWithChildren:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIMenu, _sel_menuWithChildren_, children.ref.pointer);
    return UIMenu.castFromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Creates a UIMenu with the given arguments.
  ///
  /// @param title       The menu's title.
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithTitle(objc.NSString title, {required objc.NSArray children}) {
    final $ret = _objc_msgSend_15qeuct(
      _class_UIMenu,
      _sel_menuWithTitle_children_,
      title.ref.pointer,
      children.ref.pointer,
    );
    return UIMenu.castFromPointer($ret, retain: true, release: true);
  }

  /// !
  /// @abstract Creates a UIMenu with the given arguments.
  ///
  /// @param title       The menu's title.
  /// @param image       Image to be displayed alongside the menu's title.
  /// @param identifier  The menu's unique identifier. Pass nil to use an auto-generated identifier.
  /// @param options     The menu's options.
  /// @param children    The menu's action-based sub-elements and sub-menus.
  ///
  /// @return A new UIMenu.
  static UIMenu menuWithTitle$1(
    objc.NSString title, {
    UIImage? image,
    objc.NSString? identifier,
    required int options,
    required objc.NSArray children,
  }) {
    final $ret = _objc_msgSend_zjuvxo(
      _class_UIMenu,
      _sel_menuWithTitle_image_identifier_options_children_,
      title.ref.pointer,
      image?.ref.pointer ?? ffi.nullptr,
      identifier?.ref.pointer ?? ffi.nullptr,
      options,
      children.ref.pointer,
    );
    return UIMenu.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIMenu new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIMenu, _sel_new);
    return UIMenu.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIMenu, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIMenu constructed with the default `new` method.
  factory UIMenu() => new$();
}

extension UIMenu$Methods on UIMenu {
  /// The menu's sub-elements and sub-menus. On iOS 14.0, elements of your own menus are mutable, -copying a menu will produce mutable elements, and UIKit will take immutable copies of menus it receives. Prior to iOS 14.0, menus are always fully immutable.
  objc.NSArray get children {
    objc.checkOsVersionInternal('UIMenu.children', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_children);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// Unique identifier.
  objc.NSString get identifier {
    objc.checkOsVersionInternal('UIMenu.identifier', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UIMenu init() {
    objc.checkOsVersionInternal('UIMenu.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIMenu.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIMenu? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIMenu.castFromPointer($ret, retain: false, release: true);
  }

  /// !
  /// @abstract Copies this menu and replaces its children.
  ///
  /// @param newChildren  The replacement children.
  ///
  /// @return A copy of this menu with updated children.
  UIMenu menuByReplacingChildren(objc.NSArray newChildren) {
    objc.checkOsVersionInternal('UIMenu.menuByReplacingChildren:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.pointer, _sel_menuByReplacingChildren_, newChildren.ref.pointer);
    return UIMenu.castFromPointer($ret, retain: true, release: true);
  }

  /// Options.
  int get options {
    objc.checkOsVersionInternal('UIMenu.options', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_1cz0z8u(this.ref.pointer, _sel_options);
  }

  /// The element(s) in the menu and sub-menus that have an "on" menu item state.
  objc.NSArray get selectedElements {
    objc.checkOsVersionInternal('UIMenu.selectedElements', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedElements);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

sealed class UIKeyModifierFlags {
  static const UIKeyModifierAlphaShift = 65536;
  static const UIKeyModifierShift = 131072;
  static const UIKeyModifierControl = 262144;
  static const UIKeyModifierAlternate = 524288;
  static const UIKeyModifierCommand = 1048576;
  static const UIKeyModifierNumericPad = 2097152;
}

/// WARNING: UICommand is a stub. To generate bindings for this class, include
/// UICommand in your config's objc-interfaces list.
///
/// Represents an action to take.
class UICommand extends UIMenuElement {
  UICommand._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UICommand', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UICommand] that points to the same underlying object as [other].
  UICommand.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICommand] that wraps the given raw object pointer.
  UICommand.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UIEventType {
  UIEventTypeTouches(0),
  UIEventTypeMotion(1),
  UIEventTypeRemoteControl(2),
  UIEventTypePresses(3),
  UIEventTypeScroll(10),
  UIEventTypeHover(11),
  UIEventTypeTransform(14);

  final int value;
  const UIEventType(this.value);

  static UIEventType fromValue(int value) => switch (value) {
    0 => UIEventTypeTouches,
    1 => UIEventTypeMotion,
    2 => UIEventTypeRemoteControl,
    3 => UIEventTypePresses,
    10 => UIEventTypeScroll,
    11 => UIEventTypeHover,
    14 => UIEventTypeTransform,
    _ => throw ArgumentError('Unknown value for UIEventType: $value'),
  };
}

enum UIEventSubtype {
  UIEventSubtypeNone(0),
  UIEventSubtypeMotionShake(1),
  UIEventSubtypeRemoteControlPlay(100),
  UIEventSubtypeRemoteControlPause(101),
  UIEventSubtypeRemoteControlStop(102),
  UIEventSubtypeRemoteControlTogglePlayPause(103),
  UIEventSubtypeRemoteControlNextTrack(104),
  UIEventSubtypeRemoteControlPreviousTrack(105),
  UIEventSubtypeRemoteControlBeginSeekingBackward(106),
  UIEventSubtypeRemoteControlEndSeekingBackward(107),
  UIEventSubtypeRemoteControlBeginSeekingForward(108),
  UIEventSubtypeRemoteControlEndSeekingForward(109);

  final int value;
  const UIEventSubtype(this.value);

  static UIEventSubtype fromValue(int value) => switch (value) {
    0 => UIEventSubtypeNone,
    1 => UIEventSubtypeMotionShake,
    100 => UIEventSubtypeRemoteControlPlay,
    101 => UIEventSubtypeRemoteControlPause,
    102 => UIEventSubtypeRemoteControlStop,
    103 => UIEventSubtypeRemoteControlTogglePlayPause,
    104 => UIEventSubtypeRemoteControlNextTrack,
    105 => UIEventSubtypeRemoteControlPreviousTrack,
    106 => UIEventSubtypeRemoteControlBeginSeekingBackward,
    107 => UIEventSubtypeRemoteControlEndSeekingBackward,
    108 => UIEventSubtypeRemoteControlBeginSeekingForward,
    109 => UIEventSubtypeRemoteControlEndSeekingForward,
    _ => throw ArgumentError('Unknown value for UIEventSubtype: $value'),
  };
}

/// Set of buttons pressed for the current event
/// Raw format of: 1 << (buttonNumber - 1)
/// UIEventButtonMaskPrimary = 1 << 0
sealed class UIEventButtonMask {
  static const UIEventButtonMaskPrimary = 1;
  static const UIEventButtonMaskSecondary = 2;
}

/// WARNING: UIEvent is a stub. To generate bindings for this class, include
/// UIEvent in your config's objc-interfaces list.
///
/// UIEvent
class UIEvent extends objc.NSObject {
  UIEvent._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIEvent', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIEvent] that points to the same underlying object as [other].
  UIEvent.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIEvent] that wraps the given raw object pointer.
  UIEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIKeyCommand$1 is a stub. To generate bindings for this class, include
/// UIKeyCommand in your config's objc-interfaces list.
///
/// UIKeyCommand
class UIKeyCommand$1 extends UICommand {
  UIKeyCommand$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIKeyCommand', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIKeyCommand$1] that points to the same underlying object as [other].
  UIKeyCommand$1.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyCommand$1] that wraps the given raw object pointer.
  UIKeyCommand$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIUserActivityRestoring is a stub. To generate bindings for this class, include
/// UIUserActivityRestoring in your config's objc-protocols list.
///
/// UIUserActivityRestoring
interface class UIUserActivityRestoring extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIUserActivityRestoring._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIUserActivityRestoring] that points to the same underlying object as [other].
  UIUserActivityRestoring.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIUserActivityRestoring] that wraps the given raw object pointer.
  UIUserActivityRestoring.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// Construction methods for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
abstract final class ObjCBlock_NSDictionary_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> fromFunction(
    objc.NSDictionary Function(objc.NSDictionary) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(objc.NSDictionary.castFromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>`.
extension ObjCBlock_NSDictionary_NSDictionary$CallExtension
    on objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> {
  objc.NSDictionary call(objc.NSDictionary arg0) => objc.NSDictionary.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<objc.ObjCObject> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0.ref.pointer),
    retain: true,
    release: true,
  );
}

enum UIEditingInteractionConfiguration {
  UIEditingInteractionConfigurationNone(0),
  UIEditingInteractionConfigurationDefault(1);

  final int value;
  const UIEditingInteractionConfiguration(this.value);

  static UIEditingInteractionConfiguration fromValue(int value) => switch (value) {
    0 => UIEditingInteractionConfigurationNone,
    1 => UIEditingInteractionConfigurationDefault,
    _ => throw ArgumentError('Unknown value for UIEditingInteractionConfiguration: $value'),
  };
}

/// WARNING: UIResponderStandardEditActions is a stub. To generate bindings for this class, include
/// UIResponderStandardEditActions in your config's objc-protocols list.
///
/// UIResponderStandardEditActions
interface class UIResponderStandardEditActions extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIResponderStandardEditActions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIResponderStandardEditActions] that points to the same underlying object as [other].
  UIResponderStandardEditActions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponderStandardEditActions] that wraps the given raw object pointer.
  UIResponderStandardEditActions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _class_UIResponder = objc.getClass("UIResponder");
late final _sel_nextResponder = objc.registerName("nextResponder");
late final _sel_canBecomeFirstResponder = objc.registerName("canBecomeFirstResponder");
late final _sel_becomeFirstResponder = objc.registerName("becomeFirstResponder");
late final _sel_canResignFirstResponder = objc.registerName("canResignFirstResponder");
late final _sel_resignFirstResponder = objc.registerName("resignFirstResponder");
late final _sel_isFirstResponder = objc.registerName("isFirstResponder");
late final _sel_touchesBegan_withEvent_ = objc.registerName("touchesBegan:withEvent:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_touchesMoved_withEvent_ = objc.registerName("touchesMoved:withEvent:");
late final _sel_touchesEnded_withEvent_ = objc.registerName("touchesEnded:withEvent:");
late final _sel_touchesCancelled_withEvent_ = objc.registerName("touchesCancelled:withEvent:");
late final _sel_touchesEstimatedPropertiesUpdated_ = objc.registerName("touchesEstimatedPropertiesUpdated:");

/// WARNING: UIPressesEvent is a stub. To generate bindings for this class, include
/// UIPressesEvent in your config's objc-interfaces list.
///
/// UIPressesEvent
class UIPressesEvent extends objc.ObjCObjectBase {
  UIPressesEvent._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPressesEvent] that points to the same underlying object as [other].
  UIPressesEvent.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPressesEvent] that wraps the given raw object pointer.
  UIPressesEvent.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_pressesBegan_withEvent_ = objc.registerName("pressesBegan:withEvent:");
late final _sel_pressesChanged_withEvent_ = objc.registerName("pressesChanged:withEvent:");
late final _sel_pressesEnded_withEvent_ = objc.registerName("pressesEnded:withEvent:");
late final _sel_pressesCancelled_withEvent_ = objc.registerName("pressesCancelled:withEvent:");
late final _sel_motionBegan_withEvent_ = objc.registerName("motionBegan:withEvent:");
final _objc_msgSend_pov02z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_motionEnded_withEvent_ = objc.registerName("motionEnded:withEvent:");
late final _sel_motionCancelled_withEvent_ = objc.registerName("motionCancelled:withEvent:");
late final _sel_remoteControlReceivedWithEvent_ = objc.registerName("remoteControlReceivedWithEvent:");
late final _sel_canPerformAction_withSender_ = objc.registerName("canPerformAction:withSender:");
final _objc_msgSend_1f04296 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_targetForAction_withSender_ = objc.registerName("targetForAction:withSender:");
final _objc_msgSend_gx50so = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// WARNING: UIMenuBuilder is a stub. To generate bindings for this class, include
/// UIMenuBuilder in your config's objc-protocols list.
///
/// UIMenuBuilder
interface class UIMenuBuilder extends objc.ObjCProtocolBase {
  UIMenuBuilder._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMenuBuilder] that points to the same underlying object as [other].
  UIMenuBuilder.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMenuBuilder] that wraps the given raw object pointer.
  UIMenuBuilder.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_buildMenuWithBuilder_ = objc.registerName("buildMenuWithBuilder:");
late final _sel_validateCommand_ = objc.registerName("validateCommand:");
late final _sel_undoManager = objc.registerName("undoManager");
late final _sel_editingInteractionConfiguration = objc.registerName("editingInteractionConfiguration");
final _objc_msgSend_15pfzxv = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_cut_ = objc.registerName("cut:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$1$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_copy_ = objc.registerName("copy:");

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_objcObjCObject {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunction(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
              fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  listener(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  blocking(void Function(ffi.Pointer<ffi.Void>, objc.ObjCObjectBase?) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_objcObjCObject$CallExtension
    on objc.ObjCBlock<objc.Retained<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCObjectBase? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_paste_ = objc.registerName("paste:");
late final _sel_pasteAndMatchStyle_ = objc.registerName("pasteAndMatchStyle:");
late final _sel_pasteAndGo_ = objc.registerName("pasteAndGo:");
late final _sel_pasteAndSearch_ = objc.registerName("pasteAndSearch:");
late final _sel_select_ = objc.registerName("select:");
late final _sel_selectAll_ = objc.registerName("selectAll:");
late final _sel_delete_ = objc.registerName("delete:");
late final _sel_makeTextWritingDirectionLeftToRight_ = objc.registerName("makeTextWritingDirectionLeftToRight:");
late final _sel_makeTextWritingDirectionRightToLeft_ = objc.registerName("makeTextWritingDirectionRightToLeft:");
late final _sel_toggleBoldface_ = objc.registerName("toggleBoldface:");
late final _sel_toggleItalics_ = objc.registerName("toggleItalics:");
late final _sel_toggleUnderline_ = objc.registerName("toggleUnderline:");
late final _sel_increaseSize_ = objc.registerName("increaseSize:");
late final _sel_decreaseSize_ = objc.registerName("decreaseSize:");
late final _sel_updateTextAttributesWithConversionHandler_ = objc.registerName(
  "updateTextAttributesWithConversionHandler:",
);
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function()>`.
abstract final class ObjCBlock_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function()> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> fromFunction(void Function() fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function()>(
        objc.newClosureBlock(_closureCallable, () => fn(), keepIsolateAlive),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function()> listener(void Function() fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_listenerCallable.nativeFunction.cast(), () => fn(), keepIsolateAlive);
    final wrapper = _NativeLibrary_wrapListenerBlock_1pl9qdv(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function()> blocking(void Function() fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(_blockingCallable.nativeFunction.cast(), () => fn(), keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      () => fn(),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1pl9qdv(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function()>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) {
    (objc.getBlockClosure(block) as void Function())();
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter) {
    try {
      (objc.getBlockClosure(block) as void Function())();
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
  _blockingCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.isolateLocal(
        _blockingTrampoline,
      )..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
  _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.listener(
        _blockingTrampoline,
      )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) => block.ref.target.cast<ffi.NativeFunction<ffi.Void Function()>>().asFunction<void Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(_fnPtrTrampoline).cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) => (objc.getBlockClosure(block) as void Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>)>(_closureTrampoline).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function()>`.
extension ObjCBlock_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Void Function()> {
  void call() =>
      ref.pointer.ref.invoke
          .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
              fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: true, release: true)),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  listener(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1l4hxwm(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
  >
  blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1) =>
          fn(arg0, ObjCBlock_NSDictionary_NSDictionary.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1l4hxwm(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(
        arg0,
        arg1,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCBlockImpl> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCBlockImpl> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITextAttributesConversionHandler$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(ffi.Pointer<ffi.Void>, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)>)
        > {
  void call(ffi.Pointer<ffi.Void> arg0, objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> arg1) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCBlockImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCBlockImpl>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_print_ = objc.registerName("print:");
late final _sel_keyCommands = objc.registerName("keyCommands");

/// UIResponderKeyCommands
extension UIResponderKeyCommands on UIResponder {
  /// keyCommands
  objc.NSArray? get keyCommands {
    objc.checkOsVersionInternal('UIResponder.keyCommands', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyCommands);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UIView = objc.getClass("UIView");
late final _sel_layerClass = objc.registerName("layerClass");
late final _sel_initWithFrame_ = objc.registerName("initWithFrame:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
    >();
late final _sel_isUserInteractionEnabled = objc.registerName("isUserInteractionEnabled");
late final _sel_setUserInteractionEnabled_ = objc.registerName("setUserInteractionEnabled:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_tag = objc.registerName("tag");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTag_ = objc.registerName("setTag:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: CALayer is a stub. To generate bindings for this class, include
/// CALayer in your config's objc-interfaces list.
///
/// CALayer
class CALayer extends objc.NSObject implements objc.NSSecureCoding, CAMediaTiming {
  CALayer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CALayer', iOS: (false, (2, 0, 0)), macOS: (false, (10, 5, 0)));
  }

  /// Constructs a [CALayer] that points to the same underlying object as [other].
  CALayer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayer] that wraps the given raw object pointer.
  CALayer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_layer = objc.registerName("layer");
late final _sel_canBecomeFocused = objc.registerName("canBecomeFocused");
late final _sel_isFocused = objc.registerName("isFocused");
late final _sel_focusGroupIdentifier = objc.registerName("focusGroupIdentifier");
late final _sel_setFocusGroupIdentifier_ = objc.registerName("setFocusGroupIdentifier:");
late final _sel_focusGroupPriority = objc.registerName("focusGroupPriority");
late final _sel_setFocusGroupPriority_ = objc.registerName("setFocusGroupPriority:");

/// WARNING: UIFocusEffect is a stub. To generate bindings for this class, include
/// UIFocusEffect in your config's objc-interfaces list.
///
/// UIFocusEffect
class UIFocusEffect extends objc.ObjCObjectBase {
  UIFocusEffect._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEffect] that points to the same underlying object as [other].
  UIFocusEffect.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEffect] that wraps the given raw object pointer.
  UIFocusEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_focusEffect = objc.registerName("focusEffect");
late final _sel_setFocusEffect_ = objc.registerName("setFocusEffect:");

enum UISemanticContentAttribute {
  UISemanticContentAttributeUnspecified(0),
  UISemanticContentAttributePlayback(1),
  UISemanticContentAttributeSpatial(2),
  UISemanticContentAttributeForceLeftToRight(3),
  UISemanticContentAttributeForceRightToLeft(4);

  final int value;
  const UISemanticContentAttribute(this.value);

  static UISemanticContentAttribute fromValue(int value) => switch (value) {
    0 => UISemanticContentAttributeUnspecified,
    1 => UISemanticContentAttributePlayback,
    2 => UISemanticContentAttributeSpatial,
    3 => UISemanticContentAttributeForceLeftToRight,
    4 => UISemanticContentAttributeForceRightToLeft,
    _ => throw ArgumentError('Unknown value for UISemanticContentAttribute: $value'),
  };
}

late final _sel_semanticContentAttribute = objc.registerName("semanticContentAttribute");
final _objc_msgSend_i2u4x4 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSemanticContentAttribute_ = objc.registerName("setSemanticContentAttribute:");
final _objc_msgSend_162qwxu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

enum UIUserInterfaceLayoutDirection {
  UIUserInterfaceLayoutDirectionLeftToRight(0),
  UIUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const UIUserInterfaceLayoutDirection(this.value);

  static UIUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => UIUserInterfaceLayoutDirectionLeftToRight,
    1 => UIUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceLayoutDirection: $value'),
  };
}

late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_ = objc.registerName(
  "userInterfaceLayoutDirectionForSemanticContentAttribute:",
);
final _objc_msgSend_racczx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_ = objc.registerName(
  "userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:",
);
final _objc_msgSend_tz4p54 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)
      >
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_effectiveUserInterfaceLayoutDirection = objc.registerName("effectiveUserInterfaceLayoutDirection");
final _objc_msgSend_qj4fey = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_appearance = objc.registerName("appearance");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static instancetype _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<instancetype Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static instancetype _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_instancetype_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
        >()
        .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

/// WARNING: UIAppearanceContainer is a stub. To generate bindings for this class, include
/// UIAppearanceContainer in your config's objc-protocols list.
///
/// UIAppearanceContainer
interface class UIAppearanceContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIAppearanceContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearanceContainer] that points to the same underlying object as [other].
  UIAppearanceContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearanceContainer] that wraps the given raw object pointer.
  UIAppearanceContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_appearanceWhenContainedIn_ = objc.registerName("appearanceWhenContainedIn:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UIAppearanceContainer?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0,
        arg1.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg1, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_idUIAppearanceContainer$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>?)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UIAppearanceContainer? arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceWhenContainedInInstancesOfClasses_ = objc.registerName(
  "appearanceWhenContainedInInstancesOfClasses:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSArray.castFromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, objc.NSArray arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1.ref.pointer),
    retain: true,
    release: true,
  );
}

/// WARNING: UITraitCollection is a stub. To generate bindings for this class, include
/// UITraitCollection in your config's objc-interfaces list.
///
/// ! A trait collection encapsulates the system traits of an interface's environment.
class UITraitCollection extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UITraitCollection._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITraitCollection', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UITraitCollection] that points to the same underlying object as [other].
  UITraitCollection.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitCollection] that wraps the given raw object pointer.
  UITraitCollection.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_appearanceForTraitCollection_ = objc.registerName("appearanceForTraitCollection:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UITraitCollection.castFromPointer(arg1, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
            )
          >
        >()
        .asFunction<
          instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0, arg1.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_appearanceForTraitCollection_whenContainedIn_ = objc.registerName(
  "appearanceForTraitCollection:whenContainedIn:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
  >
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIAppearanceContainer?) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
            arg0,
            UITraitCollection.castFromPointer(arg1, retain: true, release: true),
            arg2.address == 0 ? null : UIAppearanceContainer.castFromPointer(arg2, retain: true, release: true),
          ).ref.retainAndAutorelease(),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_idUIAppearanceContainer$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>?)
        > {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, UIAppearanceContainer? arg2) =>
      objc.ObjCObjectBase(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObject> arg1,
                  ffi.Pointer<objc.ObjCObject> arg2,
                )
              >
            >()
            .asFunction<
              instancetype Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
              )
            >()(ref.pointer, arg0, arg1.ref.pointer, arg2?.ref.pointer ?? ffi.nullptr),
        retain: true,
        release: true,
      );
}

late final _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_ = objc.registerName(
  "appearanceForTraitCollection:whenContainedInInstancesOfClasses:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>
  fromFunction(
    Dartinstancetype Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: true, release: true),
        objc.NSArray.castFromPointer(arg2, retain: true, release: true),
      ).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)>`.
extension ObjCBlock_instancetype_ffiVoid_UITraitCollection_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, UITraitCollection, objc.NSArray)> {
  Dartinstancetype call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, objc.NSArray arg2) => objc.ObjCObjectBase(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              ffi.Pointer<objc.ObjCObject> arg1,
              ffi.Pointer<objc.ObjCObject> arg2,
            )
          >
        >()
        .asFunction<
          instancetype Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_center = objc.registerName("center");
final _objc_msgSend_1uwdhlk = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1uwdhlkStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGPoint>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSPoint_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static objc.CGPoint _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static objc.CGPoint _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGPoint Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSPoint_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGPoint Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_setCenter_ = objc.registerName("setCenter:");
final _objc_msgSend_iy8iz6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint)>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSPoint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1bktu2(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGPoint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1bktu2(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, objc.CGPoint)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>
      block.ref.target
          .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)>>()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGPoint))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSPoint$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGPoint)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGPoint)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

late final _sel_bounds = objc.registerName("bounds");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static objc.CGRect _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGRect Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSRect_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_transform = objc.registerName("transform");
final _objc_msgSend_5qswvj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qswvjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<CGAffineTransform>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<CGAffineTransform>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();

/// Construction methods for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGAffineTransform_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> fromFunction(
    CGAffineTransform Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static CGAffineTransform _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static CGAffineTransform _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as CGAffineTransform Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGAffineTransform_ffiVoid$CallExtension
    on objc.ObjCBlock<CGAffineTransform Function(ffi.Pointer<ffi.Void>)> {
  CGAffineTransform call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
            >
          >()
          .asFunction<CGAffineTransform Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
        ref.pointer,
        arg0,
      );
}

late final _sel_setTransform_ = objc.registerName("setTransform:");
final _objc_msgSend_qgt66z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> listener(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1lznlw3(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CGAffineTransform) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1lznlw3(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            CGAffineTransform,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, CGAffineTransform)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            CGAffineTransform,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    CGAffineTransform arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, CGAffineTransform))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGAffineTransform$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CGAffineTransform)> {
  void call(ffi.Pointer<ffi.Void> arg0, CGAffineTransform arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl> block,
                ffi.Pointer<ffi.Void> arg0,
                CGAffineTransform arg1,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, CGAffineTransform)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

enum UIDynamicItemCollisionBoundsType {
  UIDynamicItemCollisionBoundsTypeRectangle(0),
  UIDynamicItemCollisionBoundsTypeEllipse(1),
  UIDynamicItemCollisionBoundsTypePath(2);

  final int value;
  const UIDynamicItemCollisionBoundsType(this.value);

  static UIDynamicItemCollisionBoundsType fromValue(int value) => switch (value) {
    0 => UIDynamicItemCollisionBoundsTypeRectangle,
    1 => UIDynamicItemCollisionBoundsTypeEllipse,
    2 => UIDynamicItemCollisionBoundsTypePath,
    _ => throw ArgumentError('Unknown value for UIDynamicItemCollisionBoundsType: $value'),
  };
}

late final _sel_collisionBoundsType = objc.registerName("collisionBoundsType");
final _objc_msgSend_k9iunc = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIDynamicItemCollisionBoundsType Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0).value, keepIsolateAlive),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
        0,
      ).cast();
  static int _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
        0,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIDynamicItemCollisionBoundsType_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  UIDynamicItemCollisionBoundsType call(ffi.Pointer<ffi.Void> arg0) => UIDynamicItemCollisionBoundsType.fromValue(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
  );
}

/// WARNING: UIBezierPath is a stub. To generate bindings for this class, include
/// UIBezierPath in your config's objc-interfaces list.
///
/// UIBezierPath
class UIBezierPath extends objc.ObjCObjectBase {
  UIBezierPath._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIBezierPath] that points to the same underlying object as [other].
  UIBezierPath.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBezierPath] that wraps the given raw object pointer.
  UIBezierPath.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_collisionBoundingPath = objc.registerName("collisionBoundingPath");

/// Construction methods for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIBezierPath_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIBezierPath Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIBezierPath_ffiVoid$CallExtension on objc.ObjCBlock<UIBezierPath Function(ffi.Pointer<ffi.Void>)> {
  UIBezierPath call(ffi.Pointer<ffi.Void> arg0) => UIBezierPath.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_traitCollection = objc.registerName("traitCollection");

/// Construction methods for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UITraitCollection_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UITraitCollection Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UITraitCollection_ffiVoid$CallExtension
    on objc.ObjCBlock<UITraitCollection Function(ffi.Pointer<ffi.Void>)> {
  UITraitCollection call(ffi.Pointer<ffi.Void> arg0) => UITraitCollection.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_traitCollectionDidChange_ = objc.registerName("traitCollectionDidChange:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, arg1.address == 0 ? null : UITraitCollection.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection?)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1?.ref.pointer ?? ffi.nullptr);
}

/// WARNING: UICoordinateSpace is a stub. To generate bindings for this class, include
/// UICoordinateSpace in your config's objc-protocols list.
///
/// UICoordinateSpace
interface class UICoordinateSpace extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UICoordinateSpace._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UICoordinateSpace] that points to the same underlying object as [other].
  UICoordinateSpace.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UICoordinateSpace] that wraps the given raw object pointer.
  UICoordinateSpace.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_convertPoint_toCoordinateSpace_ = objc.registerName("convertPoint:toCoordinateSpace:");
final _objc_msgSend_3l1tu1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_3l1tu1Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, UICoordinateSpace) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGPoint _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              objc.CGPoint Function(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, ffi.Pointer<objc.ObjCObject> arg2)
            >
          >()
          .asFunction<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>()(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGPoint _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGPoint arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGPoint Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGPoint,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGPoint_ffiVoid_CGPoint_idUICoordinateSpace$CallExtension
    on objc.ObjCBlock<objc.CGPoint Function(ffi.Pointer<ffi.Void>, objc.CGPoint, ffi.Pointer<objc.ObjCObject>)> {
  objc.CGPoint call(ffi.Pointer<ffi.Void> arg0, objc.CGPoint arg1, UICoordinateSpace arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGPoint Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGPoint arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertPoint_fromCoordinateSpace_ = objc.registerName("convertPoint:fromCoordinateSpace:");
late final _sel_convertRect_toCoordinateSpace_ = objc.registerName("convertRect:toCoordinateSpace:");
final _objc_msgSend_2olghr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGRect Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
final _objc_msgSend_2olghrStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, UICoordinateSpace) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UICoordinateSpace.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              objc.CGRect Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, ffi.Pointer<objc.ObjCObject> arg2)
            >
          >()
          .asFunction<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>()(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGRect _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGRect Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGRect,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_CGRect_ffiVoid_CGRect_idUICoordinateSpace$CallExtension
    on objc.ObjCBlock<objc.CGRect Function(ffi.Pointer<ffi.Void>, objc.CGRect, ffi.Pointer<objc.ObjCObject>)> {
  objc.CGRect call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1, UICoordinateSpace arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGRect Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGRect arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        objc.CGRect Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_convertRect_fromCoordinateSpace_ = objc.registerName("convertRect:fromCoordinateSpace:");
late final _sel_frame = objc.registerName("frame");
late final _sel_isTransparentFocusItem = objc.registerName("isTransparentFocusItem");

/// WARNING: UIFocusMovementHint is a stub. To generate bindings for this class, include
/// UIFocusMovementHint in your config's objc-interfaces list.
///
/// UIFocusMovementHint
class UIFocusMovementHint extends objc.ObjCObjectBase {
  UIFocusMovementHint._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusMovementHint] that points to the same underlying object as [other].
  UIFocusMovementHint.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusMovementHint] that wraps the given raw object pointer.
  UIFocusMovementHint.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_didHintFocusMovement_ = objc.registerName("didHintFocusMovement:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> listener(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusMovementHint.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusMovementHint$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusMovementHint)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusMovementHint arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_preferredFocusEnvironments = objc.registerName("preferredFocusEnvironments");

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

/// WARNING: UIFocusEnvironment is a stub. To generate bindings for this class, include
/// UIFocusEnvironment in your config's objc-protocols list.
///
/// Objects conforming to UIFocusEnvironment influence and respond to focus behavior within a specific area of the screen that they control.
interface class UIFocusEnvironment extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIFocusEnvironment._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusEnvironment] that points to the same underlying object as [other].
  UIFocusEnvironment.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusEnvironment] that wraps the given raw object pointer.
  UIFocusEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_parentFocusEnvironment = objc.registerName("parentFocusEnvironment");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusEnvironment_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIFocusEnvironment? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusEnvironment_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusEnvironment? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusEnvironment.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

/// WARNING: UIFocusItemContainer is a stub. To generate bindings for this class, include
/// UIFocusItemContainer in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItemContainer are responsible for providing which focus items they
/// contain and where they are.
interface class UIFocusItemContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIFocusItemContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemContainer] that points to the same underlying object as [other].
  UIFocusItemContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemContainer] that wraps the given raw object pointer.
  UIFocusItemContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_focusItemContainer = objc.registerName("focusItemContainer");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUIFocusItemContainer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIFocusItemContainer? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUIFocusItemContainer_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  UIFocusItemContainer? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIFocusItemContainer.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_setNeedsFocusUpdate = objc.registerName("setNeedsFocusUpdate");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_ovsamd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_updateFocusIfNeeded = objc.registerName("updateFocusIfNeeded");

/// WARNING: UIFocusUpdateContext is a stub. To generate bindings for this class, include
/// UIFocusUpdateContext in your config's objc-interfaces list.
///
/// UIFocusUpdateContexts provide information relevant to a specific focus update from one view to another. They are ephemeral objects that are usually discarded after the update is finished.
class UIFocusUpdateContext extends objc.NSObject {
  UIFocusUpdateContext._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusUpdateContext', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusUpdateContext] that points to the same underlying object as [other].
  UIFocusUpdateContext.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusUpdateContext] that wraps the given raw object pointer.
  UIFocusUpdateContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_shouldUpdateFocusInContext_ = objc.registerName("shouldUpdateFocusInContext:");

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_bool_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_bool_ffiVoid_UIFocusUpdateContext$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  bool call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// WARNING: UIFocusAnimationCoordinator is a stub. To generate bindings for this class, include
/// UIFocusAnimationCoordinator in your config's objc-interfaces list.
///
/// UIFocusAnimationCoordinator is used to coordinate disparate animations that are related to a focus update.
class UIFocusAnimationCoordinator extends objc.NSObject {
  UIFocusAnimationCoordinator._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFocusAnimationCoordinator', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIFocusAnimationCoordinator] that points to the same underlying object as [other].
  UIFocusAnimationCoordinator.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusAnimationCoordinator] that wraps the given raw object pointer.
  UIFocusAnimationCoordinator.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_didUpdateFocusInContext_withAnimationCoordinator_ = objc.registerName(
  "didUpdateFocusInContext:withAnimationCoordinator:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UIFocusUpdateContext.castFromPointer(arg1, retain: false, release: true),
        UIFocusAnimationCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UIFocusUpdateContext_UIFocusAnimationCoordinator$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext, UIFocusAnimationCoordinator)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1, UIFocusAnimationCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_soundIdentifierForFocusUpdateInContext_ = objc.registerName("soundIdentifierForFocusUpdateInContext:");

/// Construction methods for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
abstract final class ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> fromFunction(
    objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(
            arg0,
            UIFocusUpdateContext.castFromPointer(arg1, retain: true, release: true),
          )?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)
            >
          >()
          .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
        arg0,
        arg1,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)>`.
extension ObjCBlock_UIFocusSoundIdentifier_ffiVoid_UIFocusUpdateContext$CallExtension
    on objc.ObjCBlock<objc.NSString? Function(ffi.Pointer<ffi.Void>, UIFocusUpdateContext)> {
  objc.NSString? call(ffi.Pointer<ffi.Void> arg0, UIFocusUpdateContext arg1) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSString.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_preferredFocusedView = objc.registerName("preferredFocusedView");

/// Construction methods for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_UIView_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UIView? Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_UIView_ffiVoid$CallExtension on objc.ObjCBlock<UIView? Function(ffi.Pointer<ffi.Void>)> {
  UIView? call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0)
              .address ==
          0
      ? null
      : UIView.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
              >()(ref.pointer, arg0),
          retain: true,
          release: true,
        );
}

late final _sel_coordinateSpace = objc.registerName("coordinateSpace");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idUICoordinateSpace_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> fromFunction(
    UICoordinateSpace Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idUICoordinateSpace_ffiVoid$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  UICoordinateSpace call(ffi.Pointer<ffi.Void> arg0) => UICoordinateSpace.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(
      ref.pointer,
      arg0,
    ),
    retain: true,
    release: true,
  );
}

late final _sel_focusItemsInRect_ = objc.registerName("focusItemsInRect:");

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
abstract final class ObjCBlock_NSArray_ffiVoid_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>
    ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => fn(arg0, arg1).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.CGRect)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGRect arg1,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>, objc.CGRect))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)>`.
extension ObjCBlock_NSArray_ffiVoid_CGRect$CallExtension
    on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>, objc.CGRect)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0, objc.CGRect arg1) => objc.NSArray.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<ffi.Void> arg0,
              objc.CGRect arg1,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGRect)
        >()(ref.pointer, arg0, arg1),
    retain: true,
    release: true,
  );
}

late final _sel_displayLayer_ = objc.registerName("displayLayer:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_drawLayer_inContext_ = objc.registerName("drawLayer:inContext:");
final _objc_msgSend_a4xp11 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<CGContext>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: true, release: true), arg2),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> listener(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_qvcerx(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<CGContext> arg2) =>
          fn(arg0, CALayer.castFromPointer(arg1, retain: false, release: true), arg2),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_qvcerx(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<CGContext>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<CGContext>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<CGContext>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGContext>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(
                ffi.Pointer<ffi.Void> arg0,
                ffi.Pointer<objc.ObjCObject> arg1,
                ffi.Pointer<CGContext> arg2,
              )
            >
          >()
          .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>)>()(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<CGContext>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<CGContext> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<CGContext>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<CGContext>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CALayer_CGContextRef$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, CALayer, ffi.Pointer<CGContext>)> {
  void call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, ffi.Pointer<CGContext> arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<CGContext> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<CGContext>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

late final _sel_layerWillDraw_ = objc.registerName("layerWillDraw:");
late final _sel_layoutSublayersOfLayer_ = objc.registerName("layoutSublayersOfLayer:");

/// WARNING: CAAction is a stub. To generate bindings for this class, include
/// CAAction in your config's objc-protocols list.
///
/// CAAction
interface class CAAction extends objc.ObjCProtocolBase {
  CAAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CAAction] that points to the same underlying object as [other].
  CAAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAAction] that wraps the given raw object pointer.
  CAAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_actionForLayer_forKey_ = objc.registerName("actionForLayer:forKey:");

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
abstract final class ObjCBlock_idCAAction_ffiVoid_CALayer_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>
  fromFunction(CAAction? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
              fn(
                arg0,
                CALayer.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)>`.
extension ObjCBlock_idCAAction_ffiVoid_CALayer_NSString$CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, CALayer, objc.NSString)> {
  CAAction? call(ffi.Pointer<ffi.Void> arg0, CALayer arg1, objc.NSString arg2) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : CAAction.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

late final _sel_setFrame_ = objc.registerName("setFrame:");
final _objc_msgSend_1okkq16 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
late final _sel_setBounds_ = objc.registerName("setBounds:");

final class CATransform3D extends ffi.Struct {
  @ffi.Double()
  external double m11;

  @ffi.Double()
  external double m12;

  @ffi.Double()
  external double m13;

  @ffi.Double()
  external double m14;

  @ffi.Double()
  external double m21;

  @ffi.Double()
  external double m22;

  @ffi.Double()
  external double m23;

  @ffi.Double()
  external double m24;

  @ffi.Double()
  external double m31;

  @ffi.Double()
  external double m32;

  @ffi.Double()
  external double m33;

  @ffi.Double()
  external double m34;

  @ffi.Double()
  external double m41;

  @ffi.Double()
  external double m42;

  @ffi.Double()
  external double m43;

  @ffi.Double()
  external double m44;
}

late final _sel_transform3D = objc.registerName("transform3D");
final _objc_msgSend_5qlg3j = objc.msgSendPointer
    .cast<ffi.NativeFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<CATransform3D Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_5qlg3jStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<CATransform3D>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<CATransform3D>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setTransform3D_ = objc.registerName("setTransform3D:");
final _objc_msgSend_1s50tpz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CATransform3D)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, CATransform3D)>();
late final _sel_contentScaleFactor = objc.registerName("contentScaleFactor");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentScaleFactor_ = objc.registerName("setContentScaleFactor:");
final _objc_msgSend_hwm8nu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_isMultipleTouchEnabled = objc.registerName("isMultipleTouchEnabled");
late final _sel_setMultipleTouchEnabled_ = objc.registerName("setMultipleTouchEnabled:");
late final _sel_isExclusiveTouch = objc.registerName("isExclusiveTouch");
late final _sel_setExclusiveTouch_ = objc.registerName("setExclusiveTouch:");
late final _sel_hitTest_withEvent_ = objc.registerName("hitTest:withEvent:");
final _objc_msgSend_u7nfz8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_pointInside_withEvent_ = objc.registerName("pointInside:withEvent:");
final _objc_msgSend_yvwe5y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGPoint,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGPoint,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_convertPoint_toView_ = objc.registerName("convertPoint:toView:");
late final _sel_convertPoint_fromView_ = objc.registerName("convertPoint:fromView:");
late final _sel_convertRect_toView_ = objc.registerName("convertRect:toView:");
late final _sel_convertRect_fromView_ = objc.registerName("convertRect:fromView:");
late final _sel_autoresizesSubviews = objc.registerName("autoresizesSubviews");
late final _sel_setAutoresizesSubviews_ = objc.registerName("setAutoresizesSubviews:");

sealed class UIViewAutoresizing {
  static const UIViewAutoresizingNone = 0;
  static const UIViewAutoresizingFlexibleLeftMargin = 1;
  static const UIViewAutoresizingFlexibleWidth = 2;
  static const UIViewAutoresizingFlexibleRightMargin = 4;
  static const UIViewAutoresizingFlexibleTopMargin = 8;
  static const UIViewAutoresizingFlexibleHeight = 16;
  static const UIViewAutoresizingFlexibleBottomMargin = 32;
}

late final _sel_autoresizingMask = objc.registerName("autoresizingMask");
final _objc_msgSend_sq30wq = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAutoresizingMask_ = objc.registerName("setAutoresizingMask:");
final _objc_msgSend_qjq6uk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_sizeThatFits_ = objc.registerName("sizeThatFits:");
final _objc_msgSend_1owrp3b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)
      >
    >()
    .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();
final _objc_msgSend_1owrp3bStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)
    >();
late final _sel_sizeToFit = objc.registerName("sizeToFit");

/// UIViewGeometry
extension UIViewGeometry on UIView {
  /// autoresizesSubviews
  bool get autoresizesSubviews {
    objc.checkOsVersionInternal('UIView.autoresizesSubviews', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_autoresizesSubviews);
  }

  /// autoresizingMask
  int get autoresizingMask {
    objc.checkOsVersionInternal('UIView.autoresizingMask', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_sq30wq(this.ref.pointer, _sel_autoresizingMask);
  }

  /// bounds
  objc.CGRect get bounds$1 {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// center
  objc.CGPoint get center$1 {
    objc.checkOsVersionInternal('UIView.center', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, this.ref.pointer, _sel_center)
        : $ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// contentScaleFactor
  double get contentScaleFactor {
    objc.checkOsVersionInternal('UIView.contentScaleFactor', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_contentScaleFactor)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_contentScaleFactor);
  }

  /// convertPoint:fromView:
  objc.CGPoint convertPoint$2(objc.CGPoint point, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromView_,
            point,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toView:
  objc.CGPoint convertPoint$3(objc.CGPoint point, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toView_,
            point,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromView:
  objc.CGRect convertRect$2(objc.CGRect rect, {UIView? fromView}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromView_,
            rect,
            fromView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toView:
  objc.CGRect convertRect$3(objc.CGRect rect, {UIView? toView}) {
    objc.checkOsVersionInternal('UIView.convertRect:toView:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toView_,
            rect,
            toView?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// frame
  objc.CGRect get frame$1 {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// hitTest:withEvent:
  UIView? hitTest(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.hitTest:withEvent:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_u7nfz8(
      this.ref.pointer,
      _sel_hitTest_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// isExclusiveTouch
  bool get isExclusiveTouch {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isExclusiveTouch);
  }

  /// isMultipleTouchEnabled
  bool get isMultipleTouchEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMultipleTouchEnabled);
  }

  /// pointInside:withEvent:
  bool pointInside(objc.CGPoint point, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIView.pointInside:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_yvwe5y(
      this.ref.pointer,
      _sel_pointInside_withEvent_,
      point,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setAutoresizesSubviews:
  set autoresizesSubviews(bool value) {
    objc.checkOsVersionInternal('UIView.setAutoresizesSubviews:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutoresizesSubviews_, value);
  }

  /// setAutoresizingMask:
  set autoresizingMask(int value) {
    objc.checkOsVersionInternal('UIView.setAutoresizingMask:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qjq6uk(this.ref.pointer, _sel_setAutoresizingMask_, value);
  }

  /// setBounds:
  set bounds$1(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setBounds_, value);
  }

  /// setCenter:
  set center$1(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIView.setCenter:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// setContentScaleFactor:
  set contentScaleFactor(double value) {
    objc.checkOsVersionInternal('UIView.setContentScaleFactor:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setContentScaleFactor_, value);
  }

  /// setExclusiveTouch:
  set isExclusiveTouch(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExclusiveTouch_, value);
  }

  /// setFrame:
  set frame$1(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setFrame:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setFrame_, value);
  }

  /// setMultipleTouchEnabled:
  set isMultipleTouchEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setMultipleTouchEnabled_, value);
  }

  /// setTransform3D:
  set transform3D(CATransform3D value) {
    objc.checkOsVersionInternal('UIView.setTransform3D:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s50tpz(this.ref.pointer, _sel_setTransform3D_, value);
  }

  /// setTransform:
  set transform$1(CGAffineTransform value) {
    objc.checkOsVersionInternal('UIView.setTransform:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// sizeThatFits:
  objc.CGSize sizeThatFits(objc.CGSize size) {
    objc.checkOsVersionInternal('UIView.sizeThatFits:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret($ptr, this.ref.pointer, _sel_sizeThatFits_, size)
        : $ptr.ref = _objc_msgSend_1owrp3b(this.ref.pointer, _sel_sizeThatFits_, size);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// sizeToFit
  void sizeToFit() {
    objc.checkOsVersionInternal('UIView.sizeToFit', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_sizeToFit);
  }

  /// transform
  CGAffineTransform get transform$1 {
    objc.checkOsVersionInternal('UIView.transform', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret($ptr, this.ref.pointer, _sel_transform)
        : $ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>($finalizable);
  }

  /// transform3D
  CATransform3D get transform3D {
    objc.checkOsVersionInternal('UIView.transform3D', iOS: (false, (13, 0, 0)));
    final $ptr = pkg_ffi.calloc<CATransform3D>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qlg3jStret($ptr, this.ref.pointer, _sel_transform3D)
        : $ptr.ref = _objc_msgSend_5qlg3j(this.ref.pointer, _sel_transform3D);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CATransform3D>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CATransform3D>($finalizable);
  }
}

late final _sel_superview = objc.registerName("superview");
late final _sel_subviews = objc.registerName("subviews");
late final _class_UIWindow = objc.getClass("UIWindow");

/// WARNING: UIWindowScene is a stub. To generate bindings for this class, include
/// UIWindowScene in your config's objc-interfaces list.
///
/// UIWindowScene
class UIWindowScene extends UIScene {
  UIWindowScene._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIWindowScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIWindowScene] that points to the same underlying object as [other].
  UIWindowScene.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindowScene] that wraps the given raw object pointer.
  UIWindowScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_initWithWindowScene_ = objc.registerName("initWithWindowScene:");
late final _sel_windowScene = objc.registerName("windowScene");
late final _sel_setWindowScene_ = objc.registerName("setWindowScene:");
late final _sel_canResizeToFitContent = objc.registerName("canResizeToFitContent");
late final _sel_setCanResizeToFitContent_ = objc.registerName("setCanResizeToFitContent:");
late final _class_UIScreen = objc.getClass("UIScreen");

/// UIScreen
class UIScreen extends objc.ObjCObjectBase {
  UIScreen._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIScreen] that points to the same underlying object as [other].
  UIScreen.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScreen] that wraps the given raw object pointer.
  UIScreen.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIScreen].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIScreen);
  }
}

extension UIScreen$Methods on UIScreen {}

late final _sel_screen = objc.registerName("screen");
late final _sel_setScreen_ = objc.registerName("setScreen:");
late final _sel_windowLevel = objc.registerName("windowLevel");
late final _sel_setWindowLevel_ = objc.registerName("setWindowLevel:");
late final _sel_isKeyWindow = objc.registerName("isKeyWindow");
late final _sel_canBecomeKeyWindow = objc.registerName("canBecomeKeyWindow");
late final _sel_becomeKeyWindow = objc.registerName("becomeKeyWindow");
late final _sel_resignKeyWindow = objc.registerName("resignKeyWindow");
late final _sel_makeKeyWindow = objc.registerName("makeKeyWindow");
late final _sel_makeKeyAndVisible = objc.registerName("makeKeyAndVisible");
late final _class_UIViewController = objc.getClass("UIViewController");
late final _sel_initWithNibName_bundle_ = objc.registerName("initWithNibName:bundle:");
late final _sel_view = objc.registerName("view");
late final _sel_setView_ = objc.registerName("setView:");
late final _sel_loadView = objc.registerName("loadView");
late final _sel_loadViewIfNeeded = objc.registerName("loadViewIfNeeded");
late final _sel_viewIfLoaded = objc.registerName("viewIfLoaded");
late final _sel_viewWillUnload = objc.registerName("viewWillUnload");
late final _sel_viewDidUnload = objc.registerName("viewDidUnload");
late final _sel_viewDidLoad = objc.registerName("viewDidLoad");
late final _sel_isViewLoaded = objc.registerName("isViewLoaded");
late final _sel_nibName = objc.registerName("nibName");
late final _sel_nibBundle = objc.registerName("nibBundle");

/// WARNING: UIStoryboard is a stub. To generate bindings for this class, include
/// UIStoryboard in your config's objc-interfaces list.
///
/// UIStoryboard
class UIStoryboard extends objc.ObjCObjectBase {
  UIStoryboard._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboard] that points to the same underlying object as [other].
  UIStoryboard.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboard] that wraps the given raw object pointer.
  UIStoryboard.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_storyboard = objc.registerName("storyboard");
late final _sel_performSegueWithIdentifier_sender_ = objc.registerName("performSegueWithIdentifier:sender:");
late final _sel_shouldPerformSegueWithIdentifier_sender_ = objc.registerName(
  "shouldPerformSegueWithIdentifier:sender:",
);
final _objc_msgSend_1lsax7n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// WARNING: UIStoryboardSegue is a stub. To generate bindings for this class, include
/// UIStoryboardSegue in your config's objc-interfaces list.
///
/// UIStoryboardSegue
class UIStoryboardSegue extends objc.ObjCObjectBase {
  UIStoryboardSegue._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboardSegue] that points to the same underlying object as [other].
  UIStoryboardSegue.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboardSegue] that wraps the given raw object pointer.
  UIStoryboardSegue.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_prepareForSegue_sender_ = objc.registerName("prepareForSegue:sender:");
late final _sel_canPerformUnwindSegueAction_fromViewController_sender_ = objc.registerName(
  "canPerformUnwindSegueAction:fromViewController:sender:",
);
final _objc_msgSend_iv7uhk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_canPerformUnwindSegueAction_fromViewController_withSender_ = objc.registerName(
  "canPerformUnwindSegueAction:fromViewController:withSender:",
);

/// WARNING: UIStoryboardUnwindSegueSource is a stub. To generate bindings for this class, include
/// UIStoryboardUnwindSegueSource in your config's objc-interfaces list.
///
/// UIStoryboardUnwindSegueSource
class UIStoryboardUnwindSegueSource extends objc.ObjCObjectBase {
  UIStoryboardUnwindSegueSource._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStoryboardUnwindSegueSource] that points to the same underlying object as [other].
  UIStoryboardUnwindSegueSource.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStoryboardUnwindSegueSource] that wraps the given raw object pointer.
  UIStoryboardUnwindSegueSource.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_allowedChildViewControllersForUnwindingFromSource_ = objc.registerName(
  "allowedChildViewControllersForUnwindingFromSource:",
);
late final _sel_childViewControllerContainingSegueSource_ = objc.registerName(
  "childViewControllerContainingSegueSource:",
);
late final _sel_viewControllerForUnwindSegueAction_fromViewController_withSender_ = objc.registerName(
  "viewControllerForUnwindSegueAction:fromViewController:withSender:",
);
final _objc_msgSend_cfx8ce = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_unwindForSegue_towardsViewController_ = objc.registerName("unwindForSegue:towardsViewController:");
late final _sel_segueForUnwindingToViewController_fromViewController_identifier_ = objc.registerName(
  "segueForUnwindingToViewController:fromViewController:identifier:",
);
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_viewWillAppear_ = objc.registerName("viewWillAppear:");
late final _sel_viewDidAppear_ = objc.registerName("viewDidAppear:");
late final _sel_viewWillDisappear_ = objc.registerName("viewWillDisappear:");
late final _sel_viewDidDisappear_ = objc.registerName("viewDidDisappear:");
late final _sel_viewWillLayoutSubviews = objc.registerName("viewWillLayoutSubviews");
late final _sel_viewDidLayoutSubviews = objc.registerName("viewDidLayoutSubviews");
late final _sel_setTitle_ = objc.registerName("setTitle:");
late final _sel_didReceiveMemoryWarning = objc.registerName("didReceiveMemoryWarning");
late final _sel_parentViewController = objc.registerName("parentViewController");
late final _sel_modalViewController = objc.registerName("modalViewController");
late final _sel_presentedViewController = objc.registerName("presentedViewController");
late final _sel_presentingViewController = objc.registerName("presentingViewController");
late final _sel_definesPresentationContext = objc.registerName("definesPresentationContext");
late final _sel_setDefinesPresentationContext_ = objc.registerName("setDefinesPresentationContext:");
late final _sel_providesPresentationContextTransitionStyle = objc.registerName(
  "providesPresentationContextTransitionStyle",
);
late final _sel_setProvidesPresentationContextTransitionStyle_ = objc.registerName(
  "setProvidesPresentationContextTransitionStyle:",
);
late final _sel_restoresFocusAfterTransition = objc.registerName("restoresFocusAfterTransition");
late final _sel_setRestoresFocusAfterTransition_ = objc.registerName("setRestoresFocusAfterTransition:");
late final _sel_isBeingPresented = objc.registerName("isBeingPresented");
late final _sel_isBeingDismissed = objc.registerName("isBeingDismissed");
late final _sel_isMovingToParentViewController = objc.registerName("isMovingToParentViewController");
late final _sel_isMovingFromParentViewController = objc.registerName("isMovingFromParentViewController");
late final _sel_presentViewController_animated_completion_ = objc.registerName(
  "presentViewController:animated:completion:",
);
final _objc_msgSend_na2nx0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_dismissViewControllerAnimated_completion_ = objc.registerName(
  "dismissViewControllerAnimated:completion:",
);
final _objc_msgSend_1ocak7a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_presentModalViewController_animated_ = objc.registerName("presentModalViewController:animated:");
final _objc_msgSend_6p7ndb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, bool)
    >();
late final _sel_dismissModalViewControllerAnimated_ = objc.registerName("dismissModalViewControllerAnimated:");

enum UIModalTransitionStyle {
  UIModalTransitionStyleCoverVertical(0),
  UIModalTransitionStyleFlipHorizontal(1),
  UIModalTransitionStyleCrossDissolve(2),
  UIModalTransitionStylePartialCurl(3);

  final int value;
  const UIModalTransitionStyle(this.value);

  static UIModalTransitionStyle fromValue(int value) => switch (value) {
    0 => UIModalTransitionStyleCoverVertical,
    1 => UIModalTransitionStyleFlipHorizontal,
    2 => UIModalTransitionStyleCrossDissolve,
    3 => UIModalTransitionStylePartialCurl,
    _ => throw ArgumentError('Unknown value for UIModalTransitionStyle: $value'),
  };
}

late final _sel_modalTransitionStyle = objc.registerName("modalTransitionStyle");
final _objc_msgSend_17t73u4 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setModalTransitionStyle_ = objc.registerName("setModalTransitionStyle:");
final _objc_msgSend_gt147a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

enum UIModalPresentationStyle {
  UIModalPresentationFullScreen(0),
  UIModalPresentationPageSheet(1),
  UIModalPresentationFormSheet(2),
  UIModalPresentationCurrentContext(3),
  UIModalPresentationCustom(4),
  UIModalPresentationOverFullScreen(5),
  UIModalPresentationOverCurrentContext(6),
  UIModalPresentationPopover(7),
  UIModalPresentationBlurOverFullScreen(8),
  UIModalPresentationNone(-1),
  UIModalPresentationAutomatic(-2);

  final int value;
  const UIModalPresentationStyle(this.value);

  static UIModalPresentationStyle fromValue(int value) => switch (value) {
    0 => UIModalPresentationFullScreen,
    1 => UIModalPresentationPageSheet,
    2 => UIModalPresentationFormSheet,
    3 => UIModalPresentationCurrentContext,
    4 => UIModalPresentationCustom,
    5 => UIModalPresentationOverFullScreen,
    6 => UIModalPresentationOverCurrentContext,
    7 => UIModalPresentationPopover,
    8 => UIModalPresentationBlurOverFullScreen,
    -1 => UIModalPresentationNone,
    -2 => UIModalPresentationAutomatic,
    _ => throw ArgumentError('Unknown value for UIModalPresentationStyle: $value'),
  };
}

late final _sel_modalPresentationStyle = objc.registerName("modalPresentationStyle");
final _objc_msgSend_1jdzuw5 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setModalPresentationStyle_ = objc.registerName("setModalPresentationStyle:");
final _objc_msgSend_19sk1nl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_modalPresentationCapturesStatusBarAppearance = objc.registerName(
  "modalPresentationCapturesStatusBarAppearance",
);
late final _sel_setModalPresentationCapturesStatusBarAppearance_ = objc.registerName(
  "setModalPresentationCapturesStatusBarAppearance:",
);
late final _sel_disablesAutomaticKeyboardDismissal = objc.registerName("disablesAutomaticKeyboardDismissal");
late final _sel_wantsFullScreenLayout = objc.registerName("wantsFullScreenLayout");
late final _sel_setWantsFullScreenLayout_ = objc.registerName("setWantsFullScreenLayout:");

sealed class UIRectEdge {
  static const UIRectEdgeNone = 0;
  static const UIRectEdgeTop = 1;
  static const UIRectEdgeLeft = 2;
  static const UIRectEdgeBottom = 4;
  static const UIRectEdgeRight = 8;
  static const UIRectEdgeAll = 15;
}

late final _sel_edgesForExtendedLayout = objc.registerName("edgesForExtendedLayout");
final _objc_msgSend_qrqu1s = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setEdgesForExtendedLayout_ = objc.registerName("setEdgesForExtendedLayout:");
final _objc_msgSend_1xy78x6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_extendedLayoutIncludesOpaqueBars = objc.registerName("extendedLayoutIncludesOpaqueBars");
late final _sel_setExtendedLayoutIncludesOpaqueBars_ = objc.registerName("setExtendedLayoutIncludesOpaqueBars:");
late final _sel_automaticallyAdjustsScrollViewInsets = objc.registerName("automaticallyAdjustsScrollViewInsets");
late final _sel_setAutomaticallyAdjustsScrollViewInsets_ = objc.registerName(
  "setAutomaticallyAdjustsScrollViewInsets:",
);
late final _class_UIScrollView = objc.getClass("UIScrollView");
late final _sel_contentOffset = objc.registerName("contentOffset");
late final _sel_setContentOffset_ = objc.registerName("setContentOffset:");
late final _sel_contentSize = objc.registerName("contentSize");
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGSize>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGSize_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.CGSize Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static objc.CGSize _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<objc.CGSize Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static objc.CGSize _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as objc.CGSize Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGSize_ffiVoid$CallExtension on objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>)> {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>
      >()
      .asFunction<objc.CGSize Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_setContentSize_ = objc.registerName("setContentSize:");
final _objc_msgSend_13lgpwz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize)>();

final class UIEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double left;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double right;
}

late final _sel_contentInset = objc.registerName("contentInset");
final _objc_msgSend_ct4cu5 = objc.msgSendPointer
    .cast<ffi.NativeFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<UIEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_ct4cu5Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<UIEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<UIEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setContentInset_ = objc.registerName("setContentInset:");
final _objc_msgSend_1g8fos5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIEdgeInsets)>();
late final _sel_adjustedContentInset = objc.registerName("adjustedContentInset");
late final _sel_adjustedContentInsetDidChange = objc.registerName("adjustedContentInsetDidChange");

enum UIScrollViewContentInsetAdjustmentBehavior {
  UIScrollViewContentInsetAdjustmentAutomatic(0),
  UIScrollViewContentInsetAdjustmentScrollableAxes(1),
  UIScrollViewContentInsetAdjustmentNever(2),
  UIScrollViewContentInsetAdjustmentAlways(3);

  final int value;
  const UIScrollViewContentInsetAdjustmentBehavior(this.value);

  static UIScrollViewContentInsetAdjustmentBehavior fromValue(int value) => switch (value) {
    0 => UIScrollViewContentInsetAdjustmentAutomatic,
    1 => UIScrollViewContentInsetAdjustmentScrollableAxes,
    2 => UIScrollViewContentInsetAdjustmentNever,
    3 => UIScrollViewContentInsetAdjustmentAlways,
    _ => throw ArgumentError('Unknown value for UIScrollViewContentInsetAdjustmentBehavior: $value'),
  };
}

late final _sel_contentInsetAdjustmentBehavior = objc.registerName("contentInsetAdjustmentBehavior");
final _objc_msgSend_1ubvjfk = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentInsetAdjustmentBehavior_ = objc.registerName("setContentInsetAdjustmentBehavior:");
final _objc_msgSend_1l2otbm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_automaticallyAdjustsScrollIndicatorInsets = objc.registerName(
  "automaticallyAdjustsScrollIndicatorInsets",
);
late final _sel_setAutomaticallyAdjustsScrollIndicatorInsets_ = objc.registerName(
  "setAutomaticallyAdjustsScrollIndicatorInsets:",
);

/// WARNING: UILayoutGuide is a stub. To generate bindings for this class, include
/// UILayoutGuide in your config's objc-interfaces list.
///
/// UILayoutGuide
class UILayoutGuide extends objc.NSObject implements objc.NSCoding {
  UILayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILayoutGuide', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UILayoutGuide] that points to the same underlying object as [other].
  UILayoutGuide.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILayoutGuide] that wraps the given raw object pointer.
  UILayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_contentLayoutGuide = objc.registerName("contentLayoutGuide");
late final _sel_frameLayoutGuide = objc.registerName("frameLayoutGuide");

/// WARNING: UIScrollViewDelegate is a stub. To generate bindings for this class, include
/// UIScrollViewDelegate in your config's objc-protocols list.
///
/// UIScrollViewDelegate
interface class UIScrollViewDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIScrollViewDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIScrollViewDelegate] that points to the same underlying object as [other].
  UIScrollViewDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScrollViewDelegate] that wraps the given raw object pointer.
  UIScrollViewDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_delegate = objc.registerName("delegate");
late final _sel_setDelegate_ = objc.registerName("setDelegate:");
late final _sel_isDirectionalLockEnabled = objc.registerName("isDirectionalLockEnabled");
late final _sel_setDirectionalLockEnabled_ = objc.registerName("setDirectionalLockEnabled:");
late final _sel_bounces = objc.registerName("bounces");
late final _sel_setBounces_ = objc.registerName("setBounces:");
late final _sel_alwaysBounceVertical = objc.registerName("alwaysBounceVertical");
late final _sel_setAlwaysBounceVertical_ = objc.registerName("setAlwaysBounceVertical:");
late final _sel_alwaysBounceHorizontal = objc.registerName("alwaysBounceHorizontal");
late final _sel_setAlwaysBounceHorizontal_ = objc.registerName("setAlwaysBounceHorizontal:");
late final _sel_isPagingEnabled = objc.registerName("isPagingEnabled");
late final _sel_setPagingEnabled_ = objc.registerName("setPagingEnabled:");
late final _sel_isScrollEnabled = objc.registerName("isScrollEnabled");
late final _sel_setScrollEnabled_ = objc.registerName("setScrollEnabled:");
late final _sel_showsVerticalScrollIndicator = objc.registerName("showsVerticalScrollIndicator");
late final _sel_setShowsVerticalScrollIndicator_ = objc.registerName("setShowsVerticalScrollIndicator:");
late final _sel_showsHorizontalScrollIndicator = objc.registerName("showsHorizontalScrollIndicator");
late final _sel_setShowsHorizontalScrollIndicator_ = objc.registerName("setShowsHorizontalScrollIndicator:");

enum UIScrollViewIndicatorStyle {
  UIScrollViewIndicatorStyleDefault(0),
  UIScrollViewIndicatorStyleBlack(1),
  UIScrollViewIndicatorStyleWhite(2);

  final int value;
  const UIScrollViewIndicatorStyle(this.value);

  static UIScrollViewIndicatorStyle fromValue(int value) => switch (value) {
    0 => UIScrollViewIndicatorStyleDefault,
    1 => UIScrollViewIndicatorStyleBlack,
    2 => UIScrollViewIndicatorStyleWhite,
    _ => throw ArgumentError('Unknown value for UIScrollViewIndicatorStyle: $value'),
  };
}

late final _sel_indicatorStyle = objc.registerName("indicatorStyle");
final _objc_msgSend_10fw709 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setIndicatorStyle_ = objc.registerName("setIndicatorStyle:");
final _objc_msgSend_10eov2d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_verticalScrollIndicatorInsets = objc.registerName("verticalScrollIndicatorInsets");
late final _sel_setVerticalScrollIndicatorInsets_ = objc.registerName("setVerticalScrollIndicatorInsets:");
late final _sel_horizontalScrollIndicatorInsets = objc.registerName("horizontalScrollIndicatorInsets");
late final _sel_setHorizontalScrollIndicatorInsets_ = objc.registerName("setHorizontalScrollIndicatorInsets:");
late final _sel_scrollIndicatorInsets = objc.registerName("scrollIndicatorInsets");
late final _sel_setScrollIndicatorInsets_ = objc.registerName("setScrollIndicatorInsets:");
late final _sel_decelerationRate = objc.registerName("decelerationRate");
late final _sel_setDecelerationRate_ = objc.registerName("setDecelerationRate:");

enum UIScrollViewIndexDisplayMode {
  UIScrollViewIndexDisplayModeAutomatic(0),
  UIScrollViewIndexDisplayModeAlwaysHidden(1);

  final int value;
  const UIScrollViewIndexDisplayMode(this.value);

  static UIScrollViewIndexDisplayMode fromValue(int value) => switch (value) {
    0 => UIScrollViewIndexDisplayModeAutomatic,
    1 => UIScrollViewIndexDisplayModeAlwaysHidden,
    _ => throw ArgumentError('Unknown value for UIScrollViewIndexDisplayMode: $value'),
  };
}

late final _sel_indexDisplayMode = objc.registerName("indexDisplayMode");
final _objc_msgSend_1vmqitm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setIndexDisplayMode_ = objc.registerName("setIndexDisplayMode:");
final _objc_msgSend_r5kwx4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setContentOffset_animated_ = objc.registerName("setContentOffset:animated:");
final _objc_msgSend_uyhzs2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGPoint, bool)>();
late final _sel_scrollRectToVisible_animated_ = objc.registerName("scrollRectToVisible:animated:");
final _objc_msgSend_1sfhlx6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool)>();
late final _sel_flashScrollIndicators = objc.registerName("flashScrollIndicators");
late final _sel_isTracking = objc.registerName("isTracking");
late final _sel_isDragging = objc.registerName("isDragging");
late final _sel_isDecelerating = objc.registerName("isDecelerating");
late final _sel_delaysContentTouches = objc.registerName("delaysContentTouches");
late final _sel_setDelaysContentTouches_ = objc.registerName("setDelaysContentTouches:");
late final _sel_canCancelContentTouches = objc.registerName("canCancelContentTouches");
late final _sel_setCanCancelContentTouches_ = objc.registerName("setCanCancelContentTouches:");
late final _sel_touchesShouldBegin_withEvent_inContentView_ = objc.registerName(
  "touchesShouldBegin:withEvent:inContentView:",
);
final _objc_msgSend_gtxojt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_touchesShouldCancelInContentView_ = objc.registerName("touchesShouldCancelInContentView:");
late final _sel_minimumZoomScale = objc.registerName("minimumZoomScale");
late final _sel_setMinimumZoomScale_ = objc.registerName("setMinimumZoomScale:");
late final _sel_maximumZoomScale = objc.registerName("maximumZoomScale");
late final _sel_setMaximumZoomScale_ = objc.registerName("setMaximumZoomScale:");
late final _sel_zoomScale = objc.registerName("zoomScale");
late final _sel_setZoomScale_ = objc.registerName("setZoomScale:");
late final _sel_setZoomScale_animated_ = objc.registerName("setZoomScale:animated:");
final _objc_msgSend_ghxo7e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, bool)>();
late final _sel_zoomToRect_animated_ = objc.registerName("zoomToRect:animated:");
late final _sel_bouncesZoom = objc.registerName("bouncesZoom");
late final _sel_setBouncesZoom_ = objc.registerName("setBouncesZoom:");
late final _sel_isZooming = objc.registerName("isZooming");
late final _sel_isZoomBouncing = objc.registerName("isZoomBouncing");
late final _sel_scrollsToTop = objc.registerName("scrollsToTop");
late final _sel_setScrollsToTop_ = objc.registerName("setScrollsToTop:");

/// WARNING: UIPanGestureRecognizer is a stub. To generate bindings for this class, include
/// UIPanGestureRecognizer in your config's objc-interfaces list.
///
/// UIPanGestureRecognizer
class UIPanGestureRecognizer extends UIGestureRecognizer {
  UIPanGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIPanGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UIPanGestureRecognizer] that points to the same underlying object as [other].
  UIPanGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPanGestureRecognizer] that wraps the given raw object pointer.
  UIPanGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_panGestureRecognizer = objc.registerName("panGestureRecognizer");

/// WARNING: UIPinchGestureRecognizer is a stub. To generate bindings for this class, include
/// UIPinchGestureRecognizer in your config's objc-interfaces list.
///
/// UIPinchGestureRecognizer
class UIPinchGestureRecognizer extends objc.ObjCObjectBase {
  UIPinchGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPinchGestureRecognizer] that points to the same underlying object as [other].
  UIPinchGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPinchGestureRecognizer] that wraps the given raw object pointer.
  UIPinchGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_pinchGestureRecognizer = objc.registerName("pinchGestureRecognizer");

/// WARNING: UIGestureRecognizer is a stub. To generate bindings for this class, include
/// UIGestureRecognizer in your config's objc-interfaces list.
///
/// UIGestureRecognizer
class UIGestureRecognizer extends objc.NSObject {
  UIGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIGestureRecognizer] that points to the same underlying object as [other].
  UIGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIGestureRecognizer] that wraps the given raw object pointer.
  UIGestureRecognizer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_directionalPressGestureRecognizer = objc.registerName("directionalPressGestureRecognizer");

enum UIScrollViewKeyboardDismissMode {
  UIScrollViewKeyboardDismissModeNone(0),
  UIScrollViewKeyboardDismissModeOnDrag(1),
  UIScrollViewKeyboardDismissModeInteractive(2);

  final int value;
  const UIScrollViewKeyboardDismissMode(this.value);

  static UIScrollViewKeyboardDismissMode fromValue(int value) => switch (value) {
    0 => UIScrollViewKeyboardDismissModeNone,
    1 => UIScrollViewKeyboardDismissModeOnDrag,
    2 => UIScrollViewKeyboardDismissModeInteractive,
    _ => throw ArgumentError('Unknown value for UIScrollViewKeyboardDismissMode: $value'),
  };
}

late final _sel_keyboardDismissMode = objc.registerName("keyboardDismissMode");
final _objc_msgSend_1v83s9d = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setKeyboardDismissMode_ = objc.registerName("setKeyboardDismissMode:");
final _objc_msgSend_1c75p8t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: UIRefreshControl is a stub. To generate bindings for this class, include
/// UIRefreshControl in your config's objc-interfaces list.
///
/// UIRefreshControl
class UIRefreshControl extends UIControl {
  UIRefreshControl._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIRefreshControl', iOS: (false, (6, 0, 0)));
  }

  /// Constructs a [UIRefreshControl] that points to the same underlying object as [other].
  UIRefreshControl.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIRefreshControl] that wraps the given raw object pointer.
  UIRefreshControl.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_refreshControl = objc.registerName("refreshControl");
late final _sel_setRefreshControl_ = objc.registerName("setRefreshControl:");
late final _sel_visibleSize = objc.registerName("visibleSize");

/// WARNING: UIFocusItemScrollableContainer is a stub. To generate bindings for this class, include
/// UIFocusItemScrollableContainer in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItemScrollableContainer are updated accordingly to ensure the
/// focused item remains visible on the screen.
interface class UIFocusItemScrollableContainer extends objc.ObjCProtocolBase implements UIFocusItemContainer {
  UIFocusItemScrollableContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItemScrollableContainer] that points to the same underlying object as [other].
  UIFocusItemScrollableContainer.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItemScrollableContainer] that wraps the given raw object pointer.
  UIFocusItemScrollableContainer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// UIScrollView
class UIScrollView extends UIView implements objc.NSCoding, UIFocusItemScrollableContainer {
  UIScrollView._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIScrollView] that points to the same underlying object as [other].
  UIScrollView.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScrollView] that wraps the given raw object pointer.
  UIScrollView.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIScrollView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIScrollView);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIScrollView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIScrollView, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIScrollView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UIScrollView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIScrollView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UIScrollView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }
}

extension UIScrollView$Methods on UIScrollView {
  /// adjustedContentInset
  UIEdgeInsets get adjustedContentInset {
    objc.checkOsVersionInternal('UIScrollView.adjustedContentInset', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_adjustedContentInset)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_adjustedContentInset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// adjustedContentInsetDidChange
  void adjustedContentInsetDidChange() {
    objc.checkOsVersionInternal('UIScrollView.adjustedContentInsetDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_adjustedContentInsetDidChange);
  }

  /// alwaysBounceHorizontal
  bool get alwaysBounceHorizontal {
    objc.checkOsVersionInternal('UIScrollView.alwaysBounceHorizontal', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_alwaysBounceHorizontal);
  }

  /// alwaysBounceVertical
  bool get alwaysBounceVertical {
    objc.checkOsVersionInternal('UIScrollView.alwaysBounceVertical', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_alwaysBounceVertical);
  }

  /// automaticallyAdjustsScrollIndicatorInsets
  bool get automaticallyAdjustsScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.automaticallyAdjustsScrollIndicatorInsets', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_automaticallyAdjustsScrollIndicatorInsets);
  }

  /// bounces
  bool get bounces {
    objc.checkOsVersionInternal('UIScrollView.bounces', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_bounces);
  }

  /// bouncesZoom
  bool get bouncesZoom {
    objc.checkOsVersionInternal('UIScrollView.bouncesZoom', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_bouncesZoom);
  }

  /// canCancelContentTouches
  bool get canCancelContentTouches {
    objc.checkOsVersionInternal('UIScrollView.canCancelContentTouches', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canCancelContentTouches);
  }

  /// contentInset
  UIEdgeInsets get contentInset {
    objc.checkOsVersionInternal('UIScrollView.contentInset', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_contentInset)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_contentInset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// contentInsetAdjustmentBehavior
  UIScrollViewContentInsetAdjustmentBehavior get contentInsetAdjustmentBehavior {
    objc.checkOsVersionInternal('UIScrollView.contentInsetAdjustmentBehavior', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_1ubvjfk(this.ref.pointer, _sel_contentInsetAdjustmentBehavior);
    return UIScrollViewContentInsetAdjustmentBehavior.fromValue($ret);
  }

  /// contentLayoutGuide
  UILayoutGuide get contentLayoutGuide {
    objc.checkOsVersionInternal('UIScrollView.contentLayoutGuide', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contentLayoutGuide);
    return UILayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// The current content offset of this scrollable container. If the scrollable container has a `bounds` property, `bounds.origin` must be equal to `contentOffset`.
  objc.CGPoint get contentOffset {
    objc.checkOsVersionInternal('UIScrollView.contentOffset', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, this.ref.pointer, _sel_contentOffset)
        : $ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_contentOffset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// The total size of the content contained by this container. If this size exceeds the size of
  /// this container's visible size, then scrolling is possible.
  objc.CGSize get contentSize {
    objc.checkOsVersionInternal('UIScrollView.contentSize', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret($ptr, this.ref.pointer, _sel_contentSize)
        : $ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_contentSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// The coordinate space of the focus items contained in this container. The focus items returned by focusItemsInRect: should report their frames in this coordinate space.
  /// If you are implementing this protocol, you may find it convenient to return the UIScreen as your coordinate space, and ensure that your contained items report their frames in screen space.
  /// Similarly, you might find that your focus items' containing UIView or UIWindow is the most convenient coordinate space to use.
  /// You may also choose to implement your own object that conforms to UICoordinateSpace, if that is the most natural solution for your architecture.
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal('UIScrollView.coordinateSpace', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.castFromPointer($ret, retain: true, release: true);
  }

  /// decelerationRate
  double get decelerationRate {
    objc.checkOsVersionInternal('UIScrollView.decelerationRate', iOS: (false, (3, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_decelerationRate)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_decelerationRate);
  }

  /// delaysContentTouches
  bool get delaysContentTouches {
    objc.checkOsVersionInternal('UIScrollView.delaysContentTouches', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_delaysContentTouches);
  }

  /// delegate
  UIScrollViewDelegate? get delegate {
    objc.checkOsVersionInternal('UIScrollView.delegate', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : UIScrollViewDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// directionalPressGestureRecognizer
  UIGestureRecognizer get directionalPressGestureRecognizer {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_directionalPressGestureRecognizer);
    return UIGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// flashScrollIndicators
  void flashScrollIndicators() {
    objc.checkOsVersionInternal('UIScrollView.flashScrollIndicators', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_flashScrollIndicators);
  }

  /// Returns an array of all focus items within this container that intersect with the provided rect. `rect` is expressed in `coordinateSpace`.
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIScrollView.focusItemsInRect:', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// frameLayoutGuide
  UILayoutGuide get frameLayoutGuide {
    objc.checkOsVersionInternal('UIScrollView.frameLayoutGuide', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_frameLayoutGuide);
    return UILayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// horizontalScrollIndicatorInsets
  UIEdgeInsets get horizontalScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.horizontalScrollIndicatorInsets', iOS: (false, (11, 1, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_horizontalScrollIndicatorInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_horizontalScrollIndicatorInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// indexDisplayMode
  UIScrollViewIndexDisplayMode get indexDisplayMode {
    final $ret = _objc_msgSend_1vmqitm(this.ref.pointer, _sel_indexDisplayMode);
    return UIScrollViewIndexDisplayMode.fromValue($ret);
  }

  /// indicatorStyle
  UIScrollViewIndicatorStyle get indicatorStyle {
    objc.checkOsVersionInternal('UIScrollView.indicatorStyle', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_10fw709(this.ref.pointer, _sel_indicatorStyle);
    return UIScrollViewIndicatorStyle.fromValue($ret);
  }

  /// initWithCoder:
  UIScrollView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIScrollView.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UIScrollView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIScrollView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIScrollView.castFromPointer($ret, retain: false, release: true);
  }

  /// isDecelerating
  bool get isDecelerating {
    objc.checkOsVersionInternal('UIScrollView.isDecelerating', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDecelerating);
  }

  /// isDirectionalLockEnabled
  bool get isDirectionalLockEnabled {
    objc.checkOsVersionInternal('UIScrollView.isDirectionalLockEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDirectionalLockEnabled);
  }

  /// isDragging
  bool get isDragging {
    objc.checkOsVersionInternal('UIScrollView.isDragging', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDragging);
  }

  /// isPagingEnabled
  bool get isPagingEnabled {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isPagingEnabled);
  }

  /// isScrollEnabled
  bool get isScrollEnabled {
    objc.checkOsVersionInternal('UIScrollView.isScrollEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isScrollEnabled);
  }

  /// isTracking
  bool get isTracking {
    objc.checkOsVersionInternal('UIScrollView.isTracking', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTracking);
  }

  /// isZoomBouncing
  bool get isZoomBouncing {
    objc.checkOsVersionInternal('UIScrollView.isZoomBouncing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZoomBouncing);
  }

  /// isZooming
  bool get isZooming {
    objc.checkOsVersionInternal('UIScrollView.isZooming', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isZooming);
  }

  /// keyboardDismissMode
  UIScrollViewKeyboardDismissMode get keyboardDismissMode {
    objc.checkOsVersionInternal('UIScrollView.keyboardDismissMode', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1v83s9d(this.ref.pointer, _sel_keyboardDismissMode);
    return UIScrollViewKeyboardDismissMode.fromValue($ret);
  }

  /// maximumZoomScale
  double get maximumZoomScale {
    objc.checkOsVersionInternal('UIScrollView.maximumZoomScale', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_maximumZoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_maximumZoomScale);
  }

  /// minimumZoomScale
  double get minimumZoomScale {
    objc.checkOsVersionInternal('UIScrollView.minimumZoomScale', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumZoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumZoomScale);
  }

  /// panGestureRecognizer
  UIPanGestureRecognizer get panGestureRecognizer {
    objc.checkOsVersionInternal('UIScrollView.panGestureRecognizer', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_panGestureRecognizer);
    return UIPanGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// pinchGestureRecognizer
  UIPinchGestureRecognizer? get pinchGestureRecognizer {
    objc.checkOsVersionInternal('UIScrollView.pinchGestureRecognizer', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_pinchGestureRecognizer);
    return $ret.address == 0 ? null : UIPinchGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// refreshControl
  UIRefreshControl? get refreshControl {
    objc.checkOsVersionInternal('UIScrollView.refreshControl', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_refreshControl);
    return $ret.address == 0 ? null : UIRefreshControl.castFromPointer($ret, retain: true, release: true);
  }

  /// scrollIndicatorInsets
  UIEdgeInsets get scrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.scrollIndicatorInsets', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_scrollIndicatorInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_scrollIndicatorInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// scrollRectToVisible:animated:
  void scrollRectToVisible(objc.CGRect rect, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.scrollRectToVisible:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1sfhlx6(this.ref.pointer, _sel_scrollRectToVisible_animated_, rect, animated);
  }

  /// scrollsToTop
  bool get scrollsToTop {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_scrollsToTop);
  }

  /// setAlwaysBounceHorizontal:
  set alwaysBounceHorizontal(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAlwaysBounceHorizontal:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAlwaysBounceHorizontal_, value);
  }

  /// setAlwaysBounceVertical:
  set alwaysBounceVertical(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAlwaysBounceVertical:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAlwaysBounceVertical_, value);
  }

  /// setAutomaticallyAdjustsScrollIndicatorInsets:
  set automaticallyAdjustsScrollIndicatorInsets(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setAutomaticallyAdjustsScrollIndicatorInsets:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutomaticallyAdjustsScrollIndicatorInsets_, value);
  }

  /// setBounces:
  set bounces(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setBounces:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setBounces_, value);
  }

  /// setBouncesZoom:
  set bouncesZoom(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setBouncesZoom:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setBouncesZoom_, value);
  }

  /// setCanCancelContentTouches:
  set canCancelContentTouches(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setCanCancelContentTouches:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setCanCancelContentTouches_, value);
  }

  /// setContentInset:
  set contentInset(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setContentInset:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setContentInset_, value);
  }

  /// setContentInsetAdjustmentBehavior:
  set contentInsetAdjustmentBehavior(UIScrollViewContentInsetAdjustmentBehavior value) {
    objc.checkOsVersionInternal('UIScrollView.setContentInsetAdjustmentBehavior:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1l2otbm(this.ref.pointer, _sel_setContentInsetAdjustmentBehavior_, value.value);
  }

  /// The current content offset of this scrollable container. If the scrollable container has a `bounds` property, `bounds.origin` must be equal to `contentOffset`.
  set contentOffset(objc.CGPoint value) {
    objc.checkOsVersionInternal('UIScrollView.setContentOffset:', iOS: (false, (12, 0, 0)));
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setContentOffset_, value);
  }

  /// setContentOffset:animated:
  void setContentOffset(objc.CGPoint contentOffset, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.setContentOffset:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_uyhzs2(this.ref.pointer, _sel_setContentOffset_animated_, contentOffset, animated);
  }

  /// setContentSize:
  set contentSize$1(objc.CGSize value) {
    objc.checkOsVersionInternal('UIScrollView.setContentSize:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setContentSize_, value);
  }

  /// setDecelerationRate:
  set decelerationRate(double value) {
    objc.checkOsVersionInternal('UIScrollView.setDecelerationRate:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setDecelerationRate_, value);
  }

  /// setDelaysContentTouches:
  set delaysContentTouches(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setDelaysContentTouches:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDelaysContentTouches_, value);
  }

  /// setDelegate:
  set delegate(UIScrollViewDelegate? value) {
    objc.checkOsVersionInternal('UIScrollView.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setDirectionalLockEnabled:
  set isDirectionalLockEnabled(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setDirectionalLockEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDirectionalLockEnabled_, value);
  }

  /// setHorizontalScrollIndicatorInsets:
  set horizontalScrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setHorizontalScrollIndicatorInsets:', iOS: (false, (11, 1, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setHorizontalScrollIndicatorInsets_, value);
  }

  /// setIndexDisplayMode:
  set indexDisplayMode(UIScrollViewIndexDisplayMode value) {
    _objc_msgSend_r5kwx4(this.ref.pointer, _sel_setIndexDisplayMode_, value.value);
  }

  /// setIndicatorStyle:
  set indicatorStyle(UIScrollViewIndicatorStyle value) {
    objc.checkOsVersionInternal('UIScrollView.setIndicatorStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_10eov2d(this.ref.pointer, _sel_setIndicatorStyle_, value.value);
  }

  /// setKeyboardDismissMode:
  set keyboardDismissMode(UIScrollViewKeyboardDismissMode value) {
    objc.checkOsVersionInternal('UIScrollView.setKeyboardDismissMode:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1c75p8t(this.ref.pointer, _sel_setKeyboardDismissMode_, value.value);
  }

  /// setMaximumZoomScale:
  set maximumZoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setMaximumZoomScale:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMaximumZoomScale_, value);
  }

  /// setMinimumZoomScale:
  set minimumZoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setMinimumZoomScale:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumZoomScale_, value);
  }

  /// setPagingEnabled:
  set isPagingEnabled(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPagingEnabled_, value);
  }

  /// setRefreshControl:
  set refreshControl(UIRefreshControl? value) {
    objc.checkOsVersionInternal('UIScrollView.setRefreshControl:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRefreshControl_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setScrollEnabled:
  set isScrollEnabled(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setScrollEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScrollEnabled_, value);
  }

  /// setScrollIndicatorInsets:
  set scrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setScrollIndicatorInsets:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setScrollIndicatorInsets_, value);
  }

  /// setScrollsToTop:
  set scrollsToTop(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setScrollsToTop_, value);
  }

  /// setShowsHorizontalScrollIndicator:
  set showsHorizontalScrollIndicator(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setShowsHorizontalScrollIndicator:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsHorizontalScrollIndicator_, value);
  }

  /// setShowsVerticalScrollIndicator:
  set showsVerticalScrollIndicator(bool value) {
    objc.checkOsVersionInternal('UIScrollView.setShowsVerticalScrollIndicator:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsVerticalScrollIndicator_, value);
  }

  /// setVerticalScrollIndicatorInsets:
  set verticalScrollIndicatorInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIScrollView.setVerticalScrollIndicatorInsets:', iOS: (false, (11, 1, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setVerticalScrollIndicatorInsets_, value);
  }

  /// setZoomScale:
  set zoomScale(double value) {
    objc.checkOsVersionInternal('UIScrollView.setZoomScale:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setZoomScale_, value);
  }

  /// setZoomScale:animated:
  void setZoomScale(double scale, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.setZoomScale:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_ghxo7e(this.ref.pointer, _sel_setZoomScale_animated_, scale, animated);
  }

  /// showsHorizontalScrollIndicator
  bool get showsHorizontalScrollIndicator {
    objc.checkOsVersionInternal('UIScrollView.showsHorizontalScrollIndicator', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsHorizontalScrollIndicator);
  }

  /// showsVerticalScrollIndicator
  bool get showsVerticalScrollIndicator {
    objc.checkOsVersionInternal('UIScrollView.showsVerticalScrollIndicator', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsVerticalScrollIndicator);
  }

  /// touchesShouldBegin:withEvent:inContentView:
  bool touchesShouldBegin(objc.NSSet touches, {UIEvent? withEvent, required UIView inContentView}) {
    objc.checkOsVersionInternal('UIScrollView.touchesShouldBegin:withEvent:inContentView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_gtxojt(
      this.ref.pointer,
      _sel_touchesShouldBegin_withEvent_inContentView_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
      inContentView.ref.pointer,
    );
  }

  /// touchesShouldCancelInContentView:
  bool touchesShouldCancelInContentView(UIView view) {
    objc.checkOsVersionInternal('UIScrollView.touchesShouldCancelInContentView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_touchesShouldCancelInContentView_, view.ref.pointer);
  }

  /// verticalScrollIndicatorInsets
  UIEdgeInsets get verticalScrollIndicatorInsets {
    objc.checkOsVersionInternal('UIScrollView.verticalScrollIndicatorInsets', iOS: (false, (11, 1, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_verticalScrollIndicatorInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_verticalScrollIndicatorInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// The visible size of this scrollable container.
  objc.CGSize get visibleSize {
    objc.checkOsVersionInternal('UIScrollView.visibleSize', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret($ptr, this.ref.pointer, _sel_visibleSize)
        : $ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_visibleSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// zoomScale
  double get zoomScale {
    objc.checkOsVersionInternal('UIScrollView.zoomScale', iOS: (false, (3, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_zoomScale)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_zoomScale);
  }

  /// zoomToRect:animated:
  void zoomToRect(objc.CGRect rect, {required bool animated}) {
    objc.checkOsVersionInternal('UIScrollView.zoomToRect:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1sfhlx6(this.ref.pointer, _sel_zoomToRect_animated_, rect, animated);
  }
}

sealed class NSDirectionalRectEdge {
  static const NSDirectionalRectEdgeNone = 0;
  static const NSDirectionalRectEdgeTop = 1;
  static const NSDirectionalRectEdgeLeading = 2;
  static const NSDirectionalRectEdgeBottom = 4;
  static const NSDirectionalRectEdgeTrailing = 8;
  static const NSDirectionalRectEdgeAll = 15;
}

late final _sel_setContentScrollView_forEdge_ = objc.registerName("setContentScrollView:forEdge:");
final _objc_msgSend_13y7vr7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_contentScrollViewForEdge_ = objc.registerName("contentScrollViewForEdge:");
final _objc_msgSend_kh1gvt = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_preferredContentSize = objc.registerName("preferredContentSize");
late final _sel_setPreferredContentSize_ = objc.registerName("setPreferredContentSize:");

enum UIStatusBarStyle {
  UIStatusBarStyleDefault(0),
  UIStatusBarStyleLightContent(1),
  UIStatusBarStyleDarkContent(3),
  UIStatusBarStyleBlackOpaque(2);

  static const UIStatusBarStyleBlackTranslucent = UIStatusBarStyleLightContent;

  final int value;
  const UIStatusBarStyle(this.value);

  static UIStatusBarStyle fromValue(int value) => switch (value) {
    0 => UIStatusBarStyleDefault,
    1 => UIStatusBarStyleLightContent,
    3 => UIStatusBarStyleDarkContent,
    2 => UIStatusBarStyleBlackOpaque,
    _ => throw ArgumentError('Unknown value for UIStatusBarStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIStatusBarStyleLightContent)
      return "UIStatusBarStyle.UIStatusBarStyleLightContent, UIStatusBarStyle.UIStatusBarStyleBlackTranslucent";
    return super.toString();
  }
}

late final _sel_preferredStatusBarStyle = objc.registerName("preferredStatusBarStyle");
final _objc_msgSend_czyja3 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_prefersStatusBarHidden = objc.registerName("prefersStatusBarHidden");

enum UIStatusBarAnimation {
  UIStatusBarAnimationNone(0),
  UIStatusBarAnimationFade(1),
  UIStatusBarAnimationSlide(2);

  final int value;
  const UIStatusBarAnimation(this.value);

  static UIStatusBarAnimation fromValue(int value) => switch (value) {
    0 => UIStatusBarAnimationNone,
    1 => UIStatusBarAnimationFade,
    2 => UIStatusBarAnimationSlide,
    _ => throw ArgumentError('Unknown value for UIStatusBarAnimation: $value'),
  };
}

late final _sel_preferredStatusBarUpdateAnimation = objc.registerName("preferredStatusBarUpdateAnimation");
final _objc_msgSend_14wdvus = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNeedsStatusBarAppearanceUpdate = objc.registerName("setNeedsStatusBarAppearanceUpdate");
late final _sel_targetViewControllerForAction_sender_ = objc.registerName("targetViewControllerForAction:sender:");
late final _sel_showViewController_sender_ = objc.registerName("showViewController:sender:");
late final _sel_showDetailViewController_sender_ = objc.registerName("showDetailViewController:sender:");

enum UIUserInterfaceStyle {
  UIUserInterfaceStyleUnspecified(0),
  UIUserInterfaceStyleLight(1),
  UIUserInterfaceStyleDark(2);

  final int value;
  const UIUserInterfaceStyle(this.value);

  static UIUserInterfaceStyle fromValue(int value) => switch (value) {
    0 => UIUserInterfaceStyleUnspecified,
    1 => UIUserInterfaceStyleLight,
    2 => UIUserInterfaceStyleDark,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceStyle: $value'),
  };
}

late final _sel_preferredUserInterfaceStyle = objc.registerName("preferredUserInterfaceStyle");
final _objc_msgSend_2x5ago = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setNeedsUserInterfaceAppearanceUpdate = objc.registerName("setNeedsUserInterfaceAppearanceUpdate");
late final _sel_overrideUserInterfaceStyle = objc.registerName("overrideUserInterfaceStyle");
late final _sel_setOverrideUserInterfaceStyle_ = objc.registerName("setOverrideUserInterfaceStyle:");
final _objc_msgSend_15dz1ky = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: UIContentContainer is a stub. To generate bindings for this class, include
/// UIContentContainer in your config's objc-protocols list.
///
/// UIContentContainer
interface class UIContentContainer extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIContentContainer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentContainer] that points to the same underlying object as [other].
  UIContentContainer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentContainer] that wraps the given raw object pointer.
  UIContentContainer.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_preferredContentSizeDidChangeForChildContentContainer_ = objc.registerName(
  "preferredContentSizeDidChangeForChildContentContainer:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> listener(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UIContentContainer) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_idUIContentContainer$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, UIContentContainer arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_systemLayoutFittingSizeDidChangeForChildContentContainer_ = objc.registerName(
  "systemLayoutFittingSizeDidChangeForChildContentContainer:",
);
late final _sel_sizeForChildContentContainer_withParentContainerSize_ = objc.registerName(
  "sizeForChildContentContainer:withParentContainerSize:",
);
final _objc_msgSend_xq5db9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        objc.CGSize,
      )
    >();
final _objc_msgSend_xq5db9Stret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        objc.CGSize,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>`.
abstract final class ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>
  fromFunction(
    objc.CGSize Function(ffi.Pointer<ffi.Void>, UIContentContainer, objc.CGSize) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2) =>
          fn(arg0, UIContentContainer.castFromPointer(arg1, retain: true, release: true), arg2),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static objc.CGSize _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    objc.CGSize arg2,
  ) =>
      block.ref.target
          .cast<
            ffi.NativeFunction<
              objc.CGSize Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, objc.CGSize arg2)
            >
          >()
          .asFunction<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>()(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            objc.CGSize Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              objc.CGSize,
            )
          >(_fnPtrTrampoline)
          .cast();
  static objc.CGSize _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    objc.CGSize arg2,
  ) =>
      (objc.getBlockClosure(block)
          as objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            objc.CGSize Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              objc.CGSize,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)>`.
extension ObjCBlock_CGSize_ffiVoid_idUIContentContainer_CGSize$CallExtension
    on objc.ObjCBlock<objc.CGSize Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, objc.CGSize)> {
  objc.CGSize call(ffi.Pointer<ffi.Void> arg0, UIContentContainer arg1, objc.CGSize arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          objc.CGSize Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            objc.CGSize arg2,
          )
        >
      >()
      .asFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          objc.CGSize,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2);
}

/// WARNING: UIViewControllerTransitionCoordinator is a stub. To generate bindings for this class, include
/// UIViewControllerTransitionCoordinator in your config's objc-protocols list.
///
/// UIViewControllerTransitionCoordinator
interface class UIViewControllerTransitionCoordinator extends objc.ObjCProtocolBase {
  UIViewControllerTransitionCoordinator._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerTransitionCoordinator] that points to the same underlying object as [other].
  UIViewControllerTransitionCoordinator.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerTransitionCoordinator] that wraps the given raw object pointer.
  UIViewControllerTransitionCoordinator.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_viewWillTransitionToSize_withTransitionCoordinator_ = objc.registerName(
  "viewWillTransitionToSize:withTransitionCoordinator:",
);
final _objc_msgSend_11tcc61 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> listener(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1rn6eap(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> blocking(
    void Function(ffi.Pointer<ffi.Void>, objc.CGSize, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2) =>
          fn(arg0, arg1, UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1rn6eap(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            objc.CGSize,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGSize,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGSize,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      objc.CGSize,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            objc.CGSize,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, ffi.Pointer<objc.ObjCObject> arg2)
        >
      >()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGSize,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    objc.CGSize arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
    arg2,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              objc.CGSize,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_CGSize_idUIViewControllerTransitionCoordinator$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.CGSize arg1, UIViewControllerTransitionCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            objc.CGSize arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, objc.CGSize, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1, arg2.ref.pointer);
}

late final _sel_willTransitionToTraitCollection_withTransitionCoordinator_ = objc.registerName(
  "willTransitionToTraitCollection:withTransitionCoordinator:",
);

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: true, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  listener(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>
  blocking(
    void Function(ffi.Pointer<ffi.Void>, UITraitCollection, UIViewControllerTransitionCoordinator) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITraitCollection.castFromPointer(arg1, retain: false, release: true),
        UIViewControllerTransitionCoordinator.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITraitCollection_idUIViewControllerTransitionCoordinator$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITraitCollection, ffi.Pointer<objc.ObjCObject>)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITraitCollection arg1, UIViewControllerTransitionCoordinator arg2) => ref
      .pointer
      .ref
      .invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_previewActionItems = objc.registerName("previewActionItems");
late final _sel_attemptRotationToDeviceOrientation = objc.registerName("attemptRotationToDeviceOrientation");

enum UIInterfaceOrientation {
  UIInterfaceOrientationUnknown(0),
  UIInterfaceOrientationPortrait(1),
  UIInterfaceOrientationPortraitUpsideDown(2),
  UIInterfaceOrientationLandscapeLeft(4),
  UIInterfaceOrientationLandscapeRight(3);

  final int value;
  const UIInterfaceOrientation(this.value);

  static UIInterfaceOrientation fromValue(int value) => switch (value) {
    0 => UIInterfaceOrientationUnknown,
    1 => UIInterfaceOrientationPortrait,
    2 => UIInterfaceOrientationPortraitUpsideDown,
    4 => UIInterfaceOrientationLandscapeLeft,
    3 => UIInterfaceOrientationLandscapeRight,
    _ => throw ArgumentError('Unknown value for UIInterfaceOrientation: $value'),
  };
}

late final _sel_shouldAutorotateToInterfaceOrientation_ = objc.registerName("shouldAutorotateToInterfaceOrientation:");
final _objc_msgSend_1p4s9xc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_shouldAutorotate = objc.registerName("shouldAutorotate");

sealed class UIInterfaceOrientationMask {
  static const UIInterfaceOrientationMaskPortrait = 2;
  static const UIInterfaceOrientationMaskLandscapeLeft = 16;
  static const UIInterfaceOrientationMaskLandscapeRight = 8;
  static const UIInterfaceOrientationMaskPortraitUpsideDown = 4;
  static const UIInterfaceOrientationMaskLandscape = 24;
  static const UIInterfaceOrientationMaskAll = 30;
  static const UIInterfaceOrientationMaskAllButUpsideDown = 26;
}

late final _sel_supportedInterfaceOrientations = objc.registerName("supportedInterfaceOrientations");
final _objc_msgSend_1yyvh1k = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_preferredInterfaceOrientationForPresentation = objc.registerName(
  "preferredInterfaceOrientationForPresentation",
);
final _objc_msgSend_14s25dk = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_rotatingHeaderView = objc.registerName("rotatingHeaderView");
late final _sel_rotatingFooterView = objc.registerName("rotatingFooterView");
late final _sel_interfaceOrientation = objc.registerName("interfaceOrientation");
late final _sel_willRotateToInterfaceOrientation_duration_ = objc.registerName(
  "willRotateToInterfaceOrientation:duration:",
);
final _objc_msgSend_vscdhh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Double)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, double)>();
late final _sel_didRotateFromInterfaceOrientation_ = objc.registerName("didRotateFromInterfaceOrientation:");
final _objc_msgSend_13bsfjm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_willAnimateRotationToInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateRotationToInterfaceOrientation:duration:",
);
late final _sel_willAnimateFirstHalfOfRotationToInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:",
);
late final _sel_didAnimateFirstHalfOfRotationToInterfaceOrientation_ = objc.registerName(
  "didAnimateFirstHalfOfRotationToInterfaceOrientation:",
);
late final _sel_willAnimateSecondHalfOfRotationFromInterfaceOrientation_duration_ = objc.registerName(
  "willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:",
);

/// UIViewControllerRotation
extension UIViewControllerRotation on UIViewController {
  /// didAnimateFirstHalfOfRotationToInterfaceOrientation:
  void didAnimateFirstHalfOfRotationToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation) {
    objc.checkOsVersionInternal(
      'UIViewController.didAnimateFirstHalfOfRotationToInterfaceOrientation:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_13bsfjm(
      this.ref.pointer,
      _sel_didAnimateFirstHalfOfRotationToInterfaceOrientation_,
      toInterfaceOrientation.value,
    );
  }

  /// didRotateFromInterfaceOrientation:
  void didRotateFromInterfaceOrientation(UIInterfaceOrientation fromInterfaceOrientation) {
    objc.checkOsVersionInternal('UIViewController.didRotateFromInterfaceOrientation:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13bsfjm(this.ref.pointer, _sel_didRotateFromInterfaceOrientation_, fromInterfaceOrientation.value);
  }

  /// interfaceOrientation
  UIInterfaceOrientation get interfaceOrientation {
    objc.checkOsVersionInternal('UIViewController.interfaceOrientation', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_interfaceOrientation);
    return UIInterfaceOrientation.fromValue($ret);
  }

  /// preferredInterfaceOrientationForPresentation
  UIInterfaceOrientation get preferredInterfaceOrientationForPresentation {
    objc.checkOsVersionInternal(
      'UIViewController.preferredInterfaceOrientationForPresentation',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_preferredInterfaceOrientationForPresentation);
    return UIInterfaceOrientation.fromValue($ret);
  }

  /// rotatingFooterView
  UIView? rotatingFooterView() {
    objc.checkOsVersionInternal('UIViewController.rotatingFooterView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rotatingFooterView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// rotatingHeaderView
  UIView? rotatingHeaderView() {
    objc.checkOsVersionInternal('UIViewController.rotatingHeaderView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rotatingHeaderView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// shouldAutorotate
  bool get shouldAutorotate {
    objc.checkOsVersionInternal('UIViewController.shouldAutorotate', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutorotate);
  }

  /// shouldAutorotateToInterfaceOrientation:
  bool shouldAutorotateToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation) {
    objc.checkOsVersionInternal('UIViewController.shouldAutorotateToInterfaceOrientation:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1p4s9xc(
      this.ref.pointer,
      _sel_shouldAutorotateToInterfaceOrientation_,
      toInterfaceOrientation.value,
    );
  }

  /// supportedInterfaceOrientations
  int get supportedInterfaceOrientations {
    objc.checkOsVersionInternal('UIViewController.supportedInterfaceOrientations', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_1yyvh1k(this.ref.pointer, _sel_supportedInterfaceOrientations);
  }

  /// willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:
  void willAnimateFirstHalfOfRotationToInterfaceOrientation(
    UIInterfaceOrientation toInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateFirstHalfOfRotationToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// willAnimateRotationToInterfaceOrientation:duration:
  void willAnimateRotationToInterfaceOrientation(
    UIInterfaceOrientation toInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateRotationToInterfaceOrientation:duration:',
      iOS: (false, (3, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateRotationToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:
  void willAnimateSecondHalfOfRotationFromInterfaceOrientation(
    UIInterfaceOrientation fromInterfaceOrientation, {
    required double duration,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:',
      iOS: (false, (2, 0, 0)),
    );
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willAnimateSecondHalfOfRotationFromInterfaceOrientation_duration_,
      fromInterfaceOrientation.value,
      duration,
    );
  }

  /// willRotateToInterfaceOrientation:duration:
  void willRotateToInterfaceOrientation(UIInterfaceOrientation toInterfaceOrientation, {required double duration}) {
    objc.checkOsVersionInternal('UIViewController.willRotateToInterfaceOrientation:duration:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_vscdhh(
      this.ref.pointer,
      _sel_willRotateToInterfaceOrientation_duration_,
      toInterfaceOrientation.value,
      duration,
    );
  }

  /// attemptRotationToDeviceOrientation
  static void attemptRotationToDeviceOrientation() {
    objc.checkOsVersionInternal('UIViewController.attemptRotationToDeviceOrientation', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(_class_UIViewController, _sel_attemptRotationToDeviceOrientation);
  }
}

late final _sel_isEditing = objc.registerName("isEditing");
late final _sel_setEditing_ = objc.registerName("setEditing:");
late final _sel_setEditing_animated_ = objc.registerName("setEditing:animated:");
final _objc_msgSend_14iqu8t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, bool)>();
late final _class_UIBarItem = objc.getClass("UIBarItem");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
late final _sel_setImage_ = objc.registerName("setImage:");
late final _sel_landscapeImagePhone = objc.registerName("landscapeImagePhone");
late final _sel_setLandscapeImagePhone_ = objc.registerName("setLandscapeImagePhone:");
late final _sel_largeContentSizeImage = objc.registerName("largeContentSizeImage");
late final _sel_setLargeContentSizeImage_ = objc.registerName("setLargeContentSizeImage:");
late final _sel_imageInsets = objc.registerName("imageInsets");
late final _sel_setImageInsets_ = objc.registerName("setImageInsets:");
late final _sel_landscapeImagePhoneInsets = objc.registerName("landscapeImagePhoneInsets");
late final _sel_setLandscapeImagePhoneInsets_ = objc.registerName("setLandscapeImagePhoneInsets:");
late final _sel_largeContentSizeImageInsets = objc.registerName("largeContentSizeImageInsets");
late final _sel_setLargeContentSizeImageInsets_ = objc.registerName("setLargeContentSizeImageInsets:");

sealed class UIControlState {
  static const UIControlStateNormal = 0;
  static const UIControlStateHighlighted = 1;
  static const UIControlStateDisabled = 2;
  static const UIControlStateSelected = 4;
  static const UIControlStateFocused = 8;
  static const UIControlStateApplication = 16711680;
  static const UIControlStateReserved = 4278190080;
}

late final _sel_setTitleTextAttributes_forState_ = objc.registerName("setTitleTextAttributes:forState:");
final _objc_msgSend_dldayz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_titleTextAttributesForState_ = objc.registerName("titleTextAttributesForState:");
final _objc_msgSend_1g2zxsx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();

/// WARNING: UIAppearance is a stub. To generate bindings for this class, include
/// UIAppearance in your config's objc-protocols list.
///
/// UIAppearance
interface class UIAppearance extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIAppearance] that points to the same underlying object as [other].
  UIAppearance.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAppearance] that wraps the given raw object pointer.
  UIAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// UIBarItem
class UIBarItem extends objc.NSObject implements objc.NSCoding, UIAppearance {
  UIBarItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarItem', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIBarItem] that points to the same underlying object as [other].
  UIBarItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarItem] that wraps the given raw object pointer.
  UIBarItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarItem);
  }

  /// alloc
  static UIBarItem alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_alloc);
    return UIBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIBarItem, _sel_allocWithZone_, zone);
    return UIBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UIBarItem appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_appearance);
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIBarItem appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIBarItem.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIBarItem, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIBarItem appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UIBarItem.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      _class_UIBarItem,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIBarItem appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIBarItem.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIBarItem,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIBarItem appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIBarItem.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIBarItem,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIBarItem appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UIBarItem.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIBarItem,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIBarItem new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarItem, _sel_new);
    return UIBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIBarItem constructed with the default `new` method.
  factory UIBarItem() => new$();
}

extension UIBarItem$Methods on UIBarItem {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// image
  UIImage? get image {
    objc.checkOsVersionInternal('UIBarItem.image', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_image);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// imageInsets
  UIEdgeInsets get imageInsets {
    objc.checkOsVersionInternal('UIBarItem.imageInsets', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_imageInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_imageInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// init
  UIBarItem init() {
    objc.checkOsVersionInternal('UIBarItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarItem? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// isEnabled
  bool get isEnabled {
    objc.checkOsVersionInternal('UIBarItem.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// landscapeImagePhone
  UIImage? get landscapeImagePhone {
    objc.checkOsVersionInternal('UIBarItem.landscapeImagePhone', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_landscapeImagePhone);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// landscapeImagePhoneInsets
  UIEdgeInsets get landscapeImagePhoneInsets {
    objc.checkOsVersionInternal('UIBarItem.landscapeImagePhoneInsets', iOS: (false, (5, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_landscapeImagePhoneInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_landscapeImagePhoneInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// largeContentSizeImage
  UIImage? get largeContentSizeImage {
    objc.checkOsVersionInternal('UIBarItem.largeContentSizeImage', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_largeContentSizeImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// largeContentSizeImageInsets
  UIEdgeInsets get largeContentSizeImageInsets {
    objc.checkOsVersionInternal('UIBarItem.largeContentSizeImageInsets', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_largeContentSizeImageInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_largeContentSizeImageInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// setEnabled:
  set isEnabled(bool value) {
    objc.checkOsVersionInternal('UIBarItem.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// setImage:
  set image(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setImage:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setImageInsets:
  set imageInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setImageInsets:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setImageInsets_, value);
  }

  /// setLandscapeImagePhone:
  set landscapeImagePhone(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setLandscapeImagePhone:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLandscapeImagePhone_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLandscapeImagePhoneInsets:
  set landscapeImagePhoneInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setLandscapeImagePhoneInsets:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLandscapeImagePhoneInsets_, value);
  }

  /// setLargeContentSizeImage:
  set largeContentSizeImage(UIImage? value) {
    objc.checkOsVersionInternal('UIBarItem.setLargeContentSizeImage:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLargeContentSizeImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLargeContentSizeImageInsets:
  set largeContentSizeImageInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIBarItem.setLargeContentSizeImageInsets:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLargeContentSizeImageInsets_, value);
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIBarItem.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setTag_, value);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIBarItem.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTitleTextAttributes:forState:
  void setTitleTextAttributes(objc.NSDictionary? attributes, {required int forState}) {
    objc.checkOsVersionInternal('UIBarItem.setTitleTextAttributes:forState:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_dldayz(
      this.ref.pointer,
      _sel_setTitleTextAttributes_forState_,
      attributes?.ref.pointer ?? ffi.nullptr,
      forState,
    );
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIBarItem.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_tag);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIBarItem.title', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// titleTextAttributesForState:
  objc.NSDictionary? titleTextAttributesForState(int state) {
    objc.checkOsVersionInternal('UIBarItem.titleTextAttributesForState:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1g2zxsx(this.ref.pointer, _sel_titleTextAttributesForState_, state);
    return $ret.address == 0 ? null : objc.NSDictionary.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UIBarButtonItem = objc.getClass("UIBarButtonItem");

enum UIBarButtonItemStyle {
  UIBarButtonItemStylePlain(0),
  UIBarButtonItemStyleBordered(1),
  UIBarButtonItemStyleDone(2);

  final int value;
  const UIBarButtonItemStyle(this.value);

  static UIBarButtonItemStyle fromValue(int value) => switch (value) {
    0 => UIBarButtonItemStylePlain,
    1 => UIBarButtonItemStyleBordered,
    2 => UIBarButtonItemStyleDone,
    _ => throw ArgumentError('Unknown value for UIBarButtonItemStyle: $value'),
  };
}

late final _sel_initWithImage_style_target_action_ = objc.registerName("initWithImage:style:target:action:");
final _objc_msgSend_13sbrg9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithImage_landscapeImagePhone_style_target_action_ = objc.registerName(
  "initWithImage:landscapeImagePhone:style:target:action:",
);
final _objc_msgSend_1d97k9n = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithTitle_style_target_action_ = objc.registerName("initWithTitle:style:target:action:");

enum UIBarButtonSystemItem {
  UIBarButtonSystemItemDone(0),
  UIBarButtonSystemItemCancel(1),
  UIBarButtonSystemItemEdit(2),
  UIBarButtonSystemItemSave(3),
  UIBarButtonSystemItemAdd(4),
  UIBarButtonSystemItemFlexibleSpace(5),
  UIBarButtonSystemItemFixedSpace(6),
  UIBarButtonSystemItemCompose(7),
  UIBarButtonSystemItemReply(8),
  UIBarButtonSystemItemAction(9),
  UIBarButtonSystemItemOrganize(10),
  UIBarButtonSystemItemBookmarks(11),
  UIBarButtonSystemItemSearch(12),
  UIBarButtonSystemItemRefresh(13),
  UIBarButtonSystemItemStop(14),
  UIBarButtonSystemItemCamera(15),
  UIBarButtonSystemItemTrash(16),
  UIBarButtonSystemItemPlay(17),
  UIBarButtonSystemItemPause(18),
  UIBarButtonSystemItemRewind(19),
  UIBarButtonSystemItemFastForward(20),
  UIBarButtonSystemItemUndo(21),
  UIBarButtonSystemItemRedo(22),
  UIBarButtonSystemItemPageCurl(23),
  UIBarButtonSystemItemClose(24);

  final int value;
  const UIBarButtonSystemItem(this.value);

  static UIBarButtonSystemItem fromValue(int value) => switch (value) {
    0 => UIBarButtonSystemItemDone,
    1 => UIBarButtonSystemItemCancel,
    2 => UIBarButtonSystemItemEdit,
    3 => UIBarButtonSystemItemSave,
    4 => UIBarButtonSystemItemAdd,
    5 => UIBarButtonSystemItemFlexibleSpace,
    6 => UIBarButtonSystemItemFixedSpace,
    7 => UIBarButtonSystemItemCompose,
    8 => UIBarButtonSystemItemReply,
    9 => UIBarButtonSystemItemAction,
    10 => UIBarButtonSystemItemOrganize,
    11 => UIBarButtonSystemItemBookmarks,
    12 => UIBarButtonSystemItemSearch,
    13 => UIBarButtonSystemItemRefresh,
    14 => UIBarButtonSystemItemStop,
    15 => UIBarButtonSystemItemCamera,
    16 => UIBarButtonSystemItemTrash,
    17 => UIBarButtonSystemItemPlay,
    18 => UIBarButtonSystemItemPause,
    19 => UIBarButtonSystemItemRewind,
    20 => UIBarButtonSystemItemFastForward,
    21 => UIBarButtonSystemItemUndo,
    22 => UIBarButtonSystemItemRedo,
    23 => UIBarButtonSystemItemPageCurl,
    24 => UIBarButtonSystemItemClose,
    _ => throw ArgumentError('Unknown value for UIBarButtonSystemItem: $value'),
  };
}

late final _sel_initWithBarButtonSystemItem_target_action_ = objc.registerName(
  "initWithBarButtonSystemItem:target:action:",
);
final _objc_msgSend_18lulgh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
      )
    >();
late final _sel_initWithCustomView_ = objc.registerName("initWithCustomView:");

/// WARNING: UIAction is a stub. To generate bindings for this class, include
/// UIAction in your config's objc-interfaces list.
///
/// UIAction
class UIAction extends UIMenuElement {
  UIAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAction', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIAction] that points to the same underlying object as [other].
  UIAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAction] that wraps the given raw object pointer.
  UIAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_initWithBarButtonSystemItem_primaryAction_ = objc.registerName(
  "initWithBarButtonSystemItem:primaryAction:",
);
final _objc_msgSend_ka2bhe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_initWithPrimaryAction_ = objc.registerName("initWithPrimaryAction:");
late final _sel_initWithBarButtonSystemItem_menu_ = objc.registerName("initWithBarButtonSystemItem:menu:");
late final _sel_initWithTitle_menu_ = objc.registerName("initWithTitle:menu:");
late final _sel_initWithImage_menu_ = objc.registerName("initWithImage:menu:");
late final _sel_fixedSpaceItemOfWidth_ = objc.registerName("fixedSpaceItemOfWidth:");
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)
    >();
late final _sel_flexibleSpaceItem = objc.registerName("flexibleSpaceItem");
late final _sel_style = objc.registerName("style");
final _objc_msgSend_121lhl0 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setStyle_ = objc.registerName("setStyle:");
final _objc_msgSend_11ist7u = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_width = objc.registerName("width");
late final _sel_setWidth_ = objc.registerName("setWidth:");
late final _sel_possibleTitles = objc.registerName("possibleTitles");
late final _sel_setPossibleTitles_ = objc.registerName("setPossibleTitles:");
late final _sel_customView = objc.registerName("customView");
late final _sel_setCustomView_ = objc.registerName("setCustomView:");
late final _sel_action = objc.registerName("action");
final _objc_msgSend_1ovaulg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCSelector> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setAction_ = objc.registerName("setAction:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_target = objc.registerName("target");
late final _sel_setTarget_ = objc.registerName("setTarget:");
late final _sel_primaryAction = objc.registerName("primaryAction");
late final _sel_setPrimaryAction_ = objc.registerName("setPrimaryAction:");
late final _sel_menu = objc.registerName("menu");
late final _sel_setMenu_ = objc.registerName("setMenu:");
late final _sel_changesSelectionAsPrimaryAction = objc.registerName("changesSelectionAsPrimaryAction");
late final _sel_setChangesSelectionAsPrimaryAction_ = objc.registerName("setChangesSelectionAsPrimaryAction:");
late final _sel_isSelected = objc.registerName("isSelected");
late final _sel_setSelected_ = objc.registerName("setSelected:");

enum UIBarMetrics {
  UIBarMetricsDefault(0),
  UIBarMetricsCompact(1),
  UIBarMetricsDefaultPrompt(101),
  UIBarMetricsCompactPrompt(102);

  static const UIBarMetricsLandscapePhone = UIBarMetricsCompact;
  static const UIBarMetricsLandscapePhonePrompt = UIBarMetricsCompactPrompt;

  final int value;
  const UIBarMetrics(this.value);

  static UIBarMetrics fromValue(int value) => switch (value) {
    0 => UIBarMetricsDefault,
    1 => UIBarMetricsCompact,
    101 => UIBarMetricsDefaultPrompt,
    102 => UIBarMetricsCompactPrompt,
    _ => throw ArgumentError('Unknown value for UIBarMetrics: $value'),
  };

  @override
  String toString() {
    if (this == UIBarMetricsCompact) return "UIBarMetrics.UIBarMetricsCompact, UIBarMetrics.UIBarMetricsLandscapePhone";
    if (this == UIBarMetricsCompactPrompt)
      return "UIBarMetrics.UIBarMetricsCompactPrompt, UIBarMetrics.UIBarMetricsLandscapePhonePrompt";
    return super.toString();
  }
}

late final _sel_setBackgroundImage_forState_barMetrics_ = objc.registerName("setBackgroundImage:forState:barMetrics:");
final _objc_msgSend_1oar0aj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
      )
    >();
late final _sel_backgroundImageForState_barMetrics_ = objc.registerName("backgroundImageForState:barMetrics:");
final _objc_msgSend_1mmfvr1 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)
    >();
late final _sel_setBackgroundImage_forState_style_barMetrics_ = objc.registerName(
  "setBackgroundImage:forState:style:barMetrics:",
);
final _objc_msgSend_1lg97nc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        int,
      )
    >();
late final _sel_backgroundImageForState_style_barMetrics_ = objc.registerName(
  "backgroundImageForState:style:barMetrics:",
);
final _objc_msgSend_15kz3t6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int, int)
    >();
late final _class_UIColor = objc.getClass("UIColor");
late final _sel_colorWithWhite_alpha_ = objc.registerName("colorWithWhite:alpha:");
final _objc_msgSend_1n2vn5t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
      )
    >();
late final _sel_colorWithHue_saturation_brightness_alpha_ = objc.registerName(
  "colorWithHue:saturation:brightness:alpha:",
);
final _objc_msgSend_q2wq4h = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
      )
    >();
late final _sel_colorWithRed_green_blue_alpha_ = objc.registerName("colorWithRed:green:blue:alpha:");
late final _sel_colorWithDisplayP3Red_green_blue_alpha_ = objc.registerName("colorWithDisplayP3Red:green:blue:alpha:");
late final _sel_colorWithCGColor_ = objc.registerName("colorWithCGColor:");
final _objc_msgSend_1rsocyz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<CGColor>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<CGColor>,
      )
    >();
late final _sel_colorWithPatternImage_ = objc.registerName("colorWithPatternImage:");

/// WARNING: CIColor is a stub. To generate bindings for this class, include
/// CIColor in your config's objc-interfaces list.
///
/// CIColor
class CIColor extends objc.NSObject implements objc.NSSecureCoding, objc.NSCopying {
  CIColor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIColor', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIColor] that points to the same underlying object as [other].
  CIColor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIColor] that wraps the given raw object pointer.
  CIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_colorWithCIColor_ = objc.registerName("colorWithCIColor:");
late final _sel_initWithWhite_alpha_ = objc.registerName("initWithWhite:alpha:");
late final _sel_initWithHue_saturation_brightness_alpha_ = objc.registerName(
  "initWithHue:saturation:brightness:alpha:",
);
late final _sel_initWithRed_green_blue_alpha_ = objc.registerName("initWithRed:green:blue:alpha:");
late final _sel_initWithDisplayP3Red_green_blue_alpha_ = objc.registerName("initWithDisplayP3Red:green:blue:alpha:");
late final _sel_initWithCGColor_ = objc.registerName("initWithCGColor:");
late final _sel_initWithPatternImage_ = objc.registerName("initWithPatternImage:");
late final _sel_initWithCIColor_ = objc.registerName("initWithCIColor:");
late final _sel_blackColor = objc.registerName("blackColor");
late final _sel_darkGrayColor = objc.registerName("darkGrayColor");
late final _sel_lightGrayColor = objc.registerName("lightGrayColor");
late final _sel_whiteColor = objc.registerName("whiteColor");
late final _sel_grayColor = objc.registerName("grayColor");
late final _sel_redColor = objc.registerName("redColor");
late final _sel_greenColor = objc.registerName("greenColor");
late final _sel_blueColor = objc.registerName("blueColor");
late final _sel_cyanColor = objc.registerName("cyanColor");
late final _sel_yellowColor = objc.registerName("yellowColor");
late final _sel_magentaColor = objc.registerName("magentaColor");
late final _sel_orangeColor = objc.registerName("orangeColor");
late final _sel_purpleColor = objc.registerName("purpleColor");
late final _sel_brownColor = objc.registerName("brownColor");
late final _sel_clearColor = objc.registerName("clearColor");
late final _sel_set = objc.registerName("set");
late final _sel_setFill = objc.registerName("setFill");
late final _sel_setStroke = objc.registerName("setStroke");
late final _sel_getWhite_alpha_ = objc.registerName("getWhite:alpha:");
final _objc_msgSend_kcpn4z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
      )
    >();
late final _sel_getHue_saturation_brightness_alpha_ = objc.registerName("getHue:saturation:brightness:alpha:");
final _objc_msgSend_xmvde7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
      )
    >();
late final _sel_getRed_green_blue_alpha_ = objc.registerName("getRed:green:blue:alpha:");
late final _sel_colorWithAlphaComponent_ = objc.registerName("colorWithAlphaComponent:");
late final _sel_CGColor = objc.registerName("CGColor");
final _objc_msgSend_2u9jmz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Pointer<CGColor> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<ffi.Pointer<CGColor> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_CIColor = objc.registerName("CIColor");
late final _sel_objectWithItemProviderData_typeIdentifier_error_ = objc.registerName(
  "objectWithItemProviderData:typeIdentifier:error:",
);
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObject>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
  >
  fromFunction(
    Dartinstancetype? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObject>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
          ) =>
              fn(
                arg0,
                objc.NSData.castFromPointer(arg1, retain: true, release: true),
                objc.NSString.castFromPointer(arg2, retain: true, release: true),
                arg3,
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObject>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
          )
        > {
  Dartinstancetype? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSData arg1,
    objc.NSString arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCObject> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObject>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObject>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true,
        );
}

late final _sel_readableTypeIdentifiersForItemProvider = objc.registerName("readableTypeIdentifiersForItemProvider");
late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ = objc.registerName(
  "itemProviderVisibilityForRepresentationWithTypeIdentifier:",
);
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
    objc.NSItemProviderRepresentationVisibility Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true)).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObject> arg1,
                )
              >
            >()
            .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
            >()(ref.pointer, arg0, arg1.ref.pointer),
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: true, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> listener(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> blocking(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.castFromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0, ffi.Pointer<objc.ObjCObject> arg1)>
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ = objc.registerName(
  "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:",
);
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCBlockImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunction(
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
              fn(
                arg0,
                objc.NSString.castFromPointer(arg1, retain: true, release: true),
                ObjCBlock_ffiVoid_NSData_NSError.castFromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError$CallExtension
    on
        objc.ObjCBlock<
          objc.NSProgress? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
          )
        > {
  objc.NSProgress? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSString arg1,
    objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSProgress.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObject>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// UINSItemProvider
extension UINSItemProvider on UIColor {
  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'UIColor.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIColor',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final $ret = _objc_msgSend_16fy0up(
      this.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue($ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(
    objc.NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIColor.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      this.ref.pointer,
      _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
      typeIdentifier.ref.pointer,
      forItemProviderCompletionHandler.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSProgress.castFromPointer($ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
    objc.checkOsVersionInternal(
      'UIColor.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('UIColor', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'UIColor.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(_class_UIColor, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException(
        'UIColor',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final $ret = _objc_msgSend_16fy0up(
      _class_UIColor,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue($ret);
  }

  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
      'UIColor.readableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
    objc.checkOsVersionInternal(
      'UIColor.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_colorNamed_ = objc.registerName("colorNamed:");
late final _sel_colorNamed_inBundle_compatibleWithTraitCollection_ = objc.registerName(
  "colorNamed:inBundle:compatibleWithTraitCollection:",
);

/// UIColorNamedColors
extension UIColorNamedColors on UIColor {
  /// colorNamed:
  static UIColor? colorNamed(objc.NSString name) {
    objc.checkOsVersionInternal('UIColor.colorNamed:', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorNamed_, name.ref.pointer);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorNamed:inBundle:compatibleWithTraitCollection:
  static UIColor? colorNamed$1(
    objc.NSString name, {
    objc.NSBundle? inBundle,
    UITraitCollection? compatibleWithTraitCollection,
  }) {
    objc.checkOsVersionInternal('UIColor.colorNamed:inBundle:compatibleWithTraitCollection:', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_11spmsz(
      _class_UIColor,
      _sel_colorNamed_inBundle_compatibleWithTraitCollection_,
      name.ref.pointer,
      inBundle?.ref.pointer ?? ffi.nullptr,
      compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<UIColor Function(UITraitCollection)>`.
abstract final class ObjCBlock_UIColor_UITraitCollection {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIColor Function(UITraitCollection)> fromFunction(
    UIColor Function(UITraitCollection) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIColor Function(UITraitCollection)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(UITraitCollection.castFromPointer(arg0, retain: true, release: true)).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIColor Function(UITraitCollection)>`.
extension ObjCBlock_UIColor_UITraitCollection$CallExtension on objc.ObjCBlock<UIColor Function(UITraitCollection)> {
  UIColor call(UITraitCollection arg0) => UIColor.castFromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
              ffi.Pointer<objc.ObjCBlockImpl> block,
              ffi.Pointer<objc.ObjCObject> arg0,
            )
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
        >()(ref.pointer, arg0.ref.pointer),
    retain: true,
    release: true,
  );
}

late final _sel_colorWithDynamicProvider_ = objc.registerName("colorWithDynamicProvider:");
final _objc_msgSend_nnxkei = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_initWithDynamicProvider_ = objc.registerName("initWithDynamicProvider:");
late final _sel_resolvedColorWithTraitCollection_ = objc.registerName("resolvedColorWithTraitCollection:");

/// DynamicColors
extension DynamicColors on UIColor {
  /// initWithDynamicProvider:
  UIColor initWithDynamicProvider(objc.ObjCBlock<UIColor Function(UITraitCollection)> dynamicProvider) {
    objc.checkOsVersionInternal('UIColor.initWithDynamicProvider:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_nnxkei(
      this.ref.retainAndReturnPointer(),
      _sel_initWithDynamicProvider_,
      dynamicProvider.ref.pointer,
    );
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// resolvedColorWithTraitCollection:
  UIColor resolvedColorWithTraitCollection(UITraitCollection traitCollection) {
    objc.checkOsVersionInternal('UIColor.resolvedColorWithTraitCollection:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_resolvedColorWithTraitCollection_,
      traitCollection.ref.pointer,
    );
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithDynamicProvider:
  static UIColor colorWithDynamicProvider(objc.ObjCBlock<UIColor Function(UITraitCollection)> dynamicProvider) {
    objc.checkOsVersionInternal('UIColor.colorWithDynamicProvider:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_nnxkei(_class_UIColor, _sel_colorWithDynamicProvider_, dynamicProvider.ref.pointer);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_systemRedColor = objc.registerName("systemRedColor");
late final _sel_systemGreenColor = objc.registerName("systemGreenColor");
late final _sel_systemBlueColor = objc.registerName("systemBlueColor");
late final _sel_systemOrangeColor = objc.registerName("systemOrangeColor");
late final _sel_systemYellowColor = objc.registerName("systemYellowColor");
late final _sel_systemPinkColor = objc.registerName("systemPinkColor");
late final _sel_systemPurpleColor = objc.registerName("systemPurpleColor");
late final _sel_systemTealColor = objc.registerName("systemTealColor");
late final _sel_systemIndigoColor = objc.registerName("systemIndigoColor");
late final _sel_systemBrownColor = objc.registerName("systemBrownColor");
late final _sel_systemMintColor = objc.registerName("systemMintColor");
late final _sel_systemCyanColor = objc.registerName("systemCyanColor");
late final _sel_systemGrayColor = objc.registerName("systemGrayColor");
late final _sel_systemGray2Color = objc.registerName("systemGray2Color");
late final _sel_systemGray3Color = objc.registerName("systemGray3Color");
late final _sel_systemGray4Color = objc.registerName("systemGray4Color");
late final _sel_systemGray5Color = objc.registerName("systemGray5Color");
late final _sel_systemGray6Color = objc.registerName("systemGray6Color");
late final _sel_tintColor = objc.registerName("tintColor");
late final _sel_labelColor = objc.registerName("labelColor");
late final _sel_secondaryLabelColor = objc.registerName("secondaryLabelColor");
late final _sel_tertiaryLabelColor = objc.registerName("tertiaryLabelColor");
late final _sel_quaternaryLabelColor = objc.registerName("quaternaryLabelColor");
late final _sel_linkColor = objc.registerName("linkColor");
late final _sel_placeholderTextColor = objc.registerName("placeholderTextColor");
late final _sel_separatorColor = objc.registerName("separatorColor");
late final _sel_opaqueSeparatorColor = objc.registerName("opaqueSeparatorColor");
late final _sel_systemBackgroundColor = objc.registerName("systemBackgroundColor");
late final _sel_secondarySystemBackgroundColor = objc.registerName("secondarySystemBackgroundColor");
late final _sel_tertiarySystemBackgroundColor = objc.registerName("tertiarySystemBackgroundColor");
late final _sel_systemGroupedBackgroundColor = objc.registerName("systemGroupedBackgroundColor");
late final _sel_secondarySystemGroupedBackgroundColor = objc.registerName("secondarySystemGroupedBackgroundColor");
late final _sel_tertiarySystemGroupedBackgroundColor = objc.registerName("tertiarySystemGroupedBackgroundColor");
late final _sel_systemFillColor = objc.registerName("systemFillColor");
late final _sel_secondarySystemFillColor = objc.registerName("secondarySystemFillColor");
late final _sel_tertiarySystemFillColor = objc.registerName("tertiarySystemFillColor");
late final _sel_quaternarySystemFillColor = objc.registerName("quaternarySystemFillColor");
late final _sel_lightTextColor = objc.registerName("lightTextColor");
late final _sel_darkTextColor = objc.registerName("darkTextColor");
late final _sel_groupTableViewBackgroundColor = objc.registerName("groupTableViewBackgroundColor");
late final _sel_viewFlipsideBackgroundColor = objc.registerName("viewFlipsideBackgroundColor");
late final _sel_scrollViewTexturedBackgroundColor = objc.registerName("scrollViewTexturedBackgroundColor");
late final _sel_underPageBackgroundColor = objc.registerName("underPageBackgroundColor");

/// UIColorSystemColors
extension UIColorSystemColors on UIColor {
  /// darkTextColor
  static UIColor getDarkTextColor() {
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_darkTextColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// groupTableViewBackgroundColor
  static UIColor getGroupTableViewBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.groupTableViewBackgroundColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_groupTableViewBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// labelColor
  static UIColor getLabelColor() {
    objc.checkOsVersionInternal('UIColor.labelColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_labelColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// lightTextColor
  static UIColor getLightTextColor() {
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_lightTextColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// linkColor
  static UIColor getLinkColor() {
    objc.checkOsVersionInternal('UIColor.linkColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_linkColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// opaqueSeparatorColor
  static UIColor getOpaqueSeparatorColor() {
    objc.checkOsVersionInternal('UIColor.opaqueSeparatorColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_opaqueSeparatorColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// placeholderTextColor
  static UIColor getPlaceholderTextColor() {
    objc.checkOsVersionInternal('UIColor.placeholderTextColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_placeholderTextColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// quaternaryLabelColor
  static UIColor getQuaternaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.quaternaryLabelColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_quaternaryLabelColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// quaternarySystemFillColor
  static UIColor getQuaternarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.quaternarySystemFillColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_quaternarySystemFillColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// scrollViewTexturedBackgroundColor
  static UIColor getScrollViewTexturedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.scrollViewTexturedBackgroundColor', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_scrollViewTexturedBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// secondaryLabelColor
  static UIColor getSecondaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.secondaryLabelColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondaryLabelColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// secondarySystemBackgroundColor
  static UIColor getSecondarySystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// secondarySystemFillColor
  static UIColor getSecondarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemFillColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemFillColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// secondarySystemGroupedBackgroundColor
  static UIColor getSecondarySystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.secondarySystemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_secondarySystemGroupedBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// separatorColor
  static UIColor getSeparatorColor() {
    objc.checkOsVersionInternal('UIColor.separatorColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_separatorColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemBackgroundColor
  static UIColor getSystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.systemBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemBlueColor
  static UIColor getSystemBlueColor() {
    objc.checkOsVersionInternal('UIColor.systemBlueColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBlueColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemBrownColor
  static UIColor getSystemBrownColor() {
    objc.checkOsVersionInternal('UIColor.systemBrownColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemBrownColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemCyanColor
  static UIColor getSystemCyanColor() {
    objc.checkOsVersionInternal('UIColor.systemCyanColor', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemCyanColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemFillColor
  static UIColor getSystemFillColor() {
    objc.checkOsVersionInternal('UIColor.systemFillColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemFillColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGray2Color
  static UIColor getSystemGray2Color() {
    objc.checkOsVersionInternal('UIColor.systemGray2Color', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray2Color);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGray3Color
  static UIColor getSystemGray3Color() {
    objc.checkOsVersionInternal('UIColor.systemGray3Color', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray3Color);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGray4Color
  static UIColor getSystemGray4Color() {
    objc.checkOsVersionInternal('UIColor.systemGray4Color', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray4Color);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGray5Color
  static UIColor getSystemGray5Color() {
    objc.checkOsVersionInternal('UIColor.systemGray5Color', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray5Color);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGray6Color
  static UIColor getSystemGray6Color() {
    objc.checkOsVersionInternal('UIColor.systemGray6Color', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGray6Color);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGrayColor
  static UIColor getSystemGrayColor() {
    objc.checkOsVersionInternal('UIColor.systemGrayColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGrayColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGreenColor
  static UIColor getSystemGreenColor() {
    objc.checkOsVersionInternal('UIColor.systemGreenColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGreenColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemGroupedBackgroundColor
  static UIColor getSystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.systemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemGroupedBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemIndigoColor
  static UIColor getSystemIndigoColor() {
    objc.checkOsVersionInternal('UIColor.systemIndigoColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemIndigoColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemMintColor
  static UIColor getSystemMintColor() {
    objc.checkOsVersionInternal('UIColor.systemMintColor', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemMintColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemOrangeColor
  static UIColor getSystemOrangeColor() {
    objc.checkOsVersionInternal('UIColor.systemOrangeColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemOrangeColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemPinkColor
  static UIColor getSystemPinkColor() {
    objc.checkOsVersionInternal('UIColor.systemPinkColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemPinkColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemPurpleColor
  static UIColor getSystemPurpleColor() {
    objc.checkOsVersionInternal('UIColor.systemPurpleColor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemPurpleColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemRedColor
  static UIColor getSystemRedColor() {
    objc.checkOsVersionInternal('UIColor.systemRedColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemRedColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemTealColor
  static UIColor getSystemTealColor() {
    objc.checkOsVersionInternal('UIColor.systemTealColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemTealColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// systemYellowColor
  static UIColor getSystemYellowColor() {
    objc.checkOsVersionInternal('UIColor.systemYellowColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_systemYellowColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tertiaryLabelColor
  static UIColor getTertiaryLabelColor() {
    objc.checkOsVersionInternal('UIColor.tertiaryLabelColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiaryLabelColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tertiarySystemBackgroundColor
  static UIColor getTertiarySystemBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tertiarySystemFillColor
  static UIColor getTertiarySystemFillColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemFillColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemFillColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tertiarySystemGroupedBackgroundColor
  static UIColor getTertiarySystemGroupedBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.tertiarySystemGroupedBackgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tertiarySystemGroupedBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tintColor
  static UIColor getTintColor() {
    objc.checkOsVersionInternal('UIColor.tintColor', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_tintColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// underPageBackgroundColor
  static UIColor getUnderPageBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.underPageBackgroundColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_underPageBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// viewFlipsideBackgroundColor
  static UIColor getViewFlipsideBackgroundColor() {
    objc.checkOsVersionInternal('UIColor.viewFlipsideBackgroundColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_viewFlipsideBackgroundColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }
}

/// UIColor
class UIColor extends objc.NSObject implements objc.NSSecureCoding, objc.NSCopying {
  UIColor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIColor', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIColor] that points to the same underlying object as [other].
  UIColor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIColor] that wraps the given raw object pointer.
  UIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIColor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIColor);
  }

  /// alloc
  static UIColor alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_alloc);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIColor allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIColor, _sel_allocWithZone_, zone);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// blackColor
  static UIColor getBlackColor() {
    objc.checkOsVersionInternal('UIColor.blackColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_blackColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// blueColor
  static UIColor getBlueColor() {
    objc.checkOsVersionInternal('UIColor.blueColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_blueColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// brownColor
  static UIColor getBrownColor() {
    objc.checkOsVersionInternal('UIColor.brownColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_brownColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// clearColor
  static UIColor getClearColor() {
    objc.checkOsVersionInternal('UIColor.clearColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_clearColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithCGColor:
  static UIColor colorWithCGColor(ffi.Pointer<CGColor> cgColor) {
    objc.checkOsVersionInternal('UIColor.colorWithCGColor:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1rsocyz(_class_UIColor, _sel_colorWithCGColor_, cgColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithCIColor:
  static UIColor colorWithCIColor(CIColor ciColor) {
    objc.checkOsVersionInternal('UIColor.colorWithCIColor:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorWithCIColor_, ciColor.ref.pointer);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithDisplayP3Red:green:blue:alpha:
  static UIColor colorWithDisplayP3Red(
    double displayP3Red, {
    required double green,
    required double blue,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.colorWithDisplayP3Red:green:blue:alpha:', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(
      _class_UIColor,
      _sel_colorWithDisplayP3Red_green_blue_alpha_,
      displayP3Red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithHue:saturation:brightness:alpha:
  static UIColor colorWithHue(
    double hue, {
    required double saturation,
    required double brightness,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.colorWithHue:saturation:brightness:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(
      _class_UIColor,
      _sel_colorWithHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithPatternImage:
  static UIColor colorWithPatternImage(UIImage image) {
    objc.checkOsVersionInternal('UIColor.colorWithPatternImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIColor, _sel_colorWithPatternImage_, image.ref.pointer);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:alpha:
  static UIColor colorWithRed(double red, {required double green, required double blue, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.colorWithRed:green:blue:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(_class_UIColor, _sel_colorWithRed_green_blue_alpha_, red, green, blue, alpha);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithWhite:alpha:
  static UIColor colorWithWhite(double white, {required double alpha}) {
    objc.checkOsVersionInternal('UIColor.colorWithWhite:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1n2vn5t(_class_UIColor, _sel_colorWithWhite_alpha_, white, alpha);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// cyanColor
  static UIColor getCyanColor() {
    objc.checkOsVersionInternal('UIColor.cyanColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_cyanColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// darkGrayColor
  static UIColor getDarkGrayColor() {
    objc.checkOsVersionInternal('UIColor.darkGrayColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_darkGrayColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// grayColor
  static UIColor getGrayColor() {
    objc.checkOsVersionInternal('UIColor.grayColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_grayColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// greenColor
  static UIColor getGreenColor() {
    objc.checkOsVersionInternal('UIColor.greenColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_greenColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// lightGrayColor
  static UIColor getLightGrayColor() {
    objc.checkOsVersionInternal('UIColor.lightGrayColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_lightGrayColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// magentaColor
  static UIColor getMagentaColor() {
    objc.checkOsVersionInternal('UIColor.magentaColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_magentaColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIColor new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_new);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static UIColor? objectWithItemProviderData(
    objc.NSData data, {
    required objc.NSString typeIdentifier,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error,
  }) {
    objc.checkOsVersionInternal(
      'UIColor.objectWithItemProviderData:typeIdentifier:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_1pnyuds(
      _class_UIColor,
      _sel_objectWithItemProviderData_typeIdentifier_error_,
      data.ref.pointer,
      typeIdentifier.ref.pointer,
      error,
    );
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// orangeColor
  static UIColor getOrangeColor() {
    objc.checkOsVersionInternal('UIColor.orangeColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_orangeColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// purpleColor
  static UIColor getPurpleColor() {
    objc.checkOsVersionInternal('UIColor.purpleColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_purpleColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// redColor
  static UIColor getRedColor() {
    objc.checkOsVersionInternal('UIColor.redColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_redColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIColor, _sel_supportsSecureCoding);
  }

  /// whiteColor
  static UIColor getWhiteColor() {
    objc.checkOsVersionInternal('UIColor.whiteColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_whiteColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// yellowColor
  static UIColor getYellowColor() {
    objc.checkOsVersionInternal('UIColor.yellowColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIColor, _sel_yellowColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of UIColor constructed with the default `new` method.
  factory UIColor() => new$();
}

extension UIColor$Methods on UIColor {
  /// CGColor
  ffi.Pointer<CGColor> get CGColor$1 {
    objc.checkOsVersionInternal('UIColor.CGColor', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_2u9jmz(this.ref.pointer, _sel_CGColor);
  }

  /// CIColor
  CIColor get CIColor$1 {
    objc.checkOsVersionInternal('UIColor.CIColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_CIColor);
    return CIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// colorWithAlphaComponent:
  UIColor colorWithAlphaComponent(double alpha) {
    objc.checkOsVersionInternal('UIColor.colorWithAlphaComponent:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(this.ref.pointer, _sel_colorWithAlphaComponent_, alpha);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// getHue:saturation:brightness:alpha:
  bool getHue(
    ffi.Pointer<ffi.Double> hue, {
    required ffi.Pointer<ffi.Double> saturation,
    required ffi.Pointer<ffi.Double> brightness,
    required ffi.Pointer<ffi.Double> alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.getHue:saturation:brightness:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_xmvde7(
      this.ref.pointer,
      _sel_getHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
  }

  /// getRed:green:blue:alpha:
  bool getRed(
    ffi.Pointer<ffi.Double> red, {
    required ffi.Pointer<ffi.Double> green,
    required ffi.Pointer<ffi.Double> blue,
    required ffi.Pointer<ffi.Double> alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.getRed:green:blue:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_xmvde7(this.ref.pointer, _sel_getRed_green_blue_alpha_, red, green, blue, alpha);
  }

  /// getWhite:alpha:
  bool getWhite(ffi.Pointer<ffi.Double> white, {required ffi.Pointer<ffi.Double> alpha}) {
    objc.checkOsVersionInternal('UIColor.getWhite:alpha:', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_kcpn4z(this.ref.pointer, _sel_getWhite_alpha_, white, alpha);
  }

  /// init
  UIColor init() {
    objc.checkOsVersionInternal('UIColor.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCGColor:
  UIColor initWithCGColor(ffi.Pointer<CGColor> cgColor) {
    objc.checkOsVersionInternal('UIColor.initWithCGColor:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1rsocyz(this.ref.retainAndReturnPointer(), _sel_initWithCGColor_, cgColor);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCIColor:
  UIColor initWithCIColor(CIColor ciColor) {
    objc.checkOsVersionInternal('UIColor.initWithCIColor:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCIColor_, ciColor.ref.pointer);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIColor? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithDisplayP3Red:green:blue:alpha:
  UIColor initWithDisplayP3Red(
    double displayP3Red, {
    required double green,
    required double blue,
    required double alpha,
  }) {
    objc.checkOsVersionInternal('UIColor.initWithDisplayP3Red:green:blue:alpha:', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithDisplayP3Red_green_blue_alpha_,
      displayP3Red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithHue:saturation:brightness:alpha:
  UIColor initWithHue(double hue, {required double saturation, required double brightness, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithHue:saturation:brightness:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithHue_saturation_brightness_alpha_,
      hue,
      saturation,
      brightness,
      alpha,
    );
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithPatternImage:
  UIColor initWithPatternImage(UIImage image) {
    objc.checkOsVersionInternal('UIColor.initWithPatternImage:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPatternImage_,
      image.ref.pointer,
    );
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:alpha:
  UIColor initWithRed(double red, {required double green, required double blue, required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithRed:green:blue:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_q2wq4h(
      this.ref.retainAndReturnPointer(),
      _sel_initWithRed_green_blue_alpha_,
      red,
      green,
      blue,
      alpha,
    );
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithWhite:alpha:
  UIColor initWithWhite(double white, {required double alpha}) {
    objc.checkOsVersionInternal('UIColor.initWithWhite:alpha:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1n2vn5t(this.ref.retainAndReturnPointer(), _sel_initWithWhite_alpha_, white, alpha);
    return UIColor.castFromPointer($ret, retain: false, release: true);
  }

  /// set
  void set$() {
    objc.checkOsVersionInternal('UIColor.set', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_set);
  }

  /// setFill
  void setFill() {
    objc.checkOsVersionInternal('UIColor.setFill', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setFill);
  }

  /// setStroke
  void setStroke() {
    objc.checkOsVersionInternal('UIColor.setStroke', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setStroke);
  }
}

late final _sel_setTintColor_ = objc.registerName("setTintColor:");
late final _sel_setBackgroundVerticalPositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackgroundVerticalPositionAdjustment:forBarMetrics:",
);
final _objc_msgSend_159fszq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Double, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_backgroundVerticalPositionAdjustmentForBarMetrics_ = objc.registerName(
  "backgroundVerticalPositionAdjustmentForBarMetrics:",
);
final _objc_msgSend_1ih4ekw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_1ih4ekwFpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<ffi.Double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

final class UIOffset extends ffi.Struct {
  @ffi.Double()
  external double horizontal;

  @ffi.Double()
  external double vertical;
}

late final _sel_setTitlePositionAdjustment_forBarMetrics_ = objc.registerName(
  "setTitlePositionAdjustment:forBarMetrics:",
);
final _objc_msgSend_dhwtpp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset, int)>();
late final _sel_titlePositionAdjustmentForBarMetrics_ = objc.registerName("titlePositionAdjustmentForBarMetrics:");
final _objc_msgSend_qx0nmf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_qx0nmfStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_setBackButtonBackgroundImage_forState_barMetrics_ = objc.registerName(
  "setBackButtonBackgroundImage:forState:barMetrics:",
);
late final _sel_backButtonBackgroundImageForState_barMetrics_ = objc.registerName(
  "backButtonBackgroundImageForState:barMetrics:",
);
late final _sel_setBackButtonTitlePositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackButtonTitlePositionAdjustment:forBarMetrics:",
);
late final _sel_backButtonTitlePositionAdjustmentForBarMetrics_ = objc.registerName(
  "backButtonTitlePositionAdjustmentForBarMetrics:",
);
late final _sel_setBackButtonBackgroundVerticalPositionAdjustment_forBarMetrics_ = objc.registerName(
  "setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:",
);
late final _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_ = objc.registerName(
  "backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:",
);
late final _class_UIBarButtonItemGroup = objc.getClass("UIBarButtonItemGroup");
late final _sel_initWithBarButtonItems_representativeItem_ = objc.registerName(
  "initWithBarButtonItems:representativeItem:",
);
late final _sel_barButtonItems = objc.registerName("barButtonItems");
late final _sel_setBarButtonItems_ = objc.registerName("setBarButtonItems:");
late final _sel_representativeItem = objc.registerName("representativeItem");
late final _sel_setRepresentativeItem_ = objc.registerName("setRepresentativeItem:");
late final _sel_isDisplayingRepresentativeItem = objc.registerName("isDisplayingRepresentativeItem");

/// UIBarButtonItemGroup
class UIBarButtonItemGroup$1 extends objc.NSObject implements objc.NSCoding {
  UIBarButtonItemGroup$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemGroup$1] that points to the same underlying object as [other].
  UIBarButtonItemGroup$1.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemGroup$1] that wraps the given raw object pointer.
  UIBarButtonItemGroup$1.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItemGroup$1].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItemGroup);
  }

  /// alloc
  static UIBarButtonItemGroup$1 alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItemGroup, _sel_alloc);
    return UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItemGroup$1 allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIBarButtonItemGroup, _sel_allocWithZone_, zone);
    return UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIBarButtonItemGroup$1 new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItemGroup, _sel_new);
    return UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIBarButtonItemGroup$1 constructed with the default `new` method.
  factory UIBarButtonItemGroup$1() => new$();
}

extension UIBarButtonItemGroup$1$Methods on UIBarButtonItemGroup$1 {
  /// The bar button items associated with this group. Changing these items will affect the bar displaying these items without needing to re-set the groups that are in that bar. Any UIBarButtonItems that are already in group will be removed from that group.
  objc.NSArray get barButtonItems {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.barButtonItems', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barButtonItems);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// init
  UIBarButtonItemGroup$1 init() {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// Create a new bar button item group with the given items. When bar button item layout is done, either the group's barButtonItems or its representativeItem is displayed (if it exists).
  UIBarButtonItemGroup$1 initWithBarButtonItems(objc.NSArray barButtonItems, {UIBarButtonItem? representativeItem}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItemGroup.initWithBarButtonItems:representativeItem:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonItems_representativeItem_,
      barButtonItems.ref.pointer,
      representativeItem?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItemGroup$1? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIBarButtonItemGroup$1.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns YES if the representativeItem of this group is currently being displayed, rather than its barButtonItems.
  bool get isDisplayingRepresentativeItem {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.isDisplayingRepresentativeItem', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDisplayingRepresentativeItem);
  }

  /// In order to display as many items as possible, bars that support UIBarButtonItemGroup may choose to collapse items associated with groups to the representativeItem specified by the group.
  /// A bar will only collapse groups that have a representativeItem set, but may still choose to use an alternate presentation of these items.
  /// A UIBarButtonItem may only be either the representativeItem or a member of the barButtonItems of a single UIBarButtonItemGroup and may only represent a single group.
  /// If the representativeItem has an action, then that action will be invoked, otherwise the bar will present a standard UI to allow selection of the barButtonItems in the representedItem's group.
  UIBarButtonItem? get representativeItem {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.representativeItem', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_representativeItem);
    return $ret.address == 0 ? null : UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// The bar button items associated with this group. Changing these items will affect the bar displaying these items without needing to re-set the groups that are in that bar. Any UIBarButtonItems that are already in group will be removed from that group.
  set barButtonItems(objc.NSArray value) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.setBarButtonItems:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBarButtonItems_, value.ref.pointer);
  }

  /// In order to display as many items as possible, bars that support UIBarButtonItemGroup may choose to collapse items associated with groups to the representativeItem specified by the group.
  /// A bar will only collapse groups that have a representativeItem set, but may still choose to use an alternate presentation of these items.
  /// A UIBarButtonItem may only be either the representativeItem or a member of the barButtonItems of a single UIBarButtonItemGroup and may only represent a single group.
  /// If the representativeItem has an action, then that action will be invoked, otherwise the bar will present a standard UI to allow selection of the barButtonItems in the representedItem's group.
  set representativeItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UIBarButtonItemGroup.setRepresentativeItem:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRepresentativeItem_, value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_buttonGroup = objc.registerName("buttonGroup");

/// UIBarButtonItemGroup
extension UIBarButtonItemGroup on UIBarButtonItem {
  /// The group that the UIBarButtonItem is currently associated with, either as a member of the barButtonItems array or as that group's representativeItem.
  UIBarButtonItemGroup$1? get buttonGroup {
    objc.checkOsVersionInternal('UIBarButtonItem.buttonGroup', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_buttonGroup);
    return $ret.address == 0 ? null : UIBarButtonItemGroup$1.castFromPointer($ret, retain: true, release: true);
  }
}

/// UIBarButtonItem
class UIBarButtonItem extends UIBarItem implements objc.NSCoding {
  UIBarButtonItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIBarButtonItem] that points to the same underlying object as [other].
  UIBarButtonItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItem] that wraps the given raw object pointer.
  UIBarButtonItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItem);
  }

  /// alloc
  static UIBarButtonItem alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_alloc);
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIBarButtonItem, _sel_allocWithZone_, zone);
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UIBarButtonItem appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_appearance);
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIBarButtonItem appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIBarButtonItem.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIBarButtonItem, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIBarButtonItem appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceForTraitCollection:whenContainedIn:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIBarButtonItem,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIBarButtonItem appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIBarButtonItem,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIBarButtonItem appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIBarButtonItem.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIBarButtonItem,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIBarButtonItem appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.appearanceWhenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIBarButtonItem,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// Construct a new fixed space item with the given width.
  static UIBarButtonItem fixedSpaceItemOfWidth(double width) {
    objc.checkOsVersionInternal('UIBarButtonItem.fixedSpaceItemOfWidth:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(_class_UIBarButtonItem, _sel_fixedSpaceItemOfWidth_, width);
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// Construct a new flexible space item.
  static UIBarButtonItem flexibleSpaceItem() {
    objc.checkOsVersionInternal('UIBarButtonItem.flexibleSpaceItem', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_flexibleSpaceItem);
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIBarButtonItem new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItem, _sel_new);
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIBarButtonItem constructed with the default `new` method.
  factory UIBarButtonItem() => new$();
}

extension UIBarButtonItem$Methods on UIBarButtonItem {
  /// action
  ffi.Pointer<objc.ObjCSelector> get action {
    objc.checkOsVersionInternal('UIBarButtonItem.action', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1ovaulg(this.ref.pointer, _sel_action);
  }

  /// backButtonBackgroundImageForState:barMetrics:
  UIImage? backButtonBackgroundImageForState(int state, {required UIBarMetrics barMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonBackgroundImageForState:barMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1mmfvr1(
      this.ref.pointer,
      _sel_backButtonBackgroundImageForState_barMetrics_,
      state,
      barMetrics.value,
    );
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:
  double backButtonBackgroundVerticalPositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonBackgroundVerticalPositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ih4ekwFpret(
            this.ref.pointer,
            _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _objc_msgSend_1ih4ekw(
            this.ref.pointer,
            _sel_backButtonBackgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
  }

  /// backButtonTitlePositionAdjustmentForBarMetrics:
  UIOffset backButtonTitlePositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backButtonTitlePositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<UIOffset>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qx0nmfStret(
            $ptr,
            this.ref.pointer,
            _sel_backButtonTitlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : $ptr.ref = _objc_msgSend_qx0nmf(
            this.ref.pointer,
            _sel_backButtonTitlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIOffset>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIOffset>($finalizable);
  }

  /// backgroundImageForState:barMetrics:
  UIImage? backgroundImageForState(int state, {required UIBarMetrics barMetrics}) {
    objc.checkOsVersionInternal('UIBarButtonItem.backgroundImageForState:barMetrics:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1mmfvr1(
      this.ref.pointer,
      _sel_backgroundImageForState_barMetrics_,
      state,
      barMetrics.value,
    );
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// backgroundImageForState:style:barMetrics:
  UIImage? backgroundImageForState$1(
    int state, {
    required UIBarButtonItemStyle style,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.backgroundImageForState:style:barMetrics:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_15kz3t6(
      this.ref.pointer,
      _sel_backgroundImageForState_style_barMetrics_,
      state,
      style.value,
      barMetrics.value,
    );
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// backgroundVerticalPositionAdjustmentForBarMetrics:
  double backgroundVerticalPositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.backgroundVerticalPositionAdjustmentForBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ih4ekwFpret(
            this.ref.pointer,
            _sel_backgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : _objc_msgSend_1ih4ekw(
            this.ref.pointer,
            _sel_backgroundVerticalPositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
  }

  /// Indicates if the button changes selection as its primary action.
  /// This shows the menu as options for selection if a menu is populated and no action when tapped is enabled.
  /// If no menu is provided and no action is enabled when tapped, the item is toggled on and off for the primary action.
  bool get changesSelectionAsPrimaryAction {
    objc.checkOsVersionInternal('UIBarButtonItem.changesSelectionAsPrimaryAction', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_changesSelectionAsPrimaryAction);
  }

  /// customView
  UIView? get customView {
    objc.checkOsVersionInternal('UIBarButtonItem.customView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_customView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// init
  UIBarButtonItem init() {
    objc.checkOsVersionInternal('UIBarButtonItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Creates a bar button item for the given systemItem. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithBarButtonSystemItem(UIBarButtonSystemItem systemItem, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:menu:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_ka2bhe(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_menu_,
      systemItem.value,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Creates a bar button item for the given systemItem. The primaryAction is copied, and its title & image are ignored.
  UIBarButtonItem initWithBarButtonSystemItem$1(UIBarButtonSystemItem systemItem, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:primaryAction:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_ka2bhe(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_primaryAction_,
      systemItem.value,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithBarButtonSystemItem:target:action:
  UIBarButtonItem initWithBarButtonSystemItem$2(
    UIBarButtonSystemItem systemItem, {
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithBarButtonSystemItem:target:action:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_18lulgh(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarButtonSystemItem_target_action_,
      systemItem.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItem? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCustomView:
  UIBarButtonItem initWithCustomView(UIView customView) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithCustomView:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithCustomView_,
      customView.ref.pointer,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithImage:landscapeImagePhone:style:target:action:
  UIBarButtonItem initWithImage(
    UIImage? image, {
    UIImage? landscapeImagePhone,
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.initWithImage:landscapeImagePhone:style:target:action:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_1d97k9n(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_landscapeImagePhone_style_target_action_,
      image?.ref.pointer ?? ffi.nullptr,
      landscapeImagePhone?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item with the given item. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithImage$1(UIImage? image, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithImage:menu:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_menu_,
      image?.ref.pointer ?? ffi.nullptr,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithImage:style:target:action:
  UIBarButtonItem initWithImage$2(
    UIImage? image, {
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithImage:style:target:action:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_13sbrg9(
      this.ref.retainAndReturnPointer(),
      _sel_initWithImage_style_target_action_,
      image?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item from the properties of primaryAction. primaryAction is copied.
  UIBarButtonItem initWithPrimaryAction(UIAction? primaryAction) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithPrimaryAction:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithPrimaryAction_,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Creates a plain-style bar button item with the given title. The constructed item will present the menu immediately when touched.
  UIBarButtonItem initWithTitle(objc.NSString? title, {UIMenu? menu}) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithTitle:menu:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_menu_,
      title?.ref.pointer ?? ffi.nullptr,
      menu?.ref.pointer ?? ffi.nullptr,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTitle:style:target:action:
  UIBarButtonItem initWithTitle$1(
    objc.NSString? title, {
    required UIBarButtonItemStyle style,
    objc.ObjCObjectBase? target,
    required ffi.Pointer<objc.ObjCSelector> action,
  }) {
    objc.checkOsVersionInternal('UIBarButtonItem.initWithTitle:style:target:action:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_13sbrg9(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_style_target_action_,
      title?.ref.pointer ?? ffi.nullptr,
      style.value,
      target?.ref.pointer ?? ffi.nullptr,
      action,
    );
    return UIBarButtonItem.castFromPointer($ret, retain: false, release: true);
  }

  /// isSelected
  bool get isSelected {
    objc.checkOsVersionInternal('UIBarButtonItem.isSelected', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// When non-nil the menu is presented, the gesture used to trigger the menu is based on if the bar button item would normally trigger an action when tapped.
  UIMenu? get menu {
    objc.checkOsVersionInternal('UIBarButtonItem.menu', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_menu);
    return $ret.address == 0 ? null : UIMenu.castFromPointer($ret, retain: true, release: true);
  }

  /// possibleTitles
  objc.NSSet? get possibleTitles {
    objc.checkOsVersionInternal('UIBarButtonItem.possibleTitles', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_possibleTitles);
    return $ret.address == 0 ? null : objc.NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// Set the primaryAction on this item, updating the title & image of the item if appropriate (primaryAction is non-nil, and this is not a system item). When primaryAction is non-nil, the target & action properties are ignored. If primaryAction is set to nil, the title & image properties are left unchanged.
  UIAction? get primaryAction {
    objc.checkOsVersionInternal('UIBarButtonItem.primaryAction', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_primaryAction);
    return $ret.address == 0 ? null : UIAction.castFromPointer($ret, retain: true, release: true);
  }

  /// setAction:
  set action(ffi.Pointer<objc.ObjCSelector> value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setAction:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(this.ref.pointer, _sel_setAction_, value);
  }

  /// setBackButtonBackgroundImage:forState:barMetrics:
  void setBackButtonBackgroundImage(
    UIImage? backgroundImage, {
    required int forState,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonBackgroundImage:forState:barMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1oar0aj(
      this.ref.pointer,
      _sel_setBackButtonBackgroundImage_forState_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState,
      barMetrics.value,
    );
  }

  /// setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:
  void setBackButtonBackgroundVerticalPositionAdjustment(double adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonBackgroundVerticalPositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_159fszq(
      this.ref.pointer,
      _sel_setBackButtonBackgroundVerticalPositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// setBackButtonTitlePositionAdjustment:forBarMetrics:
  void setBackButtonTitlePositionAdjustment(UIOffset adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackButtonTitlePositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_dhwtpp(
      this.ref.pointer,
      _sel_setBackButtonTitlePositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// setBackgroundImage:forState:barMetrics:
  void setBackgroundImage(UIImage? backgroundImage, {required int forState, required UIBarMetrics barMetrics}) {
    objc.checkOsVersionInternal('UIBarButtonItem.setBackgroundImage:forState:barMetrics:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1oar0aj(
      this.ref.pointer,
      _sel_setBackgroundImage_forState_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState,
      barMetrics.value,
    );
  }

  /// setBackgroundImage:forState:style:barMetrics:
  void setBackgroundImage$1(
    UIImage? backgroundImage, {
    required int forState,
    required UIBarButtonItemStyle style,
    required UIBarMetrics barMetrics,
  }) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackgroundImage:forState:style:barMetrics:',
      iOS: (false, (6, 0, 0)),
    );
    _objc_msgSend_1lg97nc(
      this.ref.pointer,
      _sel_setBackgroundImage_forState_style_barMetrics_,
      backgroundImage?.ref.pointer ?? ffi.nullptr,
      forState,
      style.value,
      barMetrics.value,
    );
  }

  /// setBackgroundVerticalPositionAdjustment:forBarMetrics:
  void setBackgroundVerticalPositionAdjustment(double adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal(
      'UIBarButtonItem.setBackgroundVerticalPositionAdjustment:forBarMetrics:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_159fszq(
      this.ref.pointer,
      _sel_setBackgroundVerticalPositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// Indicates if the button changes selection as its primary action.
  /// This shows the menu as options for selection if a menu is populated and no action when tapped is enabled.
  /// If no menu is provided and no action is enabled when tapped, the item is toggled on and off for the primary action.
  set changesSelectionAsPrimaryAction(bool value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setChangesSelectionAsPrimaryAction:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setChangesSelectionAsPrimaryAction_, value);
  }

  /// setCustomView:
  set customView(UIView? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setCustomView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCustomView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When non-nil the menu is presented, the gesture used to trigger the menu is based on if the bar button item would normally trigger an action when tapped.
  set menu(UIMenu? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setMenu:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMenu_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setPossibleTitles:
  set possibleTitles(objc.NSSet? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setPossibleTitles:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPossibleTitles_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Set the primaryAction on this item, updating the title & image of the item if appropriate (primaryAction is non-nil, and this is not a system item). When primaryAction is non-nil, the target & action properties are ignored. If primaryAction is set to nil, the title & image properties are left unchanged.
  set primaryAction(UIAction? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setPrimaryAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPrimaryAction_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelected:
  set isSelected(bool value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setSelected:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// setStyle:
  set style(UIBarButtonItemStyle value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_11ist7u(this.ref.pointer, _sel_setStyle_, value.value);
  }

  /// setTarget:
  set target(objc.ObjCObjectBase? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTarget:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTarget_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTintColor:
  set tintColor(UIColor? value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTitlePositionAdjustment:forBarMetrics:
  void setTitlePositionAdjustment(UIOffset adjustment, {required UIBarMetrics forBarMetrics}) {
    objc.checkOsVersionInternal('UIBarButtonItem.setTitlePositionAdjustment:forBarMetrics:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_dhwtpp(
      this.ref.pointer,
      _sel_setTitlePositionAdjustment_forBarMetrics_,
      adjustment,
      forBarMetrics.value,
    );
  }

  /// setWidth:
  set width(double value) {
    objc.checkOsVersionInternal('UIBarButtonItem.setWidth:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setWidth_, value);
  }

  /// style
  UIBarButtonItemStyle get style {
    objc.checkOsVersionInternal('UIBarButtonItem.style', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_121lhl0(this.ref.pointer, _sel_style);
    return UIBarButtonItemStyle.fromValue($ret);
  }

  /// target
  objc.ObjCObjectBase? get target {
    objc.checkOsVersionInternal('UIBarButtonItem.target', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_target);
    return $ret.address == 0 ? null : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// tintColor
  UIColor? get tintColor {
    objc.checkOsVersionInternal('UIBarButtonItem.tintColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// titlePositionAdjustmentForBarMetrics:
  UIOffset titlePositionAdjustmentForBarMetrics(UIBarMetrics barMetrics) {
    objc.checkOsVersionInternal('UIBarButtonItem.titlePositionAdjustmentForBarMetrics:', iOS: (false, (5, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIOffset>();
    objc.useMsgSendVariants
        ? _objc_msgSend_qx0nmfStret(
            $ptr,
            this.ref.pointer,
            _sel_titlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          )
        : $ptr.ref = _objc_msgSend_qx0nmf(
            this.ref.pointer,
            _sel_titlePositionAdjustmentForBarMetrics_,
            barMetrics.value,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIOffset>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIOffset>($finalizable);
  }

  /// width
  double get width {
    objc.checkOsVersionInternal('UIBarButtonItem.width', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_width)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_width);
  }
}

late final _sel_editButtonItem = objc.registerName("editButtonItem");

/// UIViewControllerEditing
extension UIViewControllerEditing on UIViewController {
  /// editButtonItem
  UIBarButtonItem get editButtonItem {
    objc.checkOsVersionInternal('UIViewController.editButtonItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_editButtonItem);
    return UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// isEditing
  bool get isEditing {
    objc.checkOsVersionInternal('UIViewController.isEditing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEditing);
  }

  /// setEditing:
  set isEditing(bool value) {
    objc.checkOsVersionInternal('UIViewController.setEditing:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEditing_, value);
  }

  /// setEditing:animated:
  void setEditing(bool editing, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.setEditing:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setEditing_animated_, editing, animated);
  }
}

/// WARNING: UISearchDisplayController is a stub. To generate bindings for this class, include
/// UISearchDisplayController in your config's objc-interfaces list.
///
/// UISearchDisplayController
class UISearchDisplayController extends objc.ObjCObjectBase {
  UISearchDisplayController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISearchDisplayController] that points to the same underlying object as [other].
  UISearchDisplayController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISearchDisplayController] that wraps the given raw object pointer.
  UISearchDisplayController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_searchDisplayController = objc.registerName("searchDisplayController");

/// UISearchDisplayControllerSupport
extension UISearchDisplayControllerSupport on UIViewController {
  /// searchDisplayController
  UISearchDisplayController? get searchDisplayController {
    objc.checkOsVersionInternal('UIViewController.searchDisplayController', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_searchDisplayController);
    return $ret.address == 0 ? null : UISearchDisplayController.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_childViewControllers = objc.registerName("childViewControllers");
late final _sel_addChildViewController_ = objc.registerName("addChildViewController:");
late final _sel_removeFromParentViewController = objc.registerName("removeFromParentViewController");

sealed class UIViewAnimationOptions {
  static const UIViewAnimationOptionLayoutSubviews = 1;
  static const UIViewAnimationOptionAllowUserInteraction = 2;
  static const UIViewAnimationOptionBeginFromCurrentState = 4;
  static const UIViewAnimationOptionRepeat = 8;
  static const UIViewAnimationOptionAutoreverse = 16;
  static const UIViewAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewAnimationOptionOverrideInheritedCurve = 64;
  static const UIViewAnimationOptionAllowAnimatedContent = 128;
  static const UIViewAnimationOptionShowHideTransitionViews = 256;
  static const UIViewAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewAnimationOptionCurveEaseInOut = 0;
  static const UIViewAnimationOptionCurveEaseIn = 65536;
  static const UIViewAnimationOptionCurveEaseOut = 131072;
  static const UIViewAnimationOptionCurveLinear = 196608;
  static const UIViewAnimationOptionTransitionNone = 0;
  static const UIViewAnimationOptionTransitionFlipFromLeft = 1048576;
  static const UIViewAnimationOptionTransitionFlipFromRight = 2097152;
  static const UIViewAnimationOptionTransitionCurlUp = 3145728;
  static const UIViewAnimationOptionTransitionCurlDown = 4194304;
  static const UIViewAnimationOptionTransitionCrossDissolve = 5242880;
  static const UIViewAnimationOptionTransitionFlipFromTop = 6291456;
  static const UIViewAnimationOptionTransitionFlipFromBottom = 7340032;
  static const UIViewAnimationOptionPreferredFramesPerSecondDefault = 0;
  static const UIViewAnimationOptionPreferredFramesPerSecond60 = 50331648;
  static const UIViewAnimationOptionPreferredFramesPerSecond30 = 117440512;
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> fromFunction(
    void Function(bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(
    objc.newClosureBlock(_closureCallable, (bool arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> listener(void Function(bool) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1s56lr9(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Bool)> blocking(void Function(bool) fn, {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (bool arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1s56lr9(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Bool)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) {
    (objc.getBlockClosure(block) as void Function(bool))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)> _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> waiter, bool arg0) {
    try {
      (objc.getBlockClosure(block) as void Function(bool))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
  _blockingListenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>.listener(
        _blockingTrampoline,
      )..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Bool arg0)>>()
      .asFunction<void Function(bool)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>(_fnPtrTrampoline).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, bool arg0) =>
      (objc.getBlockClosure(block) as void Function(bool))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Bool)>(_closureTrampoline).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Bool)>`.
extension ObjCBlock_ffiVoid_bool$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Bool)> {
  void call(bool arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Bool arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, bool)>()(ref.pointer, arg0);
}

late final _sel_transitionFromViewController_toViewController_duration_options_animations_completion_ = objc
    .registerName("transitionFromViewController:toViewController:duration:options:animations:completion:");
final _objc_msgSend_2fdtmz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_beginAppearanceTransition_animated_ = objc.registerName("beginAppearanceTransition:animated:");
late final _sel_endAppearanceTransition = objc.registerName("endAppearanceTransition");
late final _sel_childViewControllerForStatusBarStyle = objc.registerName("childViewControllerForStatusBarStyle");
late final _sel_childViewControllerForStatusBarHidden = objc.registerName("childViewControllerForStatusBarHidden");
late final _sel_setOverrideTraitCollection_forChildViewController_ = objc.registerName(
  "setOverrideTraitCollection:forChildViewController:",
);
late final _sel_overrideTraitCollectionForChildViewController_ = objc.registerName(
  "overrideTraitCollectionForChildViewController:",
);
late final _sel_childViewControllerForUserInterfaceStyle = objc.registerName(
  "childViewControllerForUserInterfaceStyle",
);

/// UIContainerViewControllerProtectedMethods
extension UIContainerViewControllerProtectedMethods on UIViewController {
  /// addChildViewController:
  void addChildViewController(UIViewController childController) {
    objc.checkOsVersionInternal('UIViewController.addChildViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addChildViewController_, childController.ref.pointer);
  }

  /// beginAppearanceTransition:animated:
  void beginAppearanceTransition(bool isAppearing, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.beginAppearanceTransition:animated:', macOS: (true, null));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_beginAppearanceTransition_animated_, isAppearing, animated);
  }

  /// childViewControllerForStatusBarHidden
  UIViewController? get childViewControllerForStatusBarHidden {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForStatusBarHidden', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForStatusBarHidden);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// childViewControllerForStatusBarStyle
  UIViewController? get childViewControllerForStatusBarStyle {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForStatusBarStyle', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForStatusBarStyle);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// childViewControllerForUserInterfaceStyle
  UIViewController? get childViewControllerForUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForUserInterfaceStyle', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForUserInterfaceStyle);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// childViewControllers
  objc.NSArray get childViewControllers {
    objc.checkOsVersionInternal('UIViewController.childViewControllers', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllers);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// endAppearanceTransition
  void endAppearanceTransition() {
    objc.checkOsVersionInternal('UIViewController.endAppearanceTransition', macOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endAppearanceTransition);
  }

  /// overrideTraitCollectionForChildViewController:
  UITraitCollection? overrideTraitCollectionForChildViewController(UIViewController childViewController) {
    objc.checkOsVersionInternal(
      'UIViewController.overrideTraitCollectionForChildViewController:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_overrideTraitCollectionForChildViewController_,
      childViewController.ref.pointer,
    );
    return $ret.address == 0 ? null : UITraitCollection.castFromPointer($ret, retain: true, release: true);
  }

  /// removeFromParentViewController
  void removeFromParentViewController() {
    objc.checkOsVersionInternal('UIViewController.removeFromParentViewController', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeFromParentViewController);
  }

  /// setOverrideTraitCollection:forChildViewController:
  void setOverrideTraitCollection(UITraitCollection? collection, {required UIViewController forChildViewController}) {
    objc.checkOsVersionInternal(
      'UIViewController.setOverrideTraitCollection:forChildViewController:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_setOverrideTraitCollection_forChildViewController_,
      collection?.ref.pointer ?? ffi.nullptr,
      forChildViewController.ref.pointer,
    );
  }

  /// transitionFromViewController:toViewController:duration:options:animations:completion:
  void transitionFromViewController(
    UIViewController fromViewController, {
    required UIViewController toViewController,
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.transitionFromViewController:toViewController:duration:options:animations:completion:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_2fdtmz(
      this.ref.pointer,
      _sel_transitionFromViewController_toViewController_duration_options_animations_completion_,
      fromViewController.ref.pointer,
      toViewController.ref.pointer,
      duration,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers = objc.registerName(
  "automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers",
);
late final _sel_shouldAutomaticallyForwardRotationMethods = objc.registerName(
  "shouldAutomaticallyForwardRotationMethods",
);
late final _sel_shouldAutomaticallyForwardAppearanceMethods = objc.registerName(
  "shouldAutomaticallyForwardAppearanceMethods",
);
late final _sel_willMoveToParentViewController_ = objc.registerName("willMoveToParentViewController:");
late final _sel_didMoveToParentViewController_ = objc.registerName("didMoveToParentViewController:");

/// UIContainerViewControllerCallbacks
extension UIContainerViewControllerCallbacks on UIViewController {
  /// automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers
  bool automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers() {
    objc.checkOsVersionInternal(
      'UIViewController.automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers',
      iOS: (false, (5, 0, 0)),
    );
    return _objc_msgSend_91o635(
      this.ref.pointer,
      _sel_automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers,
    );
  }

  /// didMoveToParentViewController:
  void didMoveToParentViewController(UIViewController? parent) {
    objc.checkOsVersionInternal('UIViewController.didMoveToParentViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didMoveToParentViewController_, parent?.ref.pointer ?? ffi.nullptr);
  }

  /// shouldAutomaticallyForwardAppearanceMethods
  bool get shouldAutomaticallyForwardAppearanceMethods {
    objc.checkOsVersionInternal(
      'UIViewController.shouldAutomaticallyForwardAppearanceMethods',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutomaticallyForwardAppearanceMethods);
  }

  /// shouldAutomaticallyForwardRotationMethods
  bool shouldAutomaticallyForwardRotationMethods() {
    objc.checkOsVersionInternal('UIViewController.shouldAutomaticallyForwardRotationMethods', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldAutomaticallyForwardRotationMethods);
  }

  /// willMoveToParentViewController:
  void willMoveToParentViewController(UIViewController? parent) {
    objc.checkOsVersionInternal('UIViewController.willMoveToParentViewController:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToParentViewController_, parent?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_restorationIdentifier = objc.registerName("restorationIdentifier");
late final _sel_setRestorationIdentifier_ = objc.registerName("setRestorationIdentifier:");

/// WARNING: UIViewControllerRestoration is a stub. To generate bindings for this class, include
/// UIViewControllerRestoration in your config's objc-protocols list.
///
/// UIViewControllerRestoration
interface class UIViewControllerRestoration extends objc.ObjCProtocolBase {
  UIViewControllerRestoration._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerRestoration] that points to the same underlying object as [other].
  UIViewControllerRestoration.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerRestoration] that wraps the given raw object pointer.
  UIViewControllerRestoration.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_restorationClass = objc.registerName("restorationClass");
late final _sel_setRestorationClass_ = objc.registerName("setRestorationClass:");
late final _sel_encodeRestorableStateWithCoder_ = objc.registerName("encodeRestorableStateWithCoder:");
late final _sel_decodeRestorableStateWithCoder_ = objc.registerName("decodeRestorableStateWithCoder:");
late final _sel_applicationFinishedRestoringState = objc.registerName("applicationFinishedRestoringState");

/// WARNING: UIStateRestoring is a stub. To generate bindings for this class, include
/// UIStateRestoring in your config's objc-protocols list.
///
/// UIStateRestoring
interface class UIStateRestoring extends objc.ObjCProtocolBase {
  UIStateRestoring._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIStateRestoring] that points to the same underlying object as [other].
  UIStateRestoring.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIStateRestoring] that wraps the given raw object pointer.
  UIStateRestoring.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// UIStateRestoration
extension UIStateRestoration$1 on UIViewController {
  /// applicationFinishedRestoringState
  void applicationFinishedRestoringState() {
    objc.checkOsVersionInternal('UIViewController.applicationFinishedRestoringState', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_applicationFinishedRestoringState);
  }

  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIViewController.decodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIViewController.encodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// restorationClass
  UIViewControllerRestoration? get restorationClass {
    objc.checkOsVersionInternal('UIViewController.restorationClass', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationClass);
    return $ret.address == 0 ? null : UIViewControllerRestoration.castFromPointer($ret, retain: true, release: true);
  }

  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal('UIViewController.restorationIdentifier', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationIdentifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setRestorationClass:
  set restorationClass(UIViewControllerRestoration? value) {
    objc.checkOsVersionInternal('UIViewController.setRestorationClass:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationClass_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setRestorationIdentifier:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_updateViewConstraints = objc.registerName("updateViewConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods$1 on UIViewController {
  /// updateViewConstraints
  void updateViewConstraints() {
    objc.checkOsVersionInternal('UIViewController.updateViewConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateViewConstraints);
  }
}

/// WARNING: UIViewControllerTransitioningDelegate is a stub. To generate bindings for this class, include
/// UIViewControllerTransitioningDelegate in your config's objc-protocols list.
///
/// UIViewControllerTransitioningDelegate
interface class UIViewControllerTransitioningDelegate extends objc.ObjCProtocolBase {
  UIViewControllerTransitioningDelegate._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerTransitioningDelegate] that points to the same underlying object as [other].
  UIViewControllerTransitioningDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerTransitioningDelegate] that wraps the given raw object pointer.
  UIViewControllerTransitioningDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_transitioningDelegate = objc.registerName("transitioningDelegate");
late final _sel_setTransitioningDelegate_ = objc.registerName("setTransitioningDelegate:");

/// UIViewControllerTransitioning
extension UIViewControllerTransitioning on UIViewController {
  /// setTransitioningDelegate:
  set transitioningDelegate(UIViewControllerTransitioningDelegate? value) {
    objc.checkOsVersionInternal('UIViewController.setTransitioningDelegate:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTransitioningDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// transitioningDelegate
  UIViewControllerTransitioningDelegate? get transitioningDelegate {
    objc.checkOsVersionInternal('UIViewController.transitioningDelegate', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_transitioningDelegate);
    return $ret.address == 0
        ? null
        : UIViewControllerTransitioningDelegate.castFromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UILayoutSupport$1 is a stub. To generate bindings for this class, include
/// UILayoutSupport in your config's objc-protocols list.
///
/// UILayoutSupport
interface class UILayoutSupport$1 extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UILayoutSupport$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UILayoutSupport$1] that points to the same underlying object as [other].
  UILayoutSupport$1.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILayoutSupport$1] that wraps the given raw object pointer.
  UILayoutSupport$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_topLayoutGuide = objc.registerName("topLayoutGuide");
late final _sel_bottomLayoutGuide = objc.registerName("bottomLayoutGuide");
late final _sel_additionalSafeAreaInsets = objc.registerName("additionalSafeAreaInsets");
late final _sel_setAdditionalSafeAreaInsets_ = objc.registerName("setAdditionalSafeAreaInsets:");

final class NSDirectionalEdgeInsets extends ffi.Struct {
  @ffi.Double()
  external double top;

  @ffi.Double()
  external double leading;

  @ffi.Double()
  external double bottom;

  @ffi.Double()
  external double trailing;
}

late final _sel_systemMinimumLayoutMargins = objc.registerName("systemMinimumLayoutMargins");
final _objc_msgSend_12yjd2m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<NSDirectionalEdgeInsets Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_12yjd2mStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<NSDirectionalEdgeInsets>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<NSDirectionalEdgeInsets>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_viewRespectsSystemMinimumLayoutMargins = objc.registerName("viewRespectsSystemMinimumLayoutMargins");
late final _sel_setViewRespectsSystemMinimumLayoutMargins_ = objc.registerName(
  "setViewRespectsSystemMinimumLayoutMargins:",
);
late final _sel_viewLayoutMarginsDidChange = objc.registerName("viewLayoutMarginsDidChange");
late final _sel_viewSafeAreaInsetsDidChange = objc.registerName("viewSafeAreaInsetsDidChange");

/// UILayoutSupport
extension UILayoutSupport on UIViewController {
  /// additionalSafeAreaInsets
  UIEdgeInsets get additionalSafeAreaInsets {
    objc.checkOsVersionInternal('UIViewController.additionalSafeAreaInsets', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_additionalSafeAreaInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_additionalSafeAreaInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// bottomLayoutGuide
  UILayoutSupport$1 get bottomLayoutGuide {
    objc.checkOsVersionInternal('UIViewController.bottomLayoutGuide', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bottomLayoutGuide);
    return UILayoutSupport$1.castFromPointer($ret, retain: true, release: true);
  }

  /// setAdditionalSafeAreaInsets:
  set additionalSafeAreaInsets(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIViewController.setAdditionalSafeAreaInsets:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setAdditionalSafeAreaInsets_, value);
  }

  /// setViewRespectsSystemMinimumLayoutMargins:
  set viewRespectsSystemMinimumLayoutMargins(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setViewRespectsSystemMinimumLayoutMargins:',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setViewRespectsSystemMinimumLayoutMargins_, value);
  }

  /// systemMinimumLayoutMargins
  NSDirectionalEdgeInsets get systemMinimumLayoutMargins {
    objc.checkOsVersionInternal('UIViewController.systemMinimumLayoutMargins', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret($ptr, this.ref.pointer, _sel_systemMinimumLayoutMargins)
        : $ptr.ref = _objc_msgSend_12yjd2m(this.ref.pointer, _sel_systemMinimumLayoutMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// topLayoutGuide
  UILayoutSupport$1 get topLayoutGuide {
    objc.checkOsVersionInternal('UIViewController.topLayoutGuide', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topLayoutGuide);
    return UILayoutSupport$1.castFromPointer($ret, retain: true, release: true);
  }

  /// viewLayoutMarginsDidChange
  void viewLayoutMarginsDidChange() {
    objc.checkOsVersionInternal('UIViewController.viewLayoutMarginsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewLayoutMarginsDidChange);
  }

  /// viewRespectsSystemMinimumLayoutMargins
  bool get viewRespectsSystemMinimumLayoutMargins {
    objc.checkOsVersionInternal('UIViewController.viewRespectsSystemMinimumLayoutMargins', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_viewRespectsSystemMinimumLayoutMargins);
  }

  /// viewSafeAreaInsetsDidChange
  void viewSafeAreaInsetsDidChange() {
    objc.checkOsVersionInternal('UIViewController.viewSafeAreaInsetsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewSafeAreaInsetsDidChange);
  }
}

late final _sel_addKeyCommand_ = objc.registerName("addKeyCommand:");
late final _sel_removeKeyCommand_ = objc.registerName("removeKeyCommand:");

/// UIKeyCommand
extension UIKeyCommand on UIViewController {
  /// addKeyCommand:
  void addKeyCommand(UIKeyCommand$1 keyCommand) {
    objc.checkOsVersionInternal('UIViewController.addKeyCommand:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addKeyCommand_, keyCommand.ref.pointer);
  }

  /// removeKeyCommand:
  void removeKeyCommand(UIKeyCommand$1 keyCommand) {
    objc.checkOsVersionInternal('UIViewController.removeKeyCommand:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeKeyCommand_, keyCommand.ref.pointer);
  }
}

late final _sel_performsActionsWhilePresentingModally = objc.registerName("performsActionsWhilePresentingModally");

/// UIPerformsActions
extension UIPerformsActions on UIViewController {
  /// Determines whether the receiver continues to respond to actions while it is presenting a view controller modally.
  ///
  /// Defaults to YES. You can change the default return value by providing a value for UIViewControllerPerformsActionsWhilePresentingModally in your Info.plist file.
  bool get performsActionsWhilePresentingModally {
    objc.checkOsVersionInternal('UIViewController.performsActionsWhilePresentingModally', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_performsActionsWhilePresentingModally);
  }
}

late final _sel_extensionContext = objc.registerName("extensionContext");
late final _sel_beginRequestWithExtensionContext_ = objc.registerName("beginRequestWithExtensionContext:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> listener(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> blocking(
    void Function(ffi.Pointer<ffi.Void>, NSExtensionContext) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSExtensionContext.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSExtensionContext$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSExtensionContext)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSExtensionContext arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// NSExtensionAdditions
extension NSExtensionAdditions on UIViewController {
  /// beginRequestWithExtensionContext:
  void beginRequestWithExtensionContext(NSExtensionContext context) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_beginRequestWithExtensionContext_, context.ref.pointer);
  }

  /// extensionContext
  NSExtensionContext? get extensionContext {
    objc.checkOsVersionInternal('UIViewController.extensionContext', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_extensionContext);
    return $ret.address == 0 ? null : NSExtensionContext.castFromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIPresentationController$1 is a stub. To generate bindings for this class, include
/// UIPresentationController in your config's objc-interfaces list.
///
/// UIPresentationController
class UIPresentationController$1 extends objc.ObjCObjectBase {
  UIPresentationController$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPresentationController$1] that points to the same underlying object as [other].
  UIPresentationController$1.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPresentationController$1] that wraps the given raw object pointer.
  UIPresentationController$1.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_presentationController = objc.registerName("presentationController");

/// WARNING: UISheetPresentationController is a stub. To generate bindings for this class, include
/// UISheetPresentationController in your config's objc-interfaces list.
///
/// UISheetPresentationController
class UISheetPresentationController extends objc.ObjCObjectBase {
  UISheetPresentationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISheetPresentationController] that points to the same underlying object as [other].
  UISheetPresentationController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISheetPresentationController] that wraps the given raw object pointer.
  UISheetPresentationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_sheetPresentationController = objc.registerName("sheetPresentationController");

/// WARNING: UIPopoverPresentationController is a stub. To generate bindings for this class, include
/// UIPopoverPresentationController in your config's objc-interfaces list.
///
/// UIPopoverPresentationController
class UIPopoverPresentationController extends objc.ObjCObjectBase {
  UIPopoverPresentationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIPopoverPresentationController] that points to the same underlying object as [other].
  UIPopoverPresentationController.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIPopoverPresentationController] that wraps the given raw object pointer.
  UIPopoverPresentationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_popoverPresentationController = objc.registerName("popoverPresentationController");
late final _sel_isModalInPresentation = objc.registerName("isModalInPresentation");
late final _sel_setModalInPresentation_ = objc.registerName("setModalInPresentation:");

/// UIPresentationController
extension UIPresentationController on UIViewController {
  /// isModalInPresentation
  bool get isModalInPresentation {
    objc.checkOsVersionInternal('UIViewController.isModalInPresentation', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isModalInPresentation);
  }

  /// popoverPresentationController
  UIPopoverPresentationController? get popoverPresentationController {
    objc.checkOsVersionInternal('UIViewController.popoverPresentationController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_popoverPresentationController);
    return $ret.address == 0
        ? null
        : UIPopoverPresentationController.castFromPointer($ret, retain: true, release: true);
  }

  /// presentationController
  UIPresentationController$1? get presentationController {
    objc.checkOsVersionInternal('UIViewController.presentationController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentationController);
    return $ret.address == 0 ? null : UIPresentationController$1.castFromPointer($ret, retain: true, release: true);
  }

  /// setModalInPresentation:
  set isModalInPresentation(bool value) {
    objc.checkOsVersionInternal('UIViewController.setModalInPresentation:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setModalInPresentation_, value);
  }

  /// sheetPresentationController
  UISheetPresentationController? get sheetPresentationController {
    objc.checkOsVersionInternal('UIViewController.sheetPresentationController', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_sheetPresentationController);
    return $ret.address == 0 ? null : UISheetPresentationController.castFromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIViewControllerPreviewing is a stub. To generate bindings for this class, include
/// UIViewControllerPreviewing in your config's objc-protocols list.
///
/// UIViewControllerPreviewing
interface class UIViewControllerPreviewing extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIViewControllerPreviewing._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerPreviewing] that points to the same underlying object as [other].
  UIViewControllerPreviewing.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerPreviewing] that wraps the given raw object pointer.
  UIViewControllerPreviewing.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// WARNING: UIViewControllerPreviewingDelegate is a stub. To generate bindings for this class, include
/// UIViewControllerPreviewingDelegate in your config's objc-protocols list.
///
/// UIViewControllerPreviewingDelegate
interface class UIViewControllerPreviewingDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIViewControllerPreviewingDelegate._(
    ffi.Pointer<objc.ObjCObject> pointer, {
    bool retain = false,
    bool release = false,
  }) : super(pointer, retain: retain, release: release);

  /// Constructs a [UIViewControllerPreviewingDelegate] that points to the same underlying object as [other].
  UIViewControllerPreviewingDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewControllerPreviewingDelegate] that wraps the given raw object pointer.
  UIViewControllerPreviewingDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_registerForPreviewingWithDelegate_sourceView_ = objc.registerName(
  "registerForPreviewingWithDelegate:sourceView:",
);
late final _sel_unregisterForPreviewingWithContext_ = objc.registerName("unregisterForPreviewingWithContext:");

/// UIViewControllerPreviewingRegistration
extension UIViewControllerPreviewingRegistration on UIViewController {
  /// registerForPreviewingWithDelegate:sourceView:
  UIViewControllerPreviewing registerForPreviewingWithDelegate(
    UIViewControllerPreviewingDelegate delegate, {
    required UIView sourceView,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.registerForPreviewingWithDelegate:sourceView:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      this.ref.pointer,
      _sel_registerForPreviewingWithDelegate_sourceView_,
      delegate.ref.pointer,
      sourceView.ref.pointer,
    );
    return UIViewControllerPreviewing.castFromPointer($ret, retain: true, release: true);
  }

  /// unregisterForPreviewingWithContext:
  void unregisterForPreviewingWithContext(UIViewControllerPreviewing previewing) {
    objc.checkOsVersionInternal('UIViewController.unregisterForPreviewingWithContext:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_unregisterForPreviewingWithContext_, previewing.ref.pointer);
  }
}

late final _sel_childViewControllerForScreenEdgesDeferringSystemGestures = objc.registerName(
  "childViewControllerForScreenEdgesDeferringSystemGestures",
);
late final _sel_preferredScreenEdgesDeferringSystemGestures = objc.registerName(
  "preferredScreenEdgesDeferringSystemGestures",
);
late final _sel_setNeedsUpdateOfScreenEdgesDeferringSystemGestures = objc.registerName(
  "setNeedsUpdateOfScreenEdgesDeferringSystemGestures",
);

/// UIScreenEdgesDeferringSystemGestures
extension UIScreenEdgesDeferringSystemGestures on UIViewController {
  /// childViewControllerForScreenEdgesDeferringSystemGestures
  UIViewController? get childViewControllerForScreenEdgesDeferringSystemGestures {
    objc.checkOsVersionInternal(
      'UIViewController.childViewControllerForScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForScreenEdgesDeferringSystemGestures);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredScreenEdgesDeferringSystemGestures
  int get preferredScreenEdgesDeferringSystemGestures {
    objc.checkOsVersionInternal(
      'UIViewController.preferredScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    return _objc_msgSend_qrqu1s(this.ref.pointer, _sel_preferredScreenEdgesDeferringSystemGestures);
  }

  /// setNeedsUpdateOfScreenEdgesDeferringSystemGestures
  void setNeedsUpdateOfScreenEdgesDeferringSystemGestures() {
    objc.checkOsVersionInternal(
      'UIViewController.setNeedsUpdateOfScreenEdgesDeferringSystemGestures',
      iOS: (false, (11, 0, 0)),
    );
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfScreenEdgesDeferringSystemGestures);
  }
}

late final _sel_childViewControllerForHomeIndicatorAutoHidden = objc.registerName(
  "childViewControllerForHomeIndicatorAutoHidden",
);
late final _sel_prefersHomeIndicatorAutoHidden = objc.registerName("prefersHomeIndicatorAutoHidden");
late final _sel_setNeedsUpdateOfHomeIndicatorAutoHidden = objc.registerName("setNeedsUpdateOfHomeIndicatorAutoHidden");

/// UIHomeIndicatorAutoHidden
extension UIHomeIndicatorAutoHidden on UIViewController {
  /// childViewControllerForHomeIndicatorAutoHidden
  UIViewController? get childViewControllerForHomeIndicatorAutoHidden {
    objc.checkOsVersionInternal(
      'UIViewController.childViewControllerForHomeIndicatorAutoHidden',
      iOS: (false, (11, 0, 0)),
    );
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForHomeIndicatorAutoHidden);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// prefersHomeIndicatorAutoHidden
  bool get prefersHomeIndicatorAutoHidden {
    objc.checkOsVersionInternal('UIViewController.prefersHomeIndicatorAutoHidden', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersHomeIndicatorAutoHidden);
  }

  /// setNeedsUpdateOfHomeIndicatorAutoHidden
  void setNeedsUpdateOfHomeIndicatorAutoHidden() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUpdateOfHomeIndicatorAutoHidden', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfHomeIndicatorAutoHidden);
  }
}

late final _sel_childViewControllerForPointerLock = objc.registerName("childViewControllerForPointerLock");
late final _sel_prefersPointerLocked = objc.registerName("prefersPointerLocked");
late final _sel_setNeedsUpdateOfPrefersPointerLocked = objc.registerName("setNeedsUpdateOfPrefersPointerLocked");

/// UIPointerLockSupport
extension UIPointerLockSupport on UIViewController {
  /// childViewControllerForPointerLock
  UIViewController? get childViewControllerForPointerLock {
    objc.checkOsVersionInternal('UIViewController.childViewControllerForPointerLock', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_childViewControllerForPointerLock);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// prefersPointerLocked
  bool get prefersPointerLocked {
    objc.checkOsVersionInternal('UIViewController.prefersPointerLocked', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersPointerLocked);
  }

  /// setNeedsUpdateOfPrefersPointerLocked
  void setNeedsUpdateOfPrefersPointerLocked() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUpdateOfPrefersPointerLocked', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateOfPrefersPointerLocked);
  }
}

///
extension unnamed on UIViewController {}

late final _class_UINavigationItem = objc.getClass("UINavigationItem");
late final _sel_initWithTitle_ = objc.registerName("initWithTitle:");
late final _sel_titleView = objc.registerName("titleView");
late final _sel_setTitleView_ = objc.registerName("setTitleView:");
late final _sel_prompt = objc.registerName("prompt");
late final _sel_setPrompt_ = objc.registerName("setPrompt:");
late final _sel_backBarButtonItem = objc.registerName("backBarButtonItem");
late final _sel_setBackBarButtonItem_ = objc.registerName("setBackBarButtonItem:");
late final _sel_backButtonTitle = objc.registerName("backButtonTitle");
late final _sel_setBackButtonTitle_ = objc.registerName("setBackButtonTitle:");
late final _sel_hidesBackButton = objc.registerName("hidesBackButton");
late final _sel_setHidesBackButton_ = objc.registerName("setHidesBackButton:");
late final _sel_setHidesBackButton_animated_ = objc.registerName("setHidesBackButton:animated:");

enum UINavigationItemBackButtonDisplayMode {
  /// Default mode, uses an appropriate title, followed by a generic title (typically 'Back'), then no title.
  UINavigationItemBackButtonDisplayModeDefault(0),

  /// Generic titles only. Ignores .title and .backButtonTitle (but *not* .backBarButtonItem.title).
  UINavigationItemBackButtonDisplayModeGeneric(1),

  /// Don't use a title, just the back button indicator image.
  UINavigationItemBackButtonDisplayModeMinimal(2);

  final int value;
  const UINavigationItemBackButtonDisplayMode(this.value);

  static UINavigationItemBackButtonDisplayMode fromValue(int value) => switch (value) {
    0 => UINavigationItemBackButtonDisplayModeDefault,
    1 => UINavigationItemBackButtonDisplayModeGeneric,
    2 => UINavigationItemBackButtonDisplayModeMinimal,
    _ => throw ArgumentError('Unknown value for UINavigationItemBackButtonDisplayMode: $value'),
  };
}

late final _sel_backButtonDisplayMode = objc.registerName("backButtonDisplayMode");
final _objc_msgSend_10bx5wy = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBackButtonDisplayMode_ = objc.registerName("setBackButtonDisplayMode:");
final _objc_msgSend_1dph54c = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_leftBarButtonItems = objc.registerName("leftBarButtonItems");
late final _sel_setLeftBarButtonItems_ = objc.registerName("setLeftBarButtonItems:");
late final _sel_rightBarButtonItems = objc.registerName("rightBarButtonItems");
late final _sel_setRightBarButtonItems_ = objc.registerName("setRightBarButtonItems:");
late final _sel_setLeftBarButtonItems_animated_ = objc.registerName("setLeftBarButtonItems:animated:");
late final _sel_setRightBarButtonItems_animated_ = objc.registerName("setRightBarButtonItems:animated:");
late final _sel_leftItemsSupplementBackButton = objc.registerName("leftItemsSupplementBackButton");
late final _sel_setLeftItemsSupplementBackButton_ = objc.registerName("setLeftItemsSupplementBackButton:");
late final _sel_leftBarButtonItem = objc.registerName("leftBarButtonItem");
late final _sel_setLeftBarButtonItem_ = objc.registerName("setLeftBarButtonItem:");
late final _sel_rightBarButtonItem = objc.registerName("rightBarButtonItem");
late final _sel_setRightBarButtonItem_ = objc.registerName("setRightBarButtonItem:");
late final _sel_setLeftBarButtonItem_animated_ = objc.registerName("setLeftBarButtonItem:animated:");
late final _sel_setRightBarButtonItem_animated_ = objc.registerName("setRightBarButtonItem:animated:");

enum UINavigationItemLargeTitleDisplayMode {
  /// Automatically use the large out-of-line title based on the state of the previous item in the navigation bar. An item with largeTitleDisplayMode=Automatic will show or hide the large title based on the request of the previous navigation item. If the first item pushed is set to Automatic, then it will show the large title if the navigation bar has prefersLargeTitles=YES.
  UINavigationItemLargeTitleDisplayModeAutomatic(0),

  /// Always use a larger title when this item is topmost.
  UINavigationItemLargeTitleDisplayModeAlways(1),

  /// Never use a larger title when this item is topmost.
  UINavigationItemLargeTitleDisplayModeNever(2);

  final int value;
  const UINavigationItemLargeTitleDisplayMode(this.value);

  static UINavigationItemLargeTitleDisplayMode fromValue(int value) => switch (value) {
    0 => UINavigationItemLargeTitleDisplayModeAutomatic,
    1 => UINavigationItemLargeTitleDisplayModeAlways,
    2 => UINavigationItemLargeTitleDisplayModeNever,
    _ => throw ArgumentError('Unknown value for UINavigationItemLargeTitleDisplayMode: $value'),
  };
}

late final _sel_largeTitleDisplayMode = objc.registerName("largeTitleDisplayMode");
final _objc_msgSend_1j6d9um = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLargeTitleDisplayMode_ = objc.registerName("setLargeTitleDisplayMode:");
final _objc_msgSend_1ddnfsg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();

/// WARNING: UISearchController is a stub. To generate bindings for this class, include
/// UISearchController in your config's objc-interfaces list.
///
/// UISearchController
class UISearchController extends objc.ObjCObjectBase {
  UISearchController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISearchController] that points to the same underlying object as [other].
  UISearchController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISearchController] that wraps the given raw object pointer.
  UISearchController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_searchController = objc.registerName("searchController");
late final _sel_setSearchController_ = objc.registerName("setSearchController:");
late final _sel_hidesSearchBarWhenScrolling = objc.registerName("hidesSearchBarWhenScrolling");
late final _sel_setHidesSearchBarWhenScrolling_ = objc.registerName("setHidesSearchBarWhenScrolling:");
late final _class_UINavigationBarAppearance = objc.getClass("UINavigationBarAppearance");

/// UINavigationBarAppearance
class UINavigationBarAppearance extends objc.ObjCObjectBase {
  UINavigationBarAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationBarAppearance] that points to the same underlying object as [other].
  UINavigationBarAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationBarAppearance] that wraps the given raw object pointer.
  UINavigationBarAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationBarAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationBarAppearance);
  }
}

extension UINavigationBarAppearance$Methods on UINavigationBarAppearance {}

late final _sel_standardAppearance = objc.registerName("standardAppearance");
late final _sel_setStandardAppearance_ = objc.registerName("setStandardAppearance:");
late final _sel_compactAppearance = objc.registerName("compactAppearance");
late final _sel_setCompactAppearance_ = objc.registerName("setCompactAppearance:");
late final _sel_scrollEdgeAppearance = objc.registerName("scrollEdgeAppearance");
late final _sel_setScrollEdgeAppearance_ = objc.registerName("setScrollEdgeAppearance:");
late final _sel_compactScrollEdgeAppearance = objc.registerName("compactScrollEdgeAppearance");
late final _sel_setCompactScrollEdgeAppearance_ = objc.registerName("setCompactScrollEdgeAppearance:");

/// UINavigationItem
class UINavigationItem extends objc.NSObject implements objc.NSCoding {
  UINavigationItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationItem] that points to the same underlying object as [other].
  UINavigationItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationItem] that wraps the given raw object pointer.
  UINavigationItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationItem);
  }

  /// alloc
  static UINavigationItem alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UINavigationItem, _sel_alloc);
    return UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UINavigationItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UINavigationItem, _sel_allocWithZone_, zone);
    return UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UINavigationItem new$() {
    final $ret = _objc_msgSend_151sglz(_class_UINavigationItem, _sel_new);
    return UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UINavigationItem constructed with the default `new` method.
  factory UINavigationItem() => new$();
}

extension UINavigationItem$Methods on UINavigationItem {
  /// Bar button item to use for the back button when this item is the navigation bar's backItem.
  UIBarButtonItem? get backBarButtonItem {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backBarButtonItem);
    return $ret.address == 0 ? null : UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// Controls how the back button sources its title.
  UINavigationItemBackButtonDisplayMode get backButtonDisplayMode {
    objc.checkOsVersionInternal('UINavigationItem.backButtonDisplayMode', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_10bx5wy(this.ref.pointer, _sel_backButtonDisplayMode);
    return UINavigationItemBackButtonDisplayMode.fromValue($ret);
  }

  /// Title to use when this item is the navigation bar's backItem. Default is nil. backBarButtonItem takes precedence if both are specified.
  objc.NSString? get backButtonTitle {
    objc.checkOsVersionInternal('UINavigationItem.backButtonTitle', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backButtonTitle);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactAppearance. See UINavigationBar.compactAppearance for further details.
  UINavigationBarAppearance? get compactAppearance {
    objc.checkOsVersionInternal('UINavigationItem.compactAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compactAppearance);
    return $ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactScrollEdgeAppearance. See UINavigationBar.h for further details.
  UINavigationBarAppearance? get compactScrollEdgeAppearance {
    objc.checkOsVersionInternal('UINavigationItem.compactScrollEdgeAppearance', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compactScrollEdgeAppearance);
    return $ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// If YES, this navigation item will hide the back button when it's on top of the stack.
  bool get hidesBackButton {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBackButton);
  }

  /// If this property is true (the default), the searchControllers search bar will hide as the user scrolls in the top view controllers scroll view. If false, the search bar will remain visible and pinned underneath the navigation bar.
  bool get hidesSearchBarWhenScrolling {
    objc.checkOsVersionInternal('UINavigationItem.hidesSearchBarWhenScrolling', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesSearchBarWhenScrolling);
  }

  /// init
  UINavigationItem init() {
    objc.checkOsVersionInternal('UINavigationItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UINavigationItem? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTitle:
  UINavigationItem initWithTitle(objc.NSString title) {
    objc.checkOsVersionInternal('UINavigationItem.initWithTitle:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithTitle_, title.ref.pointer);
    return UINavigationItem.castFromPointer($ret, retain: false, release: true);
  }

  /// When UINavigationBar.prefersLargeTitles=YES, this property controls when the larger out-of-line title is displayed. If prefersLargeTitles=NO, this property has no effect. The default value is Automatic.
  UINavigationItemLargeTitleDisplayMode get largeTitleDisplayMode {
    objc.checkOsVersionInternal('UINavigationItem.largeTitleDisplayMode', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_1j6d9um(this.ref.pointer, _sel_largeTitleDisplayMode);
    return UINavigationItemLargeTitleDisplayMode.fromValue($ret);
  }

  /// Some navigation items want to display a custom left or right item when they're on top of the stack. A custom left item replaces the regular back button unless you set leftItemsSupplementBackButton to YES
  UIBarButtonItem? get leftBarButtonItem {
    objc.checkOsVersionInternal('UINavigationItem.leftBarButtonItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftBarButtonItem);
    return $ret.address == 0 ? null : UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// leftBarButtonItems
  objc.NSArray? get leftBarButtonItems {
    objc.checkOsVersionInternal('UINavigationItem.leftBarButtonItems', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftBarButtonItems);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// leftItemsSupplementBackButton
  bool get leftItemsSupplementBackButton {
    objc.checkOsVersionInternal('UINavigationItem.leftItemsSupplementBackButton', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_leftItemsSupplementBackButton);
  }

  /// Explanatory text to display above the navigation bar buttons.
  objc.NSString? get prompt {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_prompt);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// rightBarButtonItem
  UIBarButtonItem? get rightBarButtonItem {
    objc.checkOsVersionInternal('UINavigationItem.rightBarButtonItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightBarButtonItem);
    return $ret.address == 0 ? null : UIBarButtonItem.castFromPointer($ret, retain: true, release: true);
  }

  /// rightBarButtonItems
  objc.NSArray? get rightBarButtonItems {
    objc.checkOsVersionInternal('UINavigationItem.rightBarButtonItems', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightBarButtonItems);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's scrollEdgeAppearance. See UINavigationBar.scrollEdgeAppearance for further details.
  UINavigationBarAppearance? get scrollEdgeAppearance {
    objc.checkOsVersionInternal('UINavigationItem.scrollEdgeAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scrollEdgeAppearance);
    return $ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// A view controller that will be shown inside of a navigation controller can assign a UISearchController to this property to display the search controllers search bar in its containing navigation controllers navigation bar.
  UISearchController? get searchController {
    objc.checkOsVersionInternal('UINavigationItem.searchController', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_searchController);
    return $ret.address == 0 ? null : UISearchController.castFromPointer($ret, retain: true, release: true);
  }

  /// Bar button item to use for the back button when this item is the navigation bar's backItem.
  set backBarButtonItem(UIBarButtonItem? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Controls how the back button sources its title.
  set backButtonDisplayMode(UINavigationItemBackButtonDisplayMode value) {
    objc.checkOsVersionInternal('UINavigationItem.setBackButtonDisplayMode:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1dph54c(this.ref.pointer, _sel_setBackButtonDisplayMode_, value.value);
  }

  /// Title to use when this item is the navigation bar's backItem. Default is nil. backBarButtonItem takes precedence if both are specified.
  set backButtonTitle(objc.NSString? value) {
    objc.checkOsVersionInternal('UINavigationItem.setBackButtonTitle:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackButtonTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactAppearance. See UINavigationBar.compactAppearance for further details.
  set compactAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setCompactAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCompactAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's compactScrollEdgeAppearance. See UINavigationBar.h for further details.
  set compactScrollEdgeAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setCompactScrollEdgeAppearance:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCompactScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// If YES, this navigation item will hide the back button when it's on top of the stack.
  set hidesBackButton(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBackButton_, value);
  }

  /// setHidesBackButton:animated:
  void setHidesBackButton(bool hidesBackButton, {required bool animated}) {
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setHidesBackButton_animated_, hidesBackButton, animated);
  }

  /// If this property is true (the default), the searchControllers search bar will hide as the user scrolls in the top view controllers scroll view. If false, the search bar will remain visible and pinned underneath the navigation bar.
  set hidesSearchBarWhenScrolling(bool value) {
    objc.checkOsVersionInternal('UINavigationItem.setHidesSearchBarWhenScrolling:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesSearchBarWhenScrolling_, value);
  }

  /// When UINavigationBar.prefersLargeTitles=YES, this property controls when the larger out-of-line title is displayed. If prefersLargeTitles=NO, this property has no effect. The default value is Automatic.
  set largeTitleDisplayMode(UINavigationItemLargeTitleDisplayMode value) {
    objc.checkOsVersionInternal('UINavigationItem.setLargeTitleDisplayMode:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1ddnfsg(this.ref.pointer, _sel_setLargeTitleDisplayMode_, value.value);
  }

  /// Some navigation items want to display a custom left or right item when they're on top of the stack. A custom left item replaces the regular back button unless you set leftItemsSupplementBackButton to YES
  set leftBarButtonItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLeftBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLeftBarButtonItem:animated:
  void setLeftBarButtonItem(UIBarButtonItem? item, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItem:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setLeftBarButtonItem_animated_,
      item?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// setLeftBarButtonItems:
  set leftBarButtonItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItems:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setLeftBarButtonItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLeftBarButtonItems:animated:
  void setLeftBarButtonItems(objc.NSArray? items, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftBarButtonItems:animated:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setLeftBarButtonItems_animated_,
      items?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// setLeftItemsSupplementBackButton:
  set leftItemsSupplementBackButton(bool value) {
    objc.checkOsVersionInternal('UINavigationItem.setLeftItemsSupplementBackButton:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setLeftItemsSupplementBackButton_, value);
  }

  /// Explanatory text to display above the navigation bar buttons.
  set prompt(objc.NSString? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPrompt_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setRightBarButtonItem:
  set rightBarButtonItem(UIBarButtonItem? value) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRightBarButtonItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setRightBarButtonItem:animated:
  void setRightBarButtonItem(UIBarButtonItem? item, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItem:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setRightBarButtonItem_animated_,
      item?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// setRightBarButtonItems:
  set rightBarButtonItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItems:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRightBarButtonItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setRightBarButtonItems:animated:
  void setRightBarButtonItems(objc.NSArray? items, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationItem.setRightBarButtonItems:animated:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setRightBarButtonItems_animated_,
      items?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's scrollEdgeAppearance. See UINavigationBar.scrollEdgeAppearance for further details.
  set scrollEdgeAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setScrollEdgeAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// A view controller that will be shown inside of a navigation controller can assign a UISearchController to this property to display the search controllers search bar in its containing navigation controllers navigation bar.
  set searchController(UISearchController? value) {
    objc.checkOsVersionInternal('UINavigationItem.setSearchController:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSearchController_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's standardAppearance. See UINavigationBar.standardAppearance for further details.
  set standardAppearance(UINavigationBarAppearance? value) {
    objc.checkOsVersionInternal('UINavigationItem.setStandardAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStandardAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Title when topmost on the stack. default is nil
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UINavigationItem.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Custom view to use in lieu of a title. May be sized horizontally. Only used when item is topmost on the stack.
  set titleView(UIView? value) {
    objc.checkOsVersionInternal('UINavigationItem.setTitleView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitleView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is topmost, overrides the hosting navigation bar's standardAppearance. See UINavigationBar.standardAppearance for further details.
  UINavigationBarAppearance? get standardAppearance {
    objc.checkOsVersionInternal('UINavigationItem.standardAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_standardAppearance);
    return $ret.address == 0 ? null : UINavigationBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// Title when topmost on the stack. default is nil
  objc.NSString? get title {
    objc.checkOsVersionInternal('UINavigationItem.title', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// Custom view to use in lieu of a title. May be sized horizontally. Only used when item is topmost on the stack.
  UIView? get titleView {
    objc.checkOsVersionInternal('UINavigationItem.titleView', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_titleView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_navigationItem = objc.registerName("navigationItem");
late final _sel_hidesBottomBarWhenPushed = objc.registerName("hidesBottomBarWhenPushed");
late final _sel_setHidesBottomBarWhenPushed_ = objc.registerName("setHidesBottomBarWhenPushed:");
late final _class_UINavigationController = objc.getClass("UINavigationController");
late final _sel_initWithNavigationBarClass_toolbarClass_ = objc.registerName(
  "initWithNavigationBarClass:toolbarClass:",
);
late final _sel_initWithRootViewController_ = objc.registerName("initWithRootViewController:");
late final _sel_pushViewController_animated_ = objc.registerName("pushViewController:animated:");
late final _sel_popViewControllerAnimated_ = objc.registerName("popViewControllerAnimated:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)
    >();
late final _sel_popToViewController_animated_ = objc.registerName("popToViewController:animated:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();
late final _sel_popToRootViewControllerAnimated_ = objc.registerName("popToRootViewControllerAnimated:");
late final _sel_topViewController = objc.registerName("topViewController");
late final _sel_visibleViewController = objc.registerName("visibleViewController");
late final _sel_viewControllers = objc.registerName("viewControllers");
late final _sel_setViewControllers_ = objc.registerName("setViewControllers:");
late final _sel_setViewControllers_animated_ = objc.registerName("setViewControllers:animated:");
late final _sel_isNavigationBarHidden = objc.registerName("isNavigationBarHidden");
late final _sel_setNavigationBarHidden_ = objc.registerName("setNavigationBarHidden:");
late final _sel_setNavigationBarHidden_animated_ = objc.registerName("setNavigationBarHidden:animated:");

/// WARNING: UINavigationBar is a stub. To generate bindings for this class, include
/// UINavigationBar in your config's objc-interfaces list.
///
/// UINavigationBar
class UINavigationBar extends objc.ObjCObjectBase {
  UINavigationBar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationBar] that points to the same underlying object as [other].
  UINavigationBar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationBar] that wraps the given raw object pointer.
  UINavigationBar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_navigationBar = objc.registerName("navigationBar");
late final _sel_isToolbarHidden = objc.registerName("isToolbarHidden");
late final _sel_setToolbarHidden_ = objc.registerName("setToolbarHidden:");
late final _sel_setToolbarHidden_animated_ = objc.registerName("setToolbarHidden:animated:");

/// WARNING: UIToolbar is a stub. To generate bindings for this class, include
/// UIToolbar in your config's objc-interfaces list.
///
/// UIToolbar
class UIToolbar extends objc.ObjCObjectBase {
  UIToolbar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIToolbar] that points to the same underlying object as [other].
  UIToolbar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIToolbar] that wraps the given raw object pointer.
  UIToolbar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_toolbar = objc.registerName("toolbar");

/// WARNING: UINavigationControllerDelegate is a stub. To generate bindings for this class, include
/// UINavigationControllerDelegate in your config's objc-protocols list.
///
/// UINavigationControllerDelegate
interface class UINavigationControllerDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UINavigationControllerDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UINavigationControllerDelegate] that points to the same underlying object as [other].
  UINavigationControllerDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationControllerDelegate] that wraps the given raw object pointer.
  UINavigationControllerDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_interactivePopGestureRecognizer = objc.registerName("interactivePopGestureRecognizer");
late final _sel_hidesBarsWhenKeyboardAppears = objc.registerName("hidesBarsWhenKeyboardAppears");
late final _sel_setHidesBarsWhenKeyboardAppears_ = objc.registerName("setHidesBarsWhenKeyboardAppears:");
late final _sel_hidesBarsOnSwipe = objc.registerName("hidesBarsOnSwipe");
late final _sel_setHidesBarsOnSwipe_ = objc.registerName("setHidesBarsOnSwipe:");
late final _sel_barHideOnSwipeGestureRecognizer = objc.registerName("barHideOnSwipeGestureRecognizer");
late final _sel_hidesBarsWhenVerticallyCompact = objc.registerName("hidesBarsWhenVerticallyCompact");
late final _sel_setHidesBarsWhenVerticallyCompact_ = objc.registerName("setHidesBarsWhenVerticallyCompact:");
late final _sel_hidesBarsOnTap = objc.registerName("hidesBarsOnTap");
late final _sel_setHidesBarsOnTap_ = objc.registerName("setHidesBarsOnTap:");

/// WARNING: UITapGestureRecognizer is a stub. To generate bindings for this class, include
/// UITapGestureRecognizer in your config's objc-interfaces list.
///
/// UITapGestureRecognizer
class UITapGestureRecognizer extends UIGestureRecognizer {
  UITapGestureRecognizer._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITapGestureRecognizer', iOS: (false, (3, 2, 0)));
  }

  /// Constructs a [UITapGestureRecognizer] that points to the same underlying object as [other].
  UITapGestureRecognizer.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITapGestureRecognizer] that wraps the given raw object pointer.
  UITapGestureRecognizer.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_barHideOnTapGestureRecognizer = objc.registerName("barHideOnTapGestureRecognizer");

/// UINavigationController
class UINavigationController extends UIViewController {
  UINavigationController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UINavigationController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UINavigationController] that points to the same underlying object as [other].
  UINavigationController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UINavigationController] that wraps the given raw object pointer.
  UINavigationController.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UINavigationController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UINavigationController);
  }

  /// new
  static UINavigationController new$() {
    final _ret = _objc_msgSend_151sglz(_class_UINavigationController, _sel_new);
    return UINavigationController.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UINavigationController constructed with the default `new` method.
  factory UINavigationController() => new$();
}

extension UINavigationController$Methods on UINavigationController {
  /// The gesture recognizer that triggers if the bars will hide or show due to a swipe. Do not change the delegate or attempt to replace this gesture by overriding this method.
  UIPanGestureRecognizer get barHideOnSwipeGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.barHideOnSwipeGestureRecognizer', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barHideOnSwipeGestureRecognizer);
    return UIPanGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// The gesture recognizer used to recognize if the bars will hide or show due to a tap in content. Do not change the delegate or attempt to replace this gesture by overriding this method.
  UITapGestureRecognizer get barHideOnTapGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.barHideOnTapGestureRecognizer', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barHideOnTapGestureRecognizer);
    return UITapGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// delegate
  UINavigationControllerDelegate? get delegate {
    objc.checkOsVersionInternal('UINavigationController.delegate', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : UINavigationControllerDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// When the user swipes, the navigation controller's navigationBar & toolbar will be hidden (on a swipe up) or shown (on a swipe down). The toolbar only participates if it has items.
  bool get hidesBarsOnSwipe {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsOnSwipe', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsOnSwipe);
  }

  /// When the user taps, the navigation controller's navigationBar & toolbar will be hidden or shown, depending on the hidden state of the navigationBar. The toolbar will only be shown if it has items to display.
  bool get hidesBarsOnTap {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsOnTap', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsOnTap);
  }

  /// When the keyboard appears, the navigation controller's navigationBar toolbar will be hidden. The bars will remain hidden when the keyboard dismisses, but a tap in the content area will show them.
  bool get hidesBarsWhenKeyboardAppears {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsWhenKeyboardAppears', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsWhenKeyboardAppears);
  }

  /// When the UINavigationController's vertical size class is compact, hide the UINavigationBar and UIToolbar. Unhandled taps in the regions that would normally be occupied by these bars will reveal the bars.
  bool get hidesBarsWhenVerticallyCompact {
    objc.checkOsVersionInternal('UINavigationController.hidesBarsWhenVerticallyCompact', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBarsWhenVerticallyCompact);
  }

  /// initWithCoder:
  UINavigationController? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UINavigationController.initWithCoder:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UINavigationController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithNavigationBarClass:toolbarClass:
  UINavigationController initWithNavigationBarClass(
    objc.ObjCObjectBase? navigationBarClass, {
    objc.ObjCObjectBase? toolbarClass,
  }) {
    objc.checkOsVersionInternal(
      'UINavigationController.initWithNavigationBarClass:toolbarClass:',
      iOS: (false, (5, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNavigationBarClass_toolbarClass_,
      navigationBarClass?.ref.pointer ?? ffi.nullptr,
      toolbarClass?.ref.pointer ?? ffi.nullptr,
    );
    return UINavigationController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithNibName:bundle:
  UINavigationController initWithNibName(objc.NSString? nibNameOrNil, {objc.NSBundle? bundle}) {
    objc.checkOsVersionInternal('UINavigationController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UINavigationController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithRootViewController:
  UINavigationController initWithRootViewController(UIViewController rootViewController) {
    objc.checkOsVersionInternal('UINavigationController.initWithRootViewController:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithRootViewController_,
      rootViewController.ref.pointer,
    );
    return UINavigationController.castFromPointer($ret, retain: false, release: true);
  }

  /// interactivePopGestureRecognizer
  UIGestureRecognizer? get interactivePopGestureRecognizer {
    objc.checkOsVersionInternal('UINavigationController.interactivePopGestureRecognizer', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interactivePopGestureRecognizer);
    return $ret.address == 0 ? null : UIGestureRecognizer.castFromPointer($ret, retain: true, release: true);
  }

  /// isNavigationBarHidden
  bool get isNavigationBarHidden {
    objc.checkOsVersionInternal('UINavigationController.isNavigationBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isNavigationBarHidden);
  }

  /// isToolbarHidden
  bool get isToolbarHidden {
    objc.checkOsVersionInternal('UINavigationController.isToolbarHidden', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isToolbarHidden);
  }

  /// navigationBar
  UINavigationBar get navigationBar {
    objc.checkOsVersionInternal('UINavigationController.navigationBar', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationBar);
    return UINavigationBar.castFromPointer($ret, retain: true, release: true);
  }

  /// popToRootViewControllerAnimated:
  objc.NSArray? popToRootViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UINavigationController.popToRootViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_popToRootViewControllerAnimated_, animated);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// popToViewController:animated:
  objc.NSArray? popToViewController(UIViewController viewController, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.popToViewController:animated:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_17amj0z(
      this.ref.pointer,
      _sel_popToViewController_animated_,
      viewController.ref.pointer,
      animated,
    );
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// popViewControllerAnimated:
  UIViewController? popViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UINavigationController.popViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_popViewControllerAnimated_, animated);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// pushViewController:animated:
  void pushViewController(UIViewController viewController, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.pushViewController:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_pushViewController_animated_, viewController.ref.pointer, animated);
  }

  /// setDelegate:
  set delegate(UINavigationControllerDelegate? value) {
    objc.checkOsVersionInternal('UINavigationController.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When the user swipes, the navigation controller's navigationBar & toolbar will be hidden (on a swipe up) or shown (on a swipe down). The toolbar only participates if it has items.
  set hidesBarsOnSwipe(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsOnSwipe:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsOnSwipe_, value);
  }

  /// When the user taps, the navigation controller's navigationBar & toolbar will be hidden or shown, depending on the hidden state of the navigationBar. The toolbar will only be shown if it has items to display.
  set hidesBarsOnTap(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsOnTap:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsOnTap_, value);
  }

  /// When the keyboard appears, the navigation controller's navigationBar toolbar will be hidden. The bars will remain hidden when the keyboard dismisses, but a tap in the content area will show them.
  set hidesBarsWhenKeyboardAppears(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsWhenKeyboardAppears:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsWhenKeyboardAppears_, value);
  }

  /// When the UINavigationController's vertical size class is compact, hide the UINavigationBar and UIToolbar. Unhandled taps in the regions that would normally be occupied by these bars will reveal the bars.
  set hidesBarsWhenVerticallyCompact(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setHidesBarsWhenVerticallyCompact:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBarsWhenVerticallyCompact_, value);
  }

  /// setNavigationBarHidden:
  set isNavigationBarHidden(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setNavigationBarHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setNavigationBarHidden_, value);
  }

  /// setNavigationBarHidden:animated:
  void setNavigationBarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setNavigationBarHidden:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setNavigationBarHidden_animated_, hidden, animated);
  }

  /// setToolbarHidden:
  set isToolbarHidden(bool value) {
    objc.checkOsVersionInternal('UINavigationController.setToolbarHidden:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setToolbarHidden_, value);
  }

  /// setToolbarHidden:animated:
  void setToolbarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setToolbarHidden:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setToolbarHidden_animated_, hidden, animated);
  }

  /// setViewControllers:
  set viewControllers(objc.NSArray value) {
    objc.checkOsVersionInternal('UINavigationController.setViewControllers:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setViewControllers_, value.ref.pointer);
  }

  /// setViewControllers:animated:
  void setViewControllers(objc.NSArray viewControllers, {required bool animated}) {
    objc.checkOsVersionInternal('UINavigationController.setViewControllers:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_setViewControllers_animated_, viewControllers.ref.pointer, animated);
  }

  /// showViewController:sender:
  void showViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UINavigationController.showViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// toolbar
  UIToolbar get toolbar {
    objc.checkOsVersionInternal('UINavigationController.toolbar', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbar);
    return UIToolbar.castFromPointer($ret, retain: true, release: true);
  }

  /// topViewController
  UIViewController? get topViewController {
    objc.checkOsVersionInternal('UINavigationController.topViewController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// viewControllers
  objc.NSArray get viewControllers {
    objc.checkOsVersionInternal('UINavigationController.viewControllers', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewControllers);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// visibleViewController
  UIViewController? get visibleViewController {
    objc.checkOsVersionInternal('UINavigationController.visibleViewController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_visibleViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_navigationController = objc.registerName("navigationController");

/// UINavigationControllerItem
extension UINavigationControllerItem on UIViewController {
  /// hidesBottomBarWhenPushed
  bool get hidesBottomBarWhenPushed {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hidesBottomBarWhenPushed);
  }

  /// navigationController
  UINavigationController? get navigationController {
    objc.checkOsVersionInternal('UIViewController.navigationController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationController);
    return $ret.address == 0 ? null : UINavigationController.castFromPointer($ret, retain: true, release: true);
  }

  /// navigationItem
  UINavigationItem get navigationItem {
    objc.checkOsVersionInternal('UIViewController.navigationItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_navigationItem);
    return UINavigationItem.castFromPointer($ret, retain: true, release: true);
  }

  /// setHidesBottomBarWhenPushed:
  set hidesBottomBarWhenPushed(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidesBottomBarWhenPushed_, value);
  }
}

late final _sel_toolbarItems = objc.registerName("toolbarItems");
late final _sel_setToolbarItems_ = objc.registerName("setToolbarItems:");
late final _sel_setToolbarItems_animated_ = objc.registerName("setToolbarItems:animated:");

/// UINavigationControllerContextualToolbarItems
extension UINavigationControllerContextualToolbarItems on UIViewController {
  /// setToolbarItems:
  set toolbarItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIViewController.setToolbarItems:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolbarItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setToolbarItems:animated:
  void setToolbarItems(objc.NSArray? toolbarItems, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.setToolbarItems:animated:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setToolbarItems_animated_,
      toolbarItems?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// toolbarItems
  objc.NSArray? get toolbarItems {
    objc.checkOsVersionInternal('UIViewController.toolbarItems', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbarItems);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_transitionCoordinator = objc.registerName("transitionCoordinator");

/// UIViewControllerTransitionCoordinator
extension UIViewControllerTransitionCoordinator$1 on UIViewController {
  /// transitionCoordinator
  UIViewControllerTransitionCoordinator? get transitionCoordinator {
    objc.checkOsVersionInternal('UIViewController.transitionCoordinator', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_transitionCoordinator);
    return $ret.address == 0
        ? null
        : UIViewControllerTransitionCoordinator.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UITabBarItem = objc.getClass("UITabBarItem");
late final _sel_initWithTitle_image_tag_ = objc.registerName("initWithTitle:image:tag:");
final _objc_msgSend_dg412v = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
late final _sel_initWithTitle_image_selectedImage_ = objc.registerName("initWithTitle:image:selectedImage:");

enum UITabBarSystemItem {
  UITabBarSystemItemMore(0),
  UITabBarSystemItemFavorites(1),
  UITabBarSystemItemFeatured(2),
  UITabBarSystemItemTopRated(3),
  UITabBarSystemItemRecents(4),
  UITabBarSystemItemContacts(5),
  UITabBarSystemItemHistory(6),
  UITabBarSystemItemBookmarks(7),
  UITabBarSystemItemSearch(8),
  UITabBarSystemItemDownloads(9),
  UITabBarSystemItemMostRecent(10),
  UITabBarSystemItemMostViewed(11);

  final int value;
  const UITabBarSystemItem(this.value);

  static UITabBarSystemItem fromValue(int value) => switch (value) {
    0 => UITabBarSystemItemMore,
    1 => UITabBarSystemItemFavorites,
    2 => UITabBarSystemItemFeatured,
    3 => UITabBarSystemItemTopRated,
    4 => UITabBarSystemItemRecents,
    5 => UITabBarSystemItemContacts,
    6 => UITabBarSystemItemHistory,
    7 => UITabBarSystemItemBookmarks,
    8 => UITabBarSystemItemSearch,
    9 => UITabBarSystemItemDownloads,
    10 => UITabBarSystemItemMostRecent,
    11 => UITabBarSystemItemMostViewed,
    _ => throw ArgumentError('Unknown value for UITabBarSystemItem: $value'),
  };
}

late final _sel_initWithTabBarSystemItem_tag_ = objc.registerName("initWithTabBarSystemItem:tag:");
final _objc_msgSend_apdtkn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)
    >();
late final _sel_selectedImage = objc.registerName("selectedImage");
late final _sel_setSelectedImage_ = objc.registerName("setSelectedImage:");
late final _sel_badgeValue = objc.registerName("badgeValue");
late final _sel_setBadgeValue_ = objc.registerName("setBadgeValue:");
late final _sel_setFinishedSelectedImage_withFinishedUnselectedImage_ = objc.registerName(
  "setFinishedSelectedImage:withFinishedUnselectedImage:",
);
late final _sel_finishedSelectedImage = objc.registerName("finishedSelectedImage");
late final _sel_finishedUnselectedImage = objc.registerName("finishedUnselectedImage");
late final _sel_titlePositionAdjustment = objc.registerName("titlePositionAdjustment");
final _objc_msgSend_1omnhmh = objc.msgSendPointer
    .cast<ffi.NativeFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<UIOffset Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1omnhmhStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<void Function(ffi.Pointer<UIOffset>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitlePositionAdjustment_ = objc.registerName("setTitlePositionAdjustment:");
final _objc_msgSend_tbvpkh = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, UIOffset)>();
late final _sel_badgeColor = objc.registerName("badgeColor");
late final _sel_setBadgeColor_ = objc.registerName("setBadgeColor:");
late final _sel_setBadgeTextAttributes_forState_ = objc.registerName("setBadgeTextAttributes:forState:");
late final _sel_badgeTextAttributesForState_ = objc.registerName("badgeTextAttributesForState:");
late final _class_UIBarAppearance = objc.getClass("UIBarAppearance");

enum UIUserInterfaceIdiom {
  UIUserInterfaceIdiomUnspecified(-1),
  UIUserInterfaceIdiomPhone(0),
  UIUserInterfaceIdiomPad(1),
  UIUserInterfaceIdiomTV(2),
  UIUserInterfaceIdiomCarPlay(3),
  UIUserInterfaceIdiomMac(5);

  final int value;
  const UIUserInterfaceIdiom(this.value);

  static UIUserInterfaceIdiom fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceIdiomUnspecified,
    0 => UIUserInterfaceIdiomPhone,
    1 => UIUserInterfaceIdiomPad,
    2 => UIUserInterfaceIdiomTV,
    3 => UIUserInterfaceIdiomCarPlay,
    5 => UIUserInterfaceIdiomMac,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceIdiom: $value'),
  };
}

late final _sel_initWithIdiom_ = objc.registerName("initWithIdiom:");
final _objc_msgSend_radagd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_idiom = objc.registerName("idiom");
final _objc_msgSend_rtovu5 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_initWithBarAppearance_ = objc.registerName("initWithBarAppearance:");
late final _sel_copy = objc.registerName("copy");
late final _sel_configureWithDefaultBackground = objc.registerName("configureWithDefaultBackground");
late final _sel_configureWithOpaqueBackground = objc.registerName("configureWithOpaqueBackground");
late final _sel_configureWithTransparentBackground = objc.registerName("configureWithTransparentBackground");

/// WARNING: UIBlurEffect is a stub. To generate bindings for this class, include
/// UIBlurEffect in your config's objc-interfaces list.
///
/// UIBlurEffect
class UIBlurEffect extends objc.ObjCObjectBase {
  UIBlurEffect._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIBlurEffect] that points to the same underlying object as [other].
  UIBlurEffect.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBlurEffect] that wraps the given raw object pointer.
  UIBlurEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_backgroundEffect = objc.registerName("backgroundEffect");
late final _sel_setBackgroundEffect_ = objc.registerName("setBackgroundEffect:");
late final _sel_backgroundColor = objc.registerName("backgroundColor");
late final _sel_setBackgroundColor_ = objc.registerName("setBackgroundColor:");
late final _sel_backgroundImage = objc.registerName("backgroundImage");
late final _sel_setBackgroundImage_ = objc.registerName("setBackgroundImage:");

enum UIViewContentMode {
  UIViewContentModeScaleToFill(0),
  UIViewContentModeScaleAspectFit(1),
  UIViewContentModeScaleAspectFill(2),
  UIViewContentModeRedraw(3),
  UIViewContentModeCenter(4),
  UIViewContentModeTop(5),
  UIViewContentModeBottom(6),
  UIViewContentModeLeft(7),
  UIViewContentModeRight(8),
  UIViewContentModeTopLeft(9),
  UIViewContentModeTopRight(10),
  UIViewContentModeBottomLeft(11),
  UIViewContentModeBottomRight(12);

  final int value;
  const UIViewContentMode(this.value);

  static UIViewContentMode fromValue(int value) => switch (value) {
    0 => UIViewContentModeScaleToFill,
    1 => UIViewContentModeScaleAspectFit,
    2 => UIViewContentModeScaleAspectFill,
    3 => UIViewContentModeRedraw,
    4 => UIViewContentModeCenter,
    5 => UIViewContentModeTop,
    6 => UIViewContentModeBottom,
    7 => UIViewContentModeLeft,
    8 => UIViewContentModeRight,
    9 => UIViewContentModeTopLeft,
    10 => UIViewContentModeTopRight,
    11 => UIViewContentModeBottomLeft,
    12 => UIViewContentModeBottomRight,
    _ => throw ArgumentError('Unknown value for UIViewContentMode: $value'),
  };
}

late final _sel_backgroundImageContentMode = objc.registerName("backgroundImageContentMode");
final _objc_msgSend_12r2l30 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBackgroundImageContentMode_ = objc.registerName("setBackgroundImageContentMode:");
final _objc_msgSend_26z7iq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_shadowColor = objc.registerName("shadowColor");
late final _sel_setShadowColor_ = objc.registerName("setShadowColor:");
late final _sel_shadowImage = objc.registerName("shadowImage");
late final _sel_setShadowImage_ = objc.registerName("setShadowImage:");

/// UIBarAppearance
class UIBarAppearance extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIBarAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIBarAppearance] that points to the same underlying object as [other].
  UIBarAppearance.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarAppearance] that wraps the given raw object pointer.
  UIBarAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarAppearance);
  }

  /// alloc
  static UIBarAppearance alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarAppearance, _sel_alloc);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarAppearance allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIBarAppearance, _sel_allocWithZone_, zone);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIBarAppearance new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarAppearance, _sel_new);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIBarAppearance, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIBarAppearance constructed with the default `new` method.
  factory UIBarAppearance() => new$();
}

extension UIBarAppearance$Methods on UIBarAppearance {
  /// A color to use for the bar background. This color is composited over backgroundEffects.
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal('UIBarAppearance.backgroundColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// A specific blur effect to use for the bar background. This effect is composited first when constructing the bar's background.
  UIBlurEffect? get backgroundEffect {
    objc.checkOsVersionInternal('UIBarAppearance.backgroundEffect', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundEffect);
    return $ret.address == 0 ? null : UIBlurEffect.castFromPointer($ret, retain: true, release: true);
  }

  /// An image to use for the bar background. This image is composited over the backgroundColor, and resized per the backgroundImageContentMode.
  UIImage? get backgroundImage {
    objc.checkOsVersionInternal('UIBarAppearance.backgroundImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// The content mode to use when rendering the backgroundImage. Defaults to UIViewContentModeScaleToFill. UIViewContentModeRedraw will be reinterpreted as UIViewContentModeScaleToFill.
  UIViewContentMode get backgroundImageContentMode {
    objc.checkOsVersionInternal('UIBarAppearance.backgroundImageContentMode', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_12r2l30(this.ref.pointer, _sel_backgroundImageContentMode);
    return UIViewContentMode.fromValue($ret);
  }

  /// Reset background and shadow properties to their defaults.
  void configureWithDefaultBackground() {
    objc.checkOsVersionInternal('UIBarAppearance.configureWithDefaultBackground', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_configureWithDefaultBackground);
  }

  /// Reset background and shadow properties to display theme-appropriate opaque colors.
  void configureWithOpaqueBackground() {
    objc.checkOsVersionInternal('UIBarAppearance.configureWithOpaqueBackground', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_configureWithOpaqueBackground);
  }

  /// Reset background and shadow properties to be transparent.
  void configureWithTransparentBackground() {
    objc.checkOsVersionInternal('UIBarAppearance.configureWithTransparentBackground', iOS: (false, (13, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_configureWithTransparentBackground);
  }

  /// copy
  UIBarAppearance copy() {
    objc.checkOsVersionInternal('UIBarAppearance.copy', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_copy);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// The idiom that this appearance object targets.
  UIUserInterfaceIdiom get idiom {
    objc.checkOsVersionInternal('UIBarAppearance.idiom', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_rtovu5(this.ref.pointer, _sel_idiom);
    return UIUserInterfaceIdiom.fromValue($ret);
  }

  /// init
  UIBarAppearance init() {
    objc.checkOsVersionInternal('UIBarAppearance.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// Constructs a new bar appearance, copying all relevant properties from the given appearance object. This initializer is useful for migrating configuration between UIBarAppearance subclasses. For example, you can initialize a UINavigationBarAppearance with a UIToolbarAppearance instance, and shared attributes will be identical between the two.
  UIBarAppearance initWithBarAppearance(UIBarAppearance barAppearance) {
    objc.checkOsVersionInternal('UIBarAppearance.initWithBarAppearance:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarAppearance_,
      barAppearance.ref.pointer,
    );
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarAppearance? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// Constructs a new bar appearance, targeting the passed-in idiom as a hint. Not all platforms support all available idioms. See the idiom property to determine the resolved idiom.
  UIBarAppearance initWithIdiom(UIUserInterfaceIdiom idiom) {
    objc.checkOsVersionInternal('UIBarAppearance.initWithIdiom:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_radagd(this.ref.retainAndReturnPointer(), _sel_initWithIdiom_, idiom.value);
    return UIBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// A color to use for the bar background. This color is composited over backgroundEffects.
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal('UIBarAppearance.setBackgroundColor:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// A specific blur effect to use for the bar background. This effect is composited first when constructing the bar's background.
  set backgroundEffect(UIBlurEffect? value) {
    objc.checkOsVersionInternal('UIBarAppearance.setBackgroundEffect:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundEffect_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// An image to use for the bar background. This image is composited over the backgroundColor, and resized per the backgroundImageContentMode.
  set backgroundImage(UIImage? value) {
    objc.checkOsVersionInternal('UIBarAppearance.setBackgroundImage:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The content mode to use when rendering the backgroundImage. Defaults to UIViewContentModeScaleToFill. UIViewContentModeRedraw will be reinterpreted as UIViewContentModeScaleToFill.
  set backgroundImageContentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal('UIBarAppearance.setBackgroundImageContentMode:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_26z7iq(this.ref.pointer, _sel_setBackgroundImageContentMode_, value.value);
  }

  /// A color to use for the shadow. Its specific behavior depends on the value of shadowImage. If shadowImage is nil, then the shadowColor is used to color the bar's default shadow; a nil or clearColor shadowColor will result in no shadow. If shadowImage is a template image, then the shadowColor is used to tint the image; a nil or clearColor shadowColor will also result in no shadow. If the shadowImage is not a template image, then it will be rendered regardless of the value of shadowColor.
  set shadowColor(UIColor? value) {
    objc.checkOsVersionInternal('UIBarAppearance.setShadowColor:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShadowColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Use an image for the shadow. See shadowColor for how they interact.
  set shadowImage(UIImage? value) {
    objc.checkOsVersionInternal('UIBarAppearance.setShadowImage:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShadowImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// A color to use for the shadow. Its specific behavior depends on the value of shadowImage. If shadowImage is nil, then the shadowColor is used to color the bar's default shadow; a nil or clearColor shadowColor will result in no shadow. If shadowImage is a template image, then the shadowColor is used to tint the image; a nil or clearColor shadowColor will also result in no shadow. If the shadowImage is not a template image, then it will be rendered regardless of the value of shadowColor.
  UIColor? get shadowColor {
    objc.checkOsVersionInternal('UIBarAppearance.shadowColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shadowColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// Use an image for the shadow. See shadowColor for how they interact.
  UIImage? get shadowImage {
    objc.checkOsVersionInternal('UIBarAppearance.shadowImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shadowImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UITabBarAppearance = objc.getClass("UITabBarAppearance");

/// WARNING: UITabBarItemAppearance is a stub. To generate bindings for this class, include
/// UITabBarItemAppearance in your config's objc-interfaces list.
///
/// UITabBarItemAppearance
class UITabBarItemAppearance extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UITabBarItemAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITabBarItemAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UITabBarItemAppearance] that points to the same underlying object as [other].
  UITabBarItemAppearance.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarItemAppearance] that wraps the given raw object pointer.
  UITabBarItemAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_stackedLayoutAppearance = objc.registerName("stackedLayoutAppearance");
late final _sel_setStackedLayoutAppearance_ = objc.registerName("setStackedLayoutAppearance:");
late final _sel_inlineLayoutAppearance = objc.registerName("inlineLayoutAppearance");
late final _sel_setInlineLayoutAppearance_ = objc.registerName("setInlineLayoutAppearance:");
late final _sel_compactInlineLayoutAppearance = objc.registerName("compactInlineLayoutAppearance");
late final _sel_setCompactInlineLayoutAppearance_ = objc.registerName("setCompactInlineLayoutAppearance:");
late final _sel_selectionIndicatorTintColor = objc.registerName("selectionIndicatorTintColor");
late final _sel_setSelectionIndicatorTintColor_ = objc.registerName("setSelectionIndicatorTintColor:");
late final _sel_selectionIndicatorImage = objc.registerName("selectionIndicatorImage");
late final _sel_setSelectionIndicatorImage_ = objc.registerName("setSelectionIndicatorImage:");

enum UITabBarItemPositioning {
  UITabBarItemPositioningAutomatic(0),
  UITabBarItemPositioningFill(1),
  UITabBarItemPositioningCentered(2);

  final int value;
  const UITabBarItemPositioning(this.value);

  static UITabBarItemPositioning fromValue(int value) => switch (value) {
    0 => UITabBarItemPositioningAutomatic,
    1 => UITabBarItemPositioningFill,
    2 => UITabBarItemPositioningCentered,
    _ => throw ArgumentError('Unknown value for UITabBarItemPositioning: $value'),
  };
}

late final _sel_stackedItemPositioning = objc.registerName("stackedItemPositioning");
final _objc_msgSend_1wyriot = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setStackedItemPositioning_ = objc.registerName("setStackedItemPositioning:");
final _objc_msgSend_ya159h = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_stackedItemWidth = objc.registerName("stackedItemWidth");
late final _sel_setStackedItemWidth_ = objc.registerName("setStackedItemWidth:");
late final _sel_stackedItemSpacing = objc.registerName("stackedItemSpacing");
late final _sel_setStackedItemSpacing_ = objc.registerName("setStackedItemSpacing:");

/// UITabBarAppearance
class UITabBarAppearance extends UIBarAppearance {
  UITabBarAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UITabBarAppearance] that points to the same underlying object as [other].
  UITabBarAppearance.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarAppearance] that wraps the given raw object pointer.
  UITabBarAppearance.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITabBarAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITabBarAppearance);
  }

  /// alloc
  static UITabBarAppearance alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITabBarAppearance, _sel_alloc);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UITabBarAppearance allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UITabBarAppearance, _sel_allocWithZone_, zone);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UITabBarAppearance new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITabBarAppearance, _sel_new);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UITabBarAppearance, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UITabBarAppearance constructed with the default `new` method.
  factory UITabBarAppearance() => new$();
}

extension UITabBarAppearance$Methods on UITabBarAppearance {
  /// The appearance for the compact inline tab bar item layout
  UITabBarItemAppearance get compactInlineLayoutAppearance {
    objc.checkOsVersionInternal('UITabBarAppearance.compactInlineLayoutAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_compactInlineLayoutAppearance);
    return UITabBarItemAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// copy
  UITabBarAppearance copy() {
    objc.checkOsVersionInternal('UITabBarAppearance.copy', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_copy);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// init
  UITabBarAppearance init() {
    objc.checkOsVersionInternal('UITabBarAppearance.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// Constructs a new bar appearance, copying all relevant properties from the given appearance object. This initializer is useful for migrating configuration between UIBarAppearance subclasses. For example, you can initialize a UINavigationBarAppearance with a UIToolbarAppearance instance, and shared attributes will be identical between the two.
  UITabBarAppearance initWithBarAppearance(UIBarAppearance barAppearance) {
    objc.checkOsVersionInternal('UITabBarAppearance.initWithBarAppearance:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithBarAppearance_,
      barAppearance.ref.pointer,
    );
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UITabBarAppearance? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// Constructs a new bar appearance, targeting the passed-in idiom as a hint. Not all platforms support all available idioms. See the idiom property to determine the resolved idiom.
  UITabBarAppearance initWithIdiom(UIUserInterfaceIdiom idiom) {
    objc.checkOsVersionInternal('UITabBarAppearance.initWithIdiom:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_radagd(this.ref.retainAndReturnPointer(), _sel_initWithIdiom_, idiom.value);
    return UITabBarAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// The appearance for the inline tab bar item layout
  UITabBarItemAppearance get inlineLayoutAppearance {
    objc.checkOsVersionInternal('UITabBarAppearance.inlineLayoutAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inlineLayoutAppearance);
    return UITabBarItemAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// An image that is rendered behind the selected UITabBarItem and above the tab bar's background. Modified by selectionIndicatorTintColor when appropriate.
  UIImage? get selectionIndicatorImage {
    objc.checkOsVersionInternal('UITabBarAppearance.selectionIndicatorImage', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectionIndicatorImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// A color to use for the selectionIndicator, its specific behavior depends on the value of selectionIndicatorImage. If selectionIndicatorImage is nil, then the selectionIndicatorTintColor is used to color the UITabBar's default selection indicator; a nil or clearColor selectionIndicatorTintColor will result in no indicator. If selectionIndicatorImage is a template image, then the selectionIndicatorTintColor is used to tint the image; a nil or clearColor selectionIndicatorTintColor will also result in no indicator. If the selectionIndicatorImage is not a template image, then it will be rendered without respect to the value of selectionIndicatorTintColor.
  UIColor? get selectionIndicatorTintColor {
    objc.checkOsVersionInternal('UITabBarAppearance.selectionIndicatorTintColor', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectionIndicatorTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// The appearance for the compact inline tab bar item layout
  set compactInlineLayoutAppearance(UITabBarItemAppearance value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setCompactInlineLayoutAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCompactInlineLayoutAppearance_, value.ref.pointer);
  }

  /// The appearance for the inline tab bar item layout
  set inlineLayoutAppearance(UITabBarItemAppearance value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setInlineLayoutAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setInlineLayoutAppearance_, value.ref.pointer);
  }

  /// An image that is rendered behind the selected UITabBarItem and above the tab bar's background. Modified by selectionIndicatorTintColor when appropriate.
  set selectionIndicatorImage(UIImage? value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setSelectionIndicatorImage:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectionIndicatorImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// A color to use for the selectionIndicator, its specific behavior depends on the value of selectionIndicatorImage. If selectionIndicatorImage is nil, then the selectionIndicatorTintColor is used to color the UITabBar's default selection indicator; a nil or clearColor selectionIndicatorTintColor will result in no indicator. If selectionIndicatorImage is a template image, then the selectionIndicatorTintColor is used to tint the image; a nil or clearColor selectionIndicatorTintColor will also result in no indicator. If the selectionIndicatorImage is not a template image, then it will be rendered without respect to the value of selectionIndicatorTintColor.
  set selectionIndicatorTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setSelectionIndicatorTintColor:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectionIndicatorTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Determines how items in the tab bar lay out in the stacked item layout
  set stackedItemPositioning(UITabBarItemPositioning value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setStackedItemPositioning:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_ya159h(this.ref.pointer, _sel_setStackedItemPositioning_, value.value);
  }

  /// setStackedItemSpacing:
  set stackedItemSpacing(double value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setStackedItemSpacing:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setStackedItemSpacing_, value);
  }

  /// setStackedItemWidth:
  set stackedItemWidth(double value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setStackedItemWidth:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setStackedItemWidth_, value);
  }

  /// The appearance for the stacked tab bar item layout
  set stackedLayoutAppearance(UITabBarItemAppearance value) {
    objc.checkOsVersionInternal('UITabBarAppearance.setStackedLayoutAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStackedLayoutAppearance_, value.ref.pointer);
  }

  /// Determines how items in the tab bar lay out in the stacked item layout
  UITabBarItemPositioning get stackedItemPositioning {
    objc.checkOsVersionInternal('UITabBarAppearance.stackedItemPositioning', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1wyriot(this.ref.pointer, _sel_stackedItemPositioning);
    return UITabBarItemPositioning.fromValue($ret);
  }

  /// stackedItemSpacing
  double get stackedItemSpacing {
    objc.checkOsVersionInternal('UITabBarAppearance.stackedItemSpacing', iOS: (false, (13, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_stackedItemSpacing)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_stackedItemSpacing);
  }

  /// stackedItemWidth
  double get stackedItemWidth {
    objc.checkOsVersionInternal('UITabBarAppearance.stackedItemWidth', iOS: (false, (13, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_stackedItemWidth)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_stackedItemWidth);
  }

  /// The appearance for the stacked tab bar item layout
  UITabBarItemAppearance get stackedLayoutAppearance {
    objc.checkOsVersionInternal('UITabBarAppearance.stackedLayoutAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_stackedLayoutAppearance);
    return UITabBarItemAppearance.castFromPointer($ret, retain: true, release: true);
  }
}

/// UITabBarItem
class UITabBarItem extends UIBarItem {
  UITabBarItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UITabBarItem] that points to the same underlying object as [other].
  UITabBarItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarItem] that wraps the given raw object pointer.
  UITabBarItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITabBarItem].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITabBarItem);
  }

  /// alloc
  static UITabBarItem alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITabBarItem, _sel_alloc);
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UITabBarItem allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UITabBarItem, _sel_allocWithZone_, zone);
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UITabBarItem appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UITabBarItem, _sel_appearance);
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UITabBarItem appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UITabBarItem.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UITabBarItem, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UITabBarItem appearanceForTraitCollection$1(
    UITraitCollection trait, {
    UIAppearanceContainer? whenContainedIn,
  }) {
    objc.checkOsVersionInternal('UITabBarItem.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      _class_UITabBarItem,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UITabBarItem appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UITabBarItem.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UITabBarItem,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UITabBarItem appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UITabBarItem.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITabBarItem,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UITabBarItem appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UITabBarItem.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UITabBarItem,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UITabBarItem new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITabBarItem, _sel_new);
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UITabBarItem constructed with the default `new` method.
  factory UITabBarItem() => new$();
}

extension UITabBarItem$Methods on UITabBarItem {
  /// If this item displays a badge, this color will be used for the badge's background. If set to nil, the default background color will be used instead.
  UIColor? get badgeColor {
    objc.checkOsVersionInternal('UITabBarItem.badgeColor', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_badgeColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns attributes previously set via -setBadgeTextAttributes:forState:.
  objc.NSDictionary? badgeTextAttributesForState(int state) {
    objc.checkOsVersionInternal('UITabBarItem.badgeTextAttributesForState:', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1g2zxsx(this.ref.pointer, _sel_badgeTextAttributesForState_, state);
    return $ret.address == 0 ? null : objc.NSDictionary.castFromPointer($ret, retain: true, release: true);
  }

  /// badgeValue
  objc.NSString? get badgeValue {
    objc.checkOsVersionInternal('UITabBarItem.badgeValue', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_badgeValue);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// finishedSelectedImage
  UIImage? finishedSelectedImage() {
    objc.checkOsVersionInternal('UITabBarItem.finishedSelectedImage', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_finishedSelectedImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// finishedUnselectedImage
  UIImage? finishedUnselectedImage() {
    objc.checkOsVersionInternal('UITabBarItem.finishedUnselectedImage', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_finishedUnselectedImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UITabBarItem init() {
    objc.checkOsVersionInternal('UITabBarItem.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UITabBarItem? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTabBarSystemItem:tag:
  UITabBarItem initWithTabBarSystemItem(UITabBarSystemItem systemItem, {required int tag}) {
    objc.checkOsVersionInternal('UITabBarItem.initWithTabBarSystemItem:tag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_apdtkn(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTabBarSystemItem_tag_,
      systemItem.value,
      tag,
    );
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTitle:image:selectedImage:
  UITabBarItem initWithTitle(objc.NSString? title, {UIImage? image, UIImage? selectedImage}) {
    objc.checkOsVersionInternal('UITabBarItem.initWithTitle:image:selectedImage:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_11spmsz(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_image_selectedImage_,
      title?.ref.pointer ?? ffi.nullptr,
      image?.ref.pointer ?? ffi.nullptr,
      selectedImage?.ref.pointer ?? ffi.nullptr,
    );
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithTitle:image:tag:
  UITabBarItem initWithTitle$1(objc.NSString? title, {UIImage? image, required int tag}) {
    objc.checkOsVersionInternal('UITabBarItem.initWithTitle:image:tag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_dg412v(
      this.ref.retainAndReturnPointer(),
      _sel_initWithTitle_image_tag_,
      title?.ref.pointer ?? ffi.nullptr,
      image?.ref.pointer ?? ffi.nullptr,
      tag,
    );
    return UITabBarItem.castFromPointer($ret, retain: false, release: true);
  }

  /// When set and this item is selected, overrides the hosting tab bar's scrollEdgeAppearance.
  UITabBarAppearance? get scrollEdgeAppearance {
    objc.checkOsVersionInternal('UITabBarItem.scrollEdgeAppearance', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scrollEdgeAppearance);
    return $ret.address == 0 ? null : UITabBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// selectedImage
  UIImage? get selectedImage {
    objc.checkOsVersionInternal('UITabBarItem.selectedImage', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// If this item displays a badge, this color will be used for the badge's background. If set to nil, the default background color will be used instead.
  set badgeColor(UIColor? value) {
    objc.checkOsVersionInternal('UITabBarItem.setBadgeColor:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBadgeColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Provide text attributes to use to draw the badge text for the given singular control state (Normal, Disabled, Focused, Selected, or Highlighted). Default values will be supplied for keys that are not provided by this dictionary. See NSAttributedString.h for details on what keys are available.
  void setBadgeTextAttributes(objc.NSDictionary? textAttributes, {required int forState}) {
    objc.checkOsVersionInternal('UITabBarItem.setBadgeTextAttributes:forState:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_dldayz(
      this.ref.pointer,
      _sel_setBadgeTextAttributes_forState_,
      textAttributes?.ref.pointer ?? ffi.nullptr,
      forState,
    );
  }

  /// setBadgeValue:
  set badgeValue(objc.NSString? value) {
    objc.checkOsVersionInternal('UITabBarItem.setBadgeValue:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBadgeValue_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setFinishedSelectedImage:withFinishedUnselectedImage:
  void setFinishedSelectedImage(UIImage? selectedImage, {UIImage? withFinishedUnselectedImage}) {
    objc.checkOsVersionInternal(
      'UITabBarItem.setFinishedSelectedImage:withFinishedUnselectedImage:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_setFinishedSelectedImage_withFinishedUnselectedImage_,
      selectedImage?.ref.pointer ?? ffi.nullptr,
      withFinishedUnselectedImage?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// When set and this item is selected, overrides the hosting tab bar's scrollEdgeAppearance.
  set scrollEdgeAppearance(UITabBarAppearance? value) {
    objc.checkOsVersionInternal('UITabBarItem.setScrollEdgeAppearance:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelectedImage:
  set selectedImage(UIImage? value) {
    objc.checkOsVersionInternal('UITabBarItem.setSelectedImage:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// When set and this item is selected, overrides the hosting tab bar's standardAppearance.
  set standardAppearance(UITabBarAppearance? value) {
    objc.checkOsVersionInternal('UITabBarItem.setStandardAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStandardAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTitlePositionAdjustment:
  set titlePositionAdjustment(UIOffset value) {
    objc.checkOsVersionInternal('UITabBarItem.setTitlePositionAdjustment:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_tbvpkh(this.ref.pointer, _sel_setTitlePositionAdjustment_, value);
  }

  /// When set and this item is selected, overrides the hosting tab bar's standardAppearance.
  UITabBarAppearance? get standardAppearance {
    objc.checkOsVersionInternal('UITabBarItem.standardAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_standardAppearance);
    return $ret.address == 0 ? null : UITabBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// titlePositionAdjustment
  UIOffset get titlePositionAdjustment {
    objc.checkOsVersionInternal('UITabBarItem.titlePositionAdjustment', iOS: (false, (5, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIOffset>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1omnhmhStret($ptr, this.ref.pointer, _sel_titlePositionAdjustment)
        : $ptr.ref = _objc_msgSend_1omnhmh(this.ref.pointer, _sel_titlePositionAdjustment);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIOffset>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIOffset>($finalizable);
  }
}

late final _sel_tabBarItem = objc.registerName("tabBarItem");
late final _sel_setTabBarItem_ = objc.registerName("setTabBarItem:");
late final _class_UITabBarController = objc.getClass("UITabBarController");
late final _sel_selectedViewController = objc.registerName("selectedViewController");
late final _sel_setSelectedViewController_ = objc.registerName("setSelectedViewController:");
late final _sel_selectedIndex = objc.registerName("selectedIndex");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSelectedIndex_ = objc.registerName("setSelectedIndex:");
final _objc_msgSend_1i9r4xy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_moreNavigationController = objc.registerName("moreNavigationController");
late final _sel_customizableViewControllers = objc.registerName("customizableViewControllers");
late final _sel_setCustomizableViewControllers_ = objc.registerName("setCustomizableViewControllers:");
late final _class_UITabBar = objc.getClass("UITabBar");

/// WARNING: UITabBarDelegate is a stub. To generate bindings for this class, include
/// UITabBarDelegate in your config's objc-protocols list.
///
/// UITabBarDelegate
interface class UITabBarDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITabBarDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITabBarDelegate] that points to the same underlying object as [other].
  UITabBarDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarDelegate] that wraps the given raw object pointer.
  UITabBarDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_items = objc.registerName("items");
late final _sel_setItems_ = objc.registerName("setItems:");
late final _sel_selectedItem = objc.registerName("selectedItem");
late final _sel_setSelectedItem_ = objc.registerName("setSelectedItem:");
late final _sel_setItems_animated_ = objc.registerName("setItems:animated:");
late final _sel_beginCustomizingItems_ = objc.registerName("beginCustomizingItems:");
late final _sel_endCustomizingAnimated_ = objc.registerName("endCustomizingAnimated:");
final _objc_msgSend_41h7k3 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_isCustomizing = objc.registerName("isCustomizing");
late final _sel_barTintColor = objc.registerName("barTintColor");
late final _sel_setBarTintColor_ = objc.registerName("setBarTintColor:");
late final _sel_unselectedItemTintColor = objc.registerName("unselectedItemTintColor");
late final _sel_setUnselectedItemTintColor_ = objc.registerName("setUnselectedItemTintColor:");
late final _sel_selectedImageTintColor = objc.registerName("selectedImageTintColor");
late final _sel_setSelectedImageTintColor_ = objc.registerName("setSelectedImageTintColor:");
late final _sel_itemPositioning = objc.registerName("itemPositioning");
late final _sel_setItemPositioning_ = objc.registerName("setItemPositioning:");
late final _sel_itemWidth = objc.registerName("itemWidth");
late final _sel_setItemWidth_ = objc.registerName("setItemWidth:");
late final _sel_itemSpacing = objc.registerName("itemSpacing");
late final _sel_setItemSpacing_ = objc.registerName("setItemSpacing:");

enum UIBarStyle {
  UIBarStyleDefault(0),
  UIBarStyleBlack(1),
  UIBarStyleBlackTranslucent(2);

  static const UIBarStyleBlackOpaque = UIBarStyleBlack;

  final int value;
  const UIBarStyle(this.value);

  static UIBarStyle fromValue(int value) => switch (value) {
    0 => UIBarStyleDefault,
    1 => UIBarStyleBlack,
    2 => UIBarStyleBlackTranslucent,
    _ => throw ArgumentError('Unknown value for UIBarStyle: $value'),
  };

  @override
  String toString() {
    if (this == UIBarStyleBlack) return "UIBarStyle.UIBarStyleBlack, UIBarStyle.UIBarStyleBlackOpaque";
    return super.toString();
  }
}

late final _sel_barStyle = objc.registerName("barStyle");
final _objc_msgSend_5tja1h = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBarStyle_ = objc.registerName("setBarStyle:");
final _objc_msgSend_16yx6jd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isTranslucent = objc.registerName("isTranslucent");
late final _sel_setTranslucent_ = objc.registerName("setTranslucent:");
late final _sel_leadingAccessoryView = objc.registerName("leadingAccessoryView");
late final _sel_trailingAccessoryView = objc.registerName("trailingAccessoryView");

/// UITabBar
class UITabBar extends UIView {
  UITabBar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UITabBar] that points to the same underlying object as [other].
  UITabBar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBar] that wraps the given raw object pointer.
  UITabBar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITabBar].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITabBar);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UITabBar.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UITabBar, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UITabBar.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UITabBar,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UITabBar.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UITabBar,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// new
  static UITabBar new$() {
    final _ret = _objc_msgSend_151sglz(_class_UITabBar, _sel_new);
    return UITabBar.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UITabBar constructed with the default `new` method.
  factory UITabBar() => new$();
}

extension UITabBar$Methods on UITabBar {
  /// backgroundImage
  UIImage? get backgroundImage {
    objc.checkOsVersionInternal('UITabBar.backgroundImage', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// barStyle
  UIBarStyle get barStyle {
    objc.checkOsVersionInternal('UITabBar.barStyle', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_5tja1h(this.ref.pointer, _sel_barStyle);
    return UIBarStyle.fromValue($ret);
  }

  /// barTintColor
  UIColor? get barTintColor {
    objc.checkOsVersionInternal('UITabBar.barTintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_barTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// beginCustomizingItems:
  void beginCustomizingItems(objc.NSArray items) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_beginCustomizingItems_, items.ref.pointer);
  }

  /// delegate
  UITabBarDelegate? get delegate {
    objc.checkOsVersionInternal('UITabBar.delegate', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : UITabBarDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// endCustomizingAnimated:
  bool endCustomizingAnimated(bool animated) {
    return _objc_msgSend_41h7k3(this.ref.pointer, _sel_endCustomizingAnimated_, animated);
  }

  /// initWithCoder:
  UITabBar? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UITabBar.initWithCoder:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITabBar.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UITabBar initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UITabBar.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UITabBar.castFromPointer($ret, retain: false, release: true);
  }

  /// isCustomizing
  bool get isCustomizing {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isCustomizing);
  }

  /// isTranslucent
  bool get isTranslucent {
    objc.checkOsVersionInternal('UITabBar.isTranslucent', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTranslucent);
  }

  /// itemPositioning
  UITabBarItemPositioning get itemPositioning {
    objc.checkOsVersionInternal('UITabBar.itemPositioning', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1wyriot(this.ref.pointer, _sel_itemPositioning);
    return UITabBarItemPositioning.fromValue($ret);
  }

  /// itemSpacing
  double get itemSpacing {
    objc.checkOsVersionInternal('UITabBar.itemSpacing', iOS: (false, (7, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_itemSpacing)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_itemSpacing);
  }

  /// itemWidth
  double get itemWidth {
    objc.checkOsVersionInternal('UITabBar.itemWidth', iOS: (false, (7, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_itemWidth)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_itemWidth);
  }

  /// items
  objc.NSArray? get items {
    objc.checkOsVersionInternal('UITabBar.items', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_items);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// leadingAccessoryView
  UIView get leadingAccessoryView {
    objc.checkOsVersionInternal('UITabBar.leadingAccessoryView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leadingAccessoryView);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// Describes the appearance attributes for the tabBar to use when an observable scroll view is scrolled to the bottom. If not set, standardAppearance will be used instead.
  UITabBarAppearance? get scrollEdgeAppearance {
    objc.checkOsVersionInternal('UITabBar.scrollEdgeAppearance', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scrollEdgeAppearance);
    return $ret.address == 0 ? null : UITabBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// selectedImageTintColor
  UIColor? get selectedImageTintColor {
    objc.checkOsVersionInternal('UITabBar.selectedImageTintColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedImageTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// selectedItem
  UITabBarItem? get selectedItem {
    objc.checkOsVersionInternal('UITabBar.selectedItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedItem);
    return $ret.address == 0 ? null : UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// selectionIndicatorImage
  UIImage? get selectionIndicatorImage {
    objc.checkOsVersionInternal('UITabBar.selectionIndicatorImage', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectionIndicatorImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// setBackgroundImage:
  set backgroundImage(UIImage? value) {
    objc.checkOsVersionInternal('UITabBar.setBackgroundImage:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setBarStyle:
  set barStyle(UIBarStyle value) {
    objc.checkOsVersionInternal('UITabBar.setBarStyle:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_16yx6jd(this.ref.pointer, _sel_setBarStyle_, value.value);
  }

  /// setBarTintColor:
  set barTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UITabBar.setBarTintColor:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBarTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setDelegate:
  set delegate(UITabBarDelegate? value) {
    objc.checkOsVersionInternal('UITabBar.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setItemPositioning:
  set itemPositioning(UITabBarItemPositioning value) {
    objc.checkOsVersionInternal('UITabBar.setItemPositioning:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_ya159h(this.ref.pointer, _sel_setItemPositioning_, value.value);
  }

  /// setItemSpacing:
  set itemSpacing(double value) {
    objc.checkOsVersionInternal('UITabBar.setItemSpacing:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setItemSpacing_, value);
  }

  /// setItemWidth:
  set itemWidth(double value) {
    objc.checkOsVersionInternal('UITabBar.setItemWidth:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setItemWidth_, value);
  }

  /// setItems:
  set items(objc.NSArray? value) {
    objc.checkOsVersionInternal('UITabBar.setItems:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setItems:animated:
  void setItems(objc.NSArray? items, {required bool animated}) {
    objc.checkOsVersionInternal('UITabBar.setItems:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(this.ref.pointer, _sel_setItems_animated_, items?.ref.pointer ?? ffi.nullptr, animated);
  }

  /// Describes the appearance attributes for the tabBar to use when an observable scroll view is scrolled to the bottom. If not set, standardAppearance will be used instead.
  set scrollEdgeAppearance(UITabBarAppearance? value) {
    objc.checkOsVersionInternal('UITabBar.setScrollEdgeAppearance:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScrollEdgeAppearance_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelectedImageTintColor:
  set selectedImageTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UITabBar.setSelectedImageTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedImageTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelectedItem:
  set selectedItem(UITabBarItem? value) {
    objc.checkOsVersionInternal('UITabBar.setSelectedItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedItem_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelectionIndicatorImage:
  set selectionIndicatorImage(UIImage? value) {
    objc.checkOsVersionInternal('UITabBar.setSelectionIndicatorImage:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectionIndicatorImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setShadowImage:
  set shadowImage(UIImage? value) {
    objc.checkOsVersionInternal('UITabBar.setShadowImage:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShadowImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Describes the appearance attributes for the tab bar to use.
  set standardAppearance(UITabBarAppearance value) {
    objc.checkOsVersionInternal('UITabBar.setStandardAppearance:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setStandardAppearance_, value.ref.pointer);
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal('UITabBar.setTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTintColor_, value.ref.pointer);
  }

  /// setTranslucent:
  set isTranslucent(bool value) {
    objc.checkOsVersionInternal('UITabBar.setTranslucent:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setTranslucent_, value);
  }

  /// Unselected items in this tab bar will be tinted with this color. Setting this value to nil indicates that UITabBar should use its default value instead.
  set unselectedItemTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UITabBar.setUnselectedItemTintColor:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUnselectedItemTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// shadowImage
  UIImage? get shadowImage {
    objc.checkOsVersionInternal('UITabBar.shadowImage', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shadowImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// Describes the appearance attributes for the tab bar to use.
  UITabBarAppearance get standardAppearance {
    objc.checkOsVersionInternal('UITabBar.standardAppearance', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_standardAppearance);
    return UITabBarAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UITabBar.tintColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// trailingAccessoryView
  UIView get trailingAccessoryView {
    objc.checkOsVersionInternal('UITabBar.trailingAccessoryView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_trailingAccessoryView);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// Unselected items in this tab bar will be tinted with this color. Setting this value to nil indicates that UITabBar should use its default value instead.
  UIColor? get unselectedItemTintColor {
    objc.checkOsVersionInternal('UITabBar.unselectedItemTintColor', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_unselectedItemTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_tabBar = objc.registerName("tabBar");

/// WARNING: UITabBarControllerDelegate is a stub. To generate bindings for this class, include
/// UITabBarControllerDelegate in your config's objc-protocols list.
///
/// UITabBarControllerDelegate
interface class UITabBarControllerDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITabBarControllerDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITabBarControllerDelegate] that points to the same underlying object as [other].
  UITabBarControllerDelegate.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarControllerDelegate] that wraps the given raw object pointer.
  UITabBarControllerDelegate.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_tabBar_didSelectItem_ = objc.registerName("tabBar:didSelectItem:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITabBar_UITabBarItem {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: true, release: true),
        UITabBarItem.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> listener(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        UITabBarItem.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        UITabBarItem.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        UITabBarItem.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITabBar_UITabBarItem$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, UITabBarItem)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITabBar arg1, UITabBarItem arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_tabBar_willBeginCustomizingItems_ = objc.registerName("tabBar:willBeginCustomizingItems:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITabBar_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: true, release: true),
        objc.NSArray.castFromPointer(arg2, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> listener(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        objc.NSArray.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_fjrv01(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        objc.NSArray.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2) => fn(
        arg0,
        UITabBar.castFromPointer(arg1, retain: false, release: true),
        objc.NSArray.castFromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_fjrv01(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
      arg0,
      arg1,
      arg2,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>)
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>))(
        arg0,
        arg1,
        arg2,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITabBar_NSArray$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITabBar arg1, objc.NSArray arg2) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer);
}

late final _sel_tabBar_didBeginCustomizingItems_ = objc.registerName("tabBar:didBeginCustomizingItems:");
late final _sel_tabBar_willEndCustomizingItems_changed_ = objc.registerName("tabBar:willEndCustomizingItems:changed:");
final _objc_msgSend_1lhy15d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_UITabBar_NSArray_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCObject> arg2,
          ffi.Bool arg3,
        )
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, bool arg3) =>
          fn(
            arg0,
            UITabBar.castFromPointer(arg1, retain: true, release: true),
            objc.NSArray.castFromPointer(arg2, retain: true, release: true),
            arg3,
          ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> listener(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, bool arg3) =>
          fn(
            arg0,
            UITabBar.castFromPointer(arg1, retain: false, release: true),
            objc.NSArray.castFromPointer(arg2, retain: false, release: true),
            arg3,
          ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_8acz2h(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> blocking(
    void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, bool arg3) =>
          fn(
            arg0,
            UITabBar.castFromPointer(arg1, retain: false, release: true),
            objc.NSArray.castFromPointer(arg2, retain: false, release: true),
            arg3,
          ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1, ffi.Pointer<objc.ObjCObject> arg2, bool arg3) =>
          fn(
            arg0,
            UITabBar.castFromPointer(arg1, retain: false, release: true),
            objc.NSArray.castFromPointer(arg2, retain: false, release: true),
            arg3,
          ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_8acz2h(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    bool arg3,
  ) {
    (objc.getBlockClosure(block)
        as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, bool))(
      arg0,
      arg1,
      arg2,
      arg3,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    bool arg3,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, bool))(
        arg0,
        arg1,
        arg2,
        arg3,
      );
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Bool,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Bool,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    bool arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Bool arg3,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, bool)
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Bool,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCObject> arg2,
    bool arg3,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCObject>, bool))(
        arg0,
        arg1,
        arg2,
        arg3,
      );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Bool,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_UITabBar_NSArray_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, UITabBar, objc.NSArray, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, UITabBar arg1, objc.NSArray arg2, bool arg3) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCObject> arg2,
            ffi.Bool arg3,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          bool,
        )
      >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3);
}

late final _sel_tabBar_didEndCustomizingItems_changed_ = objc.registerName("tabBar:didEndCustomizingItems:changed:");

/// !
/// UITabBarController manages a button bar and transition view, for an application with multiple top-level modes.
///
/// To use in your application, add its view to the view hierarchy, then add top-level view controllers in order.
/// Most clients will not need to subclass UITabBarController.
///
/// If more than five view controllers are added to a tab bar controller, only the first four will display.
/// The rest will be accessible under an automatically generated More item.
///
/// UITabBarController is rotatable if all of its view controllers are rotatable.
class UITabBarController extends UIViewController implements UITabBarDelegate, objc.NSCoding {
  UITabBarController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITabBarController', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITabBarController] that points to the same underlying object as [other].
  UITabBarController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITabBarController] that wraps the given raw object pointer.
  UITabBarController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITabBarController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITabBarController);
  }

  /// new
  static UITabBarController new$() {
    final _ret = _objc_msgSend_151sglz(_class_UITabBarController, _sel_new);
    return UITabBarController.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UITabBarController constructed with the default `new` method.
  factory UITabBarController() => new$();
}

extension UITabBarController$Methods on UITabBarController {
  /// customizableViewControllers
  objc.NSArray? get customizableViewControllers {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_customizableViewControllers);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// delegate
  UITabBarControllerDelegate? get delegate {
    objc.checkOsVersionInternal('UITabBarController.delegate', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : UITabBarControllerDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  UITabBarController? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UITabBarController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithNibName:bundle:
  UITabBarController initWithNibName(objc.NSString? nibNameOrNil, {objc.NSBundle? bundle}) {
    objc.checkOsVersionInternal('UITabBarController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UITabBarController.castFromPointer($ret, retain: false, release: true);
  }

  /// moreNavigationController
  UINavigationController get moreNavigationController {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_moreNavigationController);
    return UINavigationController.castFromPointer($ret, retain: true, release: true);
  }

  /// selectedIndex
  int get selectedIndex {
    objc.checkOsVersionInternal('UITabBarController.selectedIndex', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_selectedIndex);
  }

  /// selectedViewController
  UIViewController? get selectedViewController {
    objc.checkOsVersionInternal('UITabBarController.selectedViewController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_selectedViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// setCustomizableViewControllers:
  set customizableViewControllers(objc.NSArray? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setCustomizableViewControllers_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setDelegate:
  set delegate(UITabBarControllerDelegate? value) {
    objc.checkOsVersionInternal('UITabBarController.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSelectedIndex:
  set selectedIndex(int value) {
    objc.checkOsVersionInternal('UITabBarController.setSelectedIndex:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_setSelectedIndex_, value);
  }

  /// setSelectedViewController:
  set selectedViewController(UIViewController? value) {
    objc.checkOsVersionInternal('UITabBarController.setSelectedViewController:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setSelectedViewController_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setViewControllers:
  set viewControllers(objc.NSArray? value) {
    objc.checkOsVersionInternal('UITabBarController.setViewControllers:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setViewControllers_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setViewControllers:animated:
  void setViewControllers(objc.NSArray? viewControllers, {required bool animated}) {
    objc.checkOsVersionInternal('UITabBarController.setViewControllers:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_setViewControllers_animated_,
      viewControllers?.ref.pointer ?? ffi.nullptr,
      animated,
    );
  }

  /// tabBar
  UITabBar get tabBar {
    objc.checkOsVersionInternal('UITabBarController.tabBar', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tabBar);
    return UITabBar.castFromPointer($ret, retain: true, release: true);
  }

  /// tabBar:didBeginCustomizingItems:
  void tabBar$1(UITabBar tabBar, {required objc.NSArray didBeginCustomizingItems}) {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_tabBar_didBeginCustomizingItems_)) {
      throw objc.UnimplementedOptionalMethodException('UITabBarController', 'tabBar:didBeginCustomizingItems:');
    }
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_tabBar_didBeginCustomizingItems_,
      tabBar.ref.pointer,
      didBeginCustomizingItems.ref.pointer,
    );
  }

  /// tabBar:didEndCustomizingItems:changed:
  void tabBar$2(UITabBar tabBar, {required objc.NSArray didEndCustomizingItems, required bool changed}) {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_tabBar_didEndCustomizingItems_changed_)) {
      throw objc.UnimplementedOptionalMethodException('UITabBarController', 'tabBar:didEndCustomizingItems:changed:');
    }
    _objc_msgSend_1lhy15d(
      this.ref.pointer,
      _sel_tabBar_didEndCustomizingItems_changed_,
      tabBar.ref.pointer,
      didEndCustomizingItems.ref.pointer,
      changed,
    );
  }

  /// tabBar:didSelectItem:
  void tabBar$3(UITabBar tabBar, {required UITabBarItem didSelectItem}) {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_tabBar_didSelectItem_)) {
      throw objc.UnimplementedOptionalMethodException('UITabBarController', 'tabBar:didSelectItem:');
    }
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_tabBar_didSelectItem_, tabBar.ref.pointer, didSelectItem.ref.pointer);
  }

  /// tabBar:willBeginCustomizingItems:
  void tabBar$4(UITabBar tabBar, {required objc.NSArray willBeginCustomizingItems}) {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_tabBar_willBeginCustomizingItems_)) {
      throw objc.UnimplementedOptionalMethodException('UITabBarController', 'tabBar:willBeginCustomizingItems:');
    }
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_tabBar_willBeginCustomizingItems_,
      tabBar.ref.pointer,
      willBeginCustomizingItems.ref.pointer,
    );
  }

  /// tabBar:willEndCustomizingItems:changed:
  void tabBar$5(UITabBar tabBar, {required objc.NSArray willEndCustomizingItems, required bool changed}) {
    if (!objc.respondsToSelector(this.ref.pointer, _sel_tabBar_willEndCustomizingItems_changed_)) {
      throw objc.UnimplementedOptionalMethodException('UITabBarController', 'tabBar:willEndCustomizingItems:changed:');
    }
    _objc_msgSend_1lhy15d(
      this.ref.pointer,
      _sel_tabBar_willEndCustomizingItems_changed_,
      tabBar.ref.pointer,
      willEndCustomizingItems.ref.pointer,
      changed,
    );
  }

  /// viewControllers
  objc.NSArray? get viewControllers {
    objc.checkOsVersionInternal('UITabBarController.viewControllers', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewControllers);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_tabBarController = objc.registerName("tabBarController");
late final _sel_tabBarObservedScrollView = objc.registerName("tabBarObservedScrollView");
late final _sel_setTabBarObservedScrollView_ = objc.registerName("setTabBarObservedScrollView:");

/// UITabBarControllerItem
extension UITabBarControllerItem on UIViewController {
  /// setTabBarItem:
  set tabBarItem(UITabBarItem value) {
    objc.checkOsVersionInternal('UIViewController.setTabBarItem:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTabBarItem_, value.ref.pointer);
  }

  /// setTabBarObservedScrollView:
  set tabBarObservedScrollView(UIScrollView? value) {
    objc.checkOsVersionInternal('UIViewController.setTabBarObservedScrollView:', iOS: (true, null));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTabBarObservedScrollView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// tabBarController
  UITabBarController? get tabBarController {
    objc.checkOsVersionInternal('UIViewController.tabBarController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tabBarController);
    return $ret.address == 0 ? null : UITabBarController.castFromPointer($ret, retain: true, release: true);
  }

  /// tabBarItem
  UITabBarItem get tabBarItem {
    objc.checkOsVersionInternal('UIViewController.tabBarItem', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tabBarItem);
    return UITabBarItem.castFromPointer($ret, retain: true, release: true);
  }

  /// tabBarObservedScrollView
  UIScrollView? get tabBarObservedScrollView {
    objc.checkOsVersionInternal('UIViewController.tabBarObservedScrollView', iOS: (true, null));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tabBarObservedScrollView);
    return $ret.address == 0 ? null : UIScrollView.castFromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UITraitEnvironment is a stub. To generate bindings for this class, include
/// UITraitEnvironment in your config's objc-protocols list.
///
/// ! Trait environments expose a trait collection that describes their environment.
interface class UITraitEnvironment extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITraitEnvironment._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITraitEnvironment] that points to the same underlying object as [other].
  UITraitEnvironment.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITraitEnvironment] that wraps the given raw object pointer.
  UITraitEnvironment.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// UIViewController
class UIViewController extends UIResponder
    implements objc.NSCoding, UIAppearanceContainer, UITraitEnvironment, UIContentContainer, UIFocusEnvironment {
  UIViewController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIViewController] that points to the same underlying object as [other].
  UIViewController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIViewController] that wraps the given raw object pointer.
  UIViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIViewController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIViewController);
  }

  /// new
  static UIViewController new$() {
    final _ret = _objc_msgSend_151sglz(_class_UIViewController, _sel_new);
    return UIViewController.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of UIViewController constructed with the default `new` method.
  factory UIViewController() => new$();
}

extension UIViewController$Methods on UIViewController {
  /// allowedChildViewControllersForUnwindingFromSource:
  objc.NSArray allowedChildViewControllersForUnwindingFromSource(UIStoryboardUnwindSegueSource source) {
    objc.checkOsVersionInternal(
      'UIViewController.allowedChildViewControllersForUnwindingFromSource:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_allowedChildViewControllersForUnwindingFromSource_,
      source.ref.pointer,
    );
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// automaticallyAdjustsScrollViewInsets
  bool get automaticallyAdjustsScrollViewInsets {
    objc.checkOsVersionInternal('UIViewController.automaticallyAdjustsScrollViewInsets', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_automaticallyAdjustsScrollViewInsets);
  }

  /// canPerformUnwindSegueAction:fromViewController:sender:
  bool canPerformUnwindSegueAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    objc.ObjCObjectBase? sender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.canPerformUnwindSegueAction:fromViewController:sender:',
      iOS: (false, (13, 0, 0)),
    );
    return _objc_msgSend_iv7uhk(
      this.ref.pointer,
      _sel_canPerformUnwindSegueAction_fromViewController_sender_,
      action,
      fromViewController.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// canPerformUnwindSegueAction:fromViewController:withSender:
  bool canPerformUnwindSegueAction$1(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    required objc.ObjCObjectBase withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.canPerformUnwindSegueAction:fromViewController:withSender:',
      iOS: (false, (6, 0, 0)),
    );
    return _objc_msgSend_iv7uhk(
      this.ref.pointer,
      _sel_canPerformUnwindSegueAction_fromViewController_withSender_,
      action,
      fromViewController.ref.pointer,
      withSender.ref.pointer,
    );
  }

  /// childViewControllerContainingSegueSource:
  UIViewController? childViewControllerContainingSegueSource(UIStoryboardUnwindSegueSource source) {
    objc.checkOsVersionInternal('UIViewController.childViewControllerContainingSegueSource:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_childViewControllerContainingSegueSource_,
      source.ref.pointer,
    );
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// Pass only a single edge (e.g., NSDirectionalRectEdgeTop) in the `edge` parameter. Raises an exception when passed an aggregate edge (e.g., NSDirectionalRectEdgeAll)
  UIScrollView? contentScrollViewForEdge(int edge) {
    objc.checkOsVersionInternal('UIViewController.contentScrollViewForEdge:', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_kh1gvt(this.ref.pointer, _sel_contentScrollViewForEdge_, edge);
    return $ret.address == 0 ? null : UIScrollView.castFromPointer($ret, retain: true, release: true);
  }

  /// definesPresentationContext
  bool get definesPresentationContext {
    objc.checkOsVersionInternal('UIViewController.definesPresentationContext', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_definesPresentationContext);
  }

  /// didReceiveMemoryWarning
  void didReceiveMemoryWarning() {
    objc.checkOsVersionInternal('UIViewController.didReceiveMemoryWarning', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didReceiveMemoryWarning);
  }

  /// Called when the screens focused item has been updated to a new item. Use the animation coordinator to schedule focus-related animations in response to the update.
  void didUpdateFocusInContext(
    UIFocusUpdateContext context, {
    required UIFocusAnimationCoordinator withAnimationCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.didUpdateFocusInContext:withAnimationCoordinator:',
      iOS: (false, (9, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      context.ref.pointer,
      withAnimationCoordinator.ref.pointer,
    );
  }

  /// disablesAutomaticKeyboardDismissal
  bool get disablesAutomaticKeyboardDismissal {
    objc.checkOsVersionInternal('UIViewController.disablesAutomaticKeyboardDismissal', iOS: (false, (4, 3, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_disablesAutomaticKeyboardDismissal);
  }

  /// dismissModalViewControllerAnimated:
  void dismissModalViewControllerAnimated(bool animated) {
    objc.checkOsVersionInternal('UIViewController.dismissModalViewControllerAnimated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_dismissModalViewControllerAnimated_, animated);
  }

  /// dismissViewControllerAnimated:completion:
  void dismissViewControllerAnimated(bool flag, {objc.ObjCBlock<ffi.Void Function()>? completion}) {
    objc.checkOsVersionInternal('UIViewController.dismissViewControllerAnimated:completion:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1ocak7a(
      this.ref.pointer,
      _sel_dismissViewControllerAnimated_completion_,
      flag,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// edgesForExtendedLayout
  int get edgesForExtendedLayout {
    objc.checkOsVersionInternal('UIViewController.edgesForExtendedLayout', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_qrqu1s(this.ref.pointer, _sel_edgesForExtendedLayout);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// extendedLayoutIncludesOpaqueBars
  bool get extendedLayoutIncludesOpaqueBars {
    objc.checkOsVersionInternal('UIViewController.extendedLayoutIncludesOpaqueBars', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_extendedLayoutIncludesOpaqueBars);
  }

  /// The identifier of the focus group that this view controller belongs to. If this is nil, the view controller inherits the focus group of its parent focus environment.
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal('UIViewController.focusGroupIdentifier', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusGroupIdentifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// The container of any child focus items in this focus environment, or nil if no container exists.
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal('UIViewController.focusItemContainer', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusItemContainer);
    return $ret.address == 0 ? null : UIFocusItemContainer.castFromPointer($ret, retain: true, release: true);
  }

  /// initWithCoder:
  UIViewController? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithNibName:bundle:
  UIViewController initWithNibName(objc.NSString? nibNameOrNil, {objc.NSBundle? bundle}) {
    objc.checkOsVersionInternal('UIViewController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UIViewController.castFromPointer($ret, retain: false, release: true);
  }

  /// isBeingDismissed
  bool get isBeingDismissed {
    objc.checkOsVersionInternal('UIViewController.isBeingDismissed', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isBeingDismissed);
  }

  /// isBeingPresented
  bool get isBeingPresented {
    objc.checkOsVersionInternal('UIViewController.isBeingPresented', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isBeingPresented);
  }

  /// isMovingFromParentViewController
  bool get isMovingFromParentViewController {
    objc.checkOsVersionInternal('UIViewController.isMovingFromParentViewController', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMovingFromParentViewController);
  }

  /// isMovingToParentViewController
  bool get isMovingToParentViewController {
    objc.checkOsVersionInternal('UIViewController.isMovingToParentViewController', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isMovingToParentViewController);
  }

  /// isViewLoaded
  bool get isViewLoaded {
    objc.checkOsVersionInternal('UIViewController.isViewLoaded', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isViewLoaded);
  }

  /// loadView
  void loadView() {
    objc.checkOsVersionInternal('UIViewController.loadView', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_loadView);
  }

  /// loadViewIfNeeded
  void loadViewIfNeeded() {
    objc.checkOsVersionInternal('UIViewController.loadViewIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_loadViewIfNeeded);
  }

  /// modalPresentationCapturesStatusBarAppearance
  bool get modalPresentationCapturesStatusBarAppearance {
    objc.checkOsVersionInternal(
      'UIViewController.modalPresentationCapturesStatusBarAppearance',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_91o635(this.ref.pointer, _sel_modalPresentationCapturesStatusBarAppearance);
  }

  /// modalPresentationStyle
  UIModalPresentationStyle get modalPresentationStyle {
    objc.checkOsVersionInternal('UIViewController.modalPresentationStyle', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_1jdzuw5(this.ref.pointer, _sel_modalPresentationStyle);
    return UIModalPresentationStyle.fromValue($ret);
  }

  /// modalTransitionStyle
  UIModalTransitionStyle get modalTransitionStyle {
    objc.checkOsVersionInternal('UIViewController.modalTransitionStyle', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_17t73u4(this.ref.pointer, _sel_modalTransitionStyle);
    return UIModalTransitionStyle.fromValue($ret);
  }

  /// modalViewController
  UIViewController? get modalViewController {
    objc.checkOsVersionInternal('UIViewController.modalViewController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_modalViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// nibBundle
  objc.NSBundle? get nibBundle {
    objc.checkOsVersionInternal('UIViewController.nibBundle', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nibBundle);
    return $ret.address == 0 ? null : objc.NSBundle.castFromPointer($ret, retain: true, release: true);
  }

  /// nibName
  objc.NSString? get nibName {
    objc.checkOsVersionInternal('UIViewController.nibName', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nibName);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.overrideUserInterfaceStyle', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_overrideUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue($ret);
  }

  /// The parent focus environment of this environment, or nil if no parent exists.
  /// NOTE: If you implement this method, you must return a non-nil value for parent focus environment, otherwise your focus environment will not participate in focus interactions.
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal('UIViewController.parentFocusEnvironment', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentFocusEnvironment);
    return $ret.address == 0 ? null : UIFocusEnvironment.castFromPointer($ret, retain: true, release: true);
  }

  /// parentViewController
  UIViewController? get parentViewController {
    objc.checkOsVersionInternal('UIViewController.parentViewController', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// performSegueWithIdentifier:sender:
  void performSegueWithIdentifier(objc.NSString identifier, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.performSegueWithIdentifier:sender:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_performSegueWithIdentifier_sender_,
      identifier.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// preferredContentSize
  objc.CGSize get preferredContentSize {
    objc.checkOsVersionInternal('UIViewController.preferredContentSize', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret($ptr, this.ref.pointer, _sel_preferredContentSize)
        : $ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_preferredContentSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// preferredContentSizeDidChangeForChildContentContainer:
  void preferredContentSizeDidChangeForChildContentContainer(UIContentContainer container) {
    objc.checkOsVersionInternal(
      'UIViewController.preferredContentSizeDidChangeForChildContentContainer:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_preferredContentSizeDidChangeForChildContentContainer_,
      container.ref.pointer,
    );
  }

  /// The preferred focus environments define where to search for the default focused item in an environment, such as when focus updates programmatically.
  /// Starting from the target environment, each preferred focus environment is recursively searched in the order of the array until an eligible, focusable item is found.
  /// Preferred focus environments can include focusable and non-focusable items, in addition to non-item environments. Returning an empty array is equivalent to returning an array containing only 'self'.
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal('UIViewController.preferredFocusEnvironments', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal('UIViewController.preferredFocusedView', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException('UIViewController', 'preferredFocusedView');
    }
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusedView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredStatusBarStyle
  UIStatusBarStyle get preferredStatusBarStyle {
    objc.checkOsVersionInternal('UIViewController.preferredStatusBarStyle', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_preferredStatusBarStyle);
    return UIStatusBarStyle.fromValue($ret);
  }

  /// preferredStatusBarUpdateAnimation
  UIStatusBarAnimation get preferredStatusBarUpdateAnimation {
    objc.checkOsVersionInternal('UIViewController.preferredStatusBarUpdateAnimation', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_14wdvus(this.ref.pointer, _sel_preferredStatusBarUpdateAnimation);
    return UIStatusBarAnimation.fromValue($ret);
  }

  /// preferredUserInterfaceStyle
  UIUserInterfaceStyle get preferredUserInterfaceStyle {
    objc.checkOsVersionInternal('UIViewController.preferredUserInterfaceStyle', iOS: (true, null));
    final $ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_preferredUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue($ret);
  }

  /// prefersStatusBarHidden
  bool get prefersStatusBarHidden {
    objc.checkOsVersionInternal('UIViewController.prefersStatusBarHidden', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_prefersStatusBarHidden);
  }

  /// prepareForSegue:sender:
  void prepareForSegue(UIStoryboardSegue segue, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.prepareForSegue:sender:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_prepareForSegue_sender_,
      segue.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// presentModalViewController:animated:
  void presentModalViewController(UIViewController modalViewController, {required bool animated}) {
    objc.checkOsVersionInternal('UIViewController.presentModalViewController:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_6p7ndb(
      this.ref.pointer,
      _sel_presentModalViewController_animated_,
      modalViewController.ref.pointer,
      animated,
    );
  }

  /// presentViewController:animated:completion:
  void presentViewController(
    UIViewController viewControllerToPresent, {
    required bool animated,
    objc.ObjCBlock<ffi.Void Function()>? completion,
  }) {
    objc.checkOsVersionInternal('UIViewController.presentViewController:animated:completion:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_na2nx0(
      this.ref.pointer,
      _sel_presentViewController_animated_completion_,
      viewControllerToPresent.ref.pointer,
      animated,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// presentedViewController
  UIViewController? get presentedViewController {
    objc.checkOsVersionInternal('UIViewController.presentedViewController', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentedViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// presentingViewController
  UIViewController? get presentingViewController {
    objc.checkOsVersionInternal('UIViewController.presentingViewController', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_presentingViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// previewActionItems
  objc.NSArray get previewActionItems {
    objc.checkOsVersionInternal('UIViewController.previewActionItems', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_previewActionItems);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// providesPresentationContextTransitionStyle
  bool get providesPresentationContextTransitionStyle {
    objc.checkOsVersionInternal('UIViewController.providesPresentationContextTransitionStyle', iOS: (false, (5, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_providesPresentationContextTransitionStyle);
  }

  /// restoresFocusAfterTransition
  bool get restoresFocusAfterTransition {
    objc.checkOsVersionInternal('UIViewController.restoresFocusAfterTransition', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_restoresFocusAfterTransition);
  }

  /// segueForUnwindingToViewController:fromViewController:identifier:
  UIStoryboardSegue? segueForUnwindingToViewController(
    UIViewController toViewController, {
    required UIViewController fromViewController,
    objc.NSString? identifier,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.segueForUnwindingToViewController:fromViewController:identifier:',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_11spmsz(
      this.ref.pointer,
      _sel_segueForUnwindingToViewController_fromViewController_identifier_,
      toViewController.ref.pointer,
      fromViewController.ref.pointer,
      identifier?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : UIStoryboardSegue.castFromPointer($ret, retain: true, release: true);
  }

  /// setAutomaticallyAdjustsScrollViewInsets:
  set automaticallyAdjustsScrollViewInsets(bool value) {
    objc.checkOsVersionInternal('UIViewController.setAutomaticallyAdjustsScrollViewInsets:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutomaticallyAdjustsScrollViewInsets_, value);
  }

  /// Aggregate values (e.g., NSDirectionalRectEdgeAll) are accepted in the `edge` parameter; NSDirectionalRectEdgeLeading and Trailing are ignored on iOS 15.0
  void setContentScrollView(UIScrollView? scrollView, {required int forEdge}) {
    objc.checkOsVersionInternal('UIViewController.setContentScrollView:forEdge:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_13y7vr7(
      this.ref.pointer,
      _sel_setContentScrollView_forEdge_,
      scrollView?.ref.pointer ?? ffi.nullptr,
      forEdge,
    );
  }

  /// setDefinesPresentationContext:
  set definesPresentationContext(bool value) {
    objc.checkOsVersionInternal('UIViewController.setDefinesPresentationContext:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDefinesPresentationContext_, value);
  }

  /// setEdgesForExtendedLayout:
  set edgesForExtendedLayout(int value) {
    objc.checkOsVersionInternal('UIViewController.setEdgesForExtendedLayout:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1xy78x6(this.ref.pointer, _sel_setEdgesForExtendedLayout_, value);
  }

  /// setExtendedLayoutIncludesOpaqueBars:
  set extendedLayoutIncludesOpaqueBars(bool value) {
    objc.checkOsVersionInternal('UIViewController.setExtendedLayoutIncludesOpaqueBars:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setExtendedLayoutIncludesOpaqueBars_, value);
  }

  /// The identifier of the focus group that this view controller belongs to. If this is nil, the view controller inherits the focus group of its parent focus environment.
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setFocusGroupIdentifier:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusGroupIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setModalPresentationCapturesStatusBarAppearance:
  set modalPresentationCapturesStatusBarAppearance(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setModalPresentationCapturesStatusBarAppearance:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setModalPresentationCapturesStatusBarAppearance_, value);
  }

  /// setModalPresentationStyle:
  set modalPresentationStyle(UIModalPresentationStyle value) {
    objc.checkOsVersionInternal('UIViewController.setModalPresentationStyle:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_19sk1nl(this.ref.pointer, _sel_setModalPresentationStyle_, value.value);
  }

  /// setModalTransitionStyle:
  set modalTransitionStyle(UIModalTransitionStyle value) {
    objc.checkOsVersionInternal('UIViewController.setModalTransitionStyle:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_gt147a(this.ref.pointer, _sel_setModalTransitionStyle_, value.value);
  }

  /// Marks this environment as needing a focus update, which if accepted will attempt to reset focus to this environment, or one of its preferred focus environments, on the next update cycle. If this environment does not currently contain the focused item, then calling this method has no effect. If a parent of this environment is also requesting focus, then this environment's request is rejected in favor of the parent's.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] requestFocusUpdateToEnvironment:self]`;
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsFocusUpdate', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// setNeedsStatusBarAppearanceUpdate
  void setNeedsStatusBarAppearanceUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsStatusBarAppearanceUpdate', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsStatusBarAppearanceUpdate);
  }

  /// setNeedsUserInterfaceAppearanceUpdate
  void setNeedsUserInterfaceAppearanceUpdate() {
    objc.checkOsVersionInternal('UIViewController.setNeedsUserInterfaceAppearanceUpdate', iOS: (true, null));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUserInterfaceAppearanceUpdate);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal('UIViewController.setOverrideUserInterfaceStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_15dz1ky(this.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value.value);
  }

  /// setPreferredContentSize:
  set preferredContentSize$1(objc.CGSize value) {
    objc.checkOsVersionInternal('UIViewController.setPreferredContentSize:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setPreferredContentSize_, value);
  }

  /// setProvidesPresentationContextTransitionStyle:
  set providesPresentationContextTransitionStyle(bool value) {
    objc.checkOsVersionInternal(
      'UIViewController.setProvidesPresentationContextTransitionStyle:',
      iOS: (false, (5, 0, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setProvidesPresentationContextTransitionStyle_, value);
  }

  /// setRestoresFocusAfterTransition:
  set restoresFocusAfterTransition(bool value) {
    objc.checkOsVersionInternal('UIViewController.setRestoresFocusAfterTransition:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setRestoresFocusAfterTransition_, value);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIViewController.setTitle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setView:
  set view(UIView value) {
    objc.checkOsVersionInternal('UIViewController.setView:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setView_, value.ref.pointer);
  }

  /// setWantsFullScreenLayout:
  set wantsFullScreenLayout(bool value) {
    objc.checkOsVersionInternal('UIViewController.setWantsFullScreenLayout:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setWantsFullScreenLayout_, value);
  }

  /// shouldPerformSegueWithIdentifier:sender:
  bool shouldPerformSegueWithIdentifier(objc.NSString identifier, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.shouldPerformSegueWithIdentifier:sender:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_shouldPerformSegueWithIdentifier_sender_,
      identifier.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Asks whether the system should allow a focus update to occur.
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIViewController.shouldUpdateFocusInContext:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_shouldUpdateFocusInContext_, context.ref.pointer);
  }

  /// showDetailViewController:sender:
  void showDetailViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.showDetailViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showDetailViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// showViewController:sender:
  void showViewController(UIViewController vc, {objc.ObjCObjectBase? sender}) {
    objc.checkOsVersionInternal('UIViewController.showViewController:sender:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_showViewController_sender_,
      vc.ref.pointer,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// sizeForChildContentContainer:withParentContainerSize:
  objc.CGSize sizeForChildContentContainer(
    UIContentContainer container, {
    required objc.CGSize withParentContainerSize,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.sizeForChildContentContainer:withParentContainerSize:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_xq5db9Stret(
            $ptr,
            this.ref.pointer,
            _sel_sizeForChildContentContainer_withParentContainerSize_,
            container.ref.pointer,
            withParentContainerSize,
          )
        : $ptr.ref = _objc_msgSend_xq5db9(
            this.ref.pointer,
            _sel_sizeForChildContentContainer_withParentContainerSize_,
            container.ref.pointer,
            withParentContainerSize,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// Specifies an identifier corresponding to a sound that should be played for a focus update.
  /// Return UIFocusSoundIdentifierNone to opt out of sounds, UIFocusSoundIdentifierDefault for the system
  /// default sounds, a previously registered identifier for a custom sound, or nil to defer the decision
  /// to the parent.
  objc.NSString? soundIdentifierForFocusUpdateInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIViewController.soundIdentifierForFocusUpdateInContext:', iOS: (true, null));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIViewController', 'soundIdentifierForFocusUpdateInContext:');
    }
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
      context.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// storyboard
  UIStoryboard? get storyboard {
    objc.checkOsVersionInternal('UIViewController.storyboard', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_storyboard);
    return $ret.address == 0 ? null : UIStoryboard.castFromPointer($ret, retain: true, release: true);
  }

  /// systemLayoutFittingSizeDidChangeForChildContentContainer:
  void systemLayoutFittingSizeDidChangeForChildContentContainer(UIContentContainer container) {
    objc.checkOsVersionInternal(
      'UIViewController.systemLayoutFittingSizeDidChangeForChildContentContainer:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_systemLayoutFittingSizeDidChangeForChildContentContainer_,
      container.ref.pointer,
    );
  }

  /// targetViewControllerForAction:sender:
  UIViewController? targetViewControllerForAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObjectBase? sender,
  }) {
    objc.checkOsVersionInternal('UIViewController.targetViewControllerForAction:sender:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_gx50so(
      this.ref.pointer,
      _sel_targetViewControllerForAction_sender_,
      action,
      sender?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIViewController.title', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIViewController.traitCollection', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer($ret, retain: true, release: true);
  }

  /// ! To be overridden as needed to provide custom behavior when the environment's traits change.
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal('UIViewController.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_traitCollectionDidChange_,
      previousTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// unwindForSegue:towardsViewController:
  void unwindForSegue(UIStoryboardSegue unwindSegue, {required UIViewController towardsViewController}) {
    objc.checkOsVersionInternal('UIViewController.unwindForSegue:towardsViewController:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_unwindForSegue_towardsViewController_,
      unwindSegue.ref.pointer,
      towardsViewController.ref.pointer,
    );
  }

  /// Forces focus to be updated immediately. If there is an environment that has requested a focus update via -setNeedsFocusUpdate, and the request was accepted, then focus will be updated to that environment or one of its preferred focus environments.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] updateFocusIfNeeded];`.
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal('UIViewController.updateFocusIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateFocusIfNeeded);
  }

  /// view
  UIView get view {
    objc.checkOsVersionInternal('UIViewController.view', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_view);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// viewControllerForUnwindSegueAction:fromViewController:withSender:
  UIViewController? viewControllerForUnwindSegueAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    required UIViewController fromViewController,
    objc.ObjCObjectBase? withSender,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.viewControllerForUnwindSegueAction:fromViewController:withSender:',
      iOS: (false, (6, 0, 0)),
    );
    final $ret = _objc_msgSend_cfx8ce(
      this.ref.pointer,
      _sel_viewControllerForUnwindSegueAction_fromViewController_withSender_,
      action,
      fromViewController.ref.pointer,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// viewDidAppear:
  void viewDidAppear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewDidAppear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewDidAppear_, animated);
  }

  /// viewDidDisappear:
  void viewDidDisappear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewDidDisappear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewDidDisappear_, animated);
  }

  /// viewDidLayoutSubviews
  void viewDidLayoutSubviews() {
    objc.checkOsVersionInternal('UIViewController.viewDidLayoutSubviews', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidLayoutSubviews);
  }

  /// viewDidLoad
  void viewDidLoad() {
    objc.checkOsVersionInternal('UIViewController.viewDidLoad', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidLoad);
  }

  /// viewDidUnload
  void viewDidUnload() {
    objc.checkOsVersionInternal('UIViewController.viewDidUnload', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewDidUnload);
  }

  /// viewIfLoaded
  UIView? get viewIfLoaded {
    objc.checkOsVersionInternal('UIViewController.viewIfLoaded', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewIfLoaded);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// viewWillAppear:
  void viewWillAppear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewWillAppear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewWillAppear_, animated);
  }

  /// viewWillDisappear:
  void viewWillDisappear(bool animated) {
    objc.checkOsVersionInternal('UIViewController.viewWillDisappear:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_viewWillDisappear_, animated);
  }

  /// viewWillLayoutSubviews
  void viewWillLayoutSubviews() {
    objc.checkOsVersionInternal('UIViewController.viewWillLayoutSubviews', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewWillLayoutSubviews);
  }

  /// viewWillTransitionToSize:withTransitionCoordinator:
  void viewWillTransitionToSize(
    objc.CGSize size, {
    required UIViewControllerTransitionCoordinator withTransitionCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.viewWillTransitionToSize:withTransitionCoordinator:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_11tcc61(
      this.ref.pointer,
      _sel_viewWillTransitionToSize_withTransitionCoordinator_,
      size,
      withTransitionCoordinator.ref.pointer,
    );
  }

  /// viewWillUnload
  void viewWillUnload() {
    objc.checkOsVersionInternal('UIViewController.viewWillUnload', iOS: (false, (5, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_viewWillUnload);
  }

  /// wantsFullScreenLayout
  bool get wantsFullScreenLayout {
    objc.checkOsVersionInternal('UIViewController.wantsFullScreenLayout', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_wantsFullScreenLayout);
  }

  /// willTransitionToTraitCollection:withTransitionCoordinator:
  void willTransitionToTraitCollection(
    UITraitCollection newCollection, {
    required UIViewControllerTransitionCoordinator withTransitionCoordinator,
  }) {
    objc.checkOsVersionInternal(
      'UIViewController.willTransitionToTraitCollection:withTransitionCoordinator:',
      iOS: (false, (8, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_willTransitionToTraitCollection_withTransitionCoordinator_,
      newCollection.ref.pointer,
      withTransitionCoordinator.ref.pointer,
    );
  }
}

late final _sel_rootViewController = objc.registerName("rootViewController");
late final _sel_setRootViewController_ = objc.registerName("setRootViewController:");
late final _sel_sendEvent_ = objc.registerName("sendEvent:");
late final _sel_convertPoint_toWindow_ = objc.registerName("convertPoint:toWindow:");
late final _sel_convertPoint_fromWindow_ = objc.registerName("convertPoint:fromWindow:");
late final _sel_convertRect_toWindow_ = objc.registerName("convertRect:toWindow:");
late final _sel_convertRect_fromWindow_ = objc.registerName("convertRect:fromWindow:");

/// UIWindow
class UIWindow extends UIView {
  UIWindow._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UIWindow] that points to the same underlying object as [other].
  UIWindow.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIWindow] that wraps the given raw object pointer.
  UIWindow.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIWindow].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIWindow);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIWindow.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIWindow, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIWindow.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UIWindow,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIWindow.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UIWindow,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }
}

extension UIWindow$Methods on UIWindow {
  /// becomeKeyWindow
  void becomeKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.becomeKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_becomeKeyWindow);
  }

  /// canBecomeKeyWindow
  bool get canBecomeKeyWindow {
    objc.checkOsVersionInternal('UIWindow.canBecomeKeyWindow', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeKeyWindow);
  }

  /// canResizeToFitContent
  bool get canResizeToFitContent {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canResizeToFitContent);
  }

  /// convertPoint:fromWindow:
  objc.CGPoint convertPoint$2(objc.CGPoint point, {UIWindow? fromWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertPoint:fromWindow:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_fromWindow_,
            point,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromWindow_,
            point,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toWindow:
  objc.CGPoint convertPoint$3(objc.CGPoint point, {UIWindow? toWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertPoint:toWindow:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_toWindow_,
            point,
            toWindow?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toWindow_,
            point,
            toWindow?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromWindow:
  objc.CGRect convertRect$2(objc.CGRect rect, {UIWindow? fromWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertRect:fromWindow:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_fromWindow_,
            rect,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromWindow_,
            rect,
            fromWindow?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toWindow:
  objc.CGRect convertRect$3(objc.CGRect rect, {UIWindow? toWindow}) {
    objc.checkOsVersionInternal('UIWindow.convertRect:toWindow:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_toWindow_,
            rect,
            toWindow?.ref.pointer ?? ffi.nullptr,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toWindow_,
            rect,
            toWindow?.ref.pointer ?? ffi.nullptr,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// initWithCoder:
  UIWindow? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIWindow.initWithCoder:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIWindow.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UIWindow initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIWindow.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIWindow.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithWindowScene:
  UIWindow initWithWindowScene(UIWindowScene windowScene) {
    objc.checkOsVersionInternal('UIWindow.initWithWindowScene:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.retainAndReturnPointer(),
      _sel_initWithWindowScene_,
      windowScene.ref.pointer,
    );
    return UIWindow.castFromPointer($ret, retain: false, release: true);
  }

  /// isKeyWindow
  bool get isKeyWindow {
    objc.checkOsVersionInternal('UIWindow.isKeyWindow', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isKeyWindow);
  }

  /// makeKeyAndVisible
  void makeKeyAndVisible() {
    objc.checkOsVersionInternal('UIWindow.makeKeyAndVisible', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_makeKeyAndVisible);
  }

  /// makeKeyWindow
  void makeKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.makeKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_makeKeyWindow);
  }

  /// resignKeyWindow
  void resignKeyWindow() {
    objc.checkOsVersionInternal('UIWindow.resignKeyWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_resignKeyWindow);
  }

  /// rootViewController
  UIViewController? get rootViewController {
    objc.checkOsVersionInternal('UIWindow.rootViewController', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rootViewController);
    return $ret.address == 0 ? null : UIViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// screen
  UIScreen get screen {
    objc.checkOsVersionInternal('UIWindow.screen', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_screen);
    return UIScreen.castFromPointer($ret, retain: true, release: true);
  }

  /// sendEvent:
  void sendEvent(UIEvent event) {
    objc.checkOsVersionInternal('UIWindow.sendEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// setCanResizeToFitContent:
  set canResizeToFitContent(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setCanResizeToFitContent_, value);
  }

  /// setRootViewController:
  set rootViewController(UIViewController? value) {
    objc.checkOsVersionInternal('UIWindow.setRootViewController:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRootViewController_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setScreen:
  set screen(UIScreen value) {
    objc.checkOsVersionInternal('UIWindow.setScreen:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScreen_, value.ref.pointer);
  }

  /// setWindowLevel:
  set windowLevel(double value) {
    objc.checkOsVersionInternal('UIWindow.setWindowLevel:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setWindowLevel_, value);
  }

  /// setWindowScene:
  set windowScene(UIWindowScene? value) {
    objc.checkOsVersionInternal('UIWindow.setWindowScene:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setWindowScene_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// windowLevel
  double get windowLevel {
    objc.checkOsVersionInternal('UIWindow.windowLevel', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_windowLevel)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_windowLevel);
  }

  /// windowScene
  UIWindowScene? get windowScene {
    objc.checkOsVersionInternal('UIWindow.windowScene', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windowScene);
    return $ret.address == 0 ? null : UIWindowScene.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_window = objc.registerName("window");
late final _sel_removeFromSuperview = objc.registerName("removeFromSuperview");
late final _sel_insertSubview_atIndex_ = objc.registerName("insertSubview:atIndex:");
final _objc_msgSend_1nvl641 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_exchangeSubviewAtIndex_withSubviewAtIndex_ = objc.registerName(
  "exchangeSubviewAtIndex:withSubviewAtIndex:",
);
final _objc_msgSend_1w5k0al = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_addSubview_ = objc.registerName("addSubview:");
late final _sel_insertSubview_belowSubview_ = objc.registerName("insertSubview:belowSubview:");
late final _sel_insertSubview_aboveSubview_ = objc.registerName("insertSubview:aboveSubview:");
late final _sel_bringSubviewToFront_ = objc.registerName("bringSubviewToFront:");
late final _sel_sendSubviewToBack_ = objc.registerName("sendSubviewToBack:");
late final _sel_didAddSubview_ = objc.registerName("didAddSubview:");
late final _sel_willRemoveSubview_ = objc.registerName("willRemoveSubview:");
late final _sel_willMoveToSuperview_ = objc.registerName("willMoveToSuperview:");
late final _sel_didMoveToSuperview = objc.registerName("didMoveToSuperview");
late final _sel_willMoveToWindow_ = objc.registerName("willMoveToWindow:");
late final _sel_didMoveToWindow = objc.registerName("didMoveToWindow");
late final _sel_isDescendantOfView_ = objc.registerName("isDescendantOfView:");
late final _sel_viewWithTag_ = objc.registerName("viewWithTag:");
final _objc_msgSend_qugqlf = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_setNeedsLayout = objc.registerName("setNeedsLayout");
late final _sel_layoutIfNeeded = objc.registerName("layoutIfNeeded");
late final _sel_layoutSubviews = objc.registerName("layoutSubviews");
late final _sel_layoutMargins = objc.registerName("layoutMargins");
late final _sel_setLayoutMargins_ = objc.registerName("setLayoutMargins:");
late final _sel_directionalLayoutMargins = objc.registerName("directionalLayoutMargins");
late final _sel_setDirectionalLayoutMargins_ = objc.registerName("setDirectionalLayoutMargins:");
final _objc_msgSend_s0isf8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, NSDirectionalEdgeInsets)>();
late final _sel_preservesSuperviewLayoutMargins = objc.registerName("preservesSuperviewLayoutMargins");
late final _sel_setPreservesSuperviewLayoutMargins_ = objc.registerName("setPreservesSuperviewLayoutMargins:");
late final _sel_insetsLayoutMarginsFromSafeArea = objc.registerName("insetsLayoutMarginsFromSafeArea");
late final _sel_setInsetsLayoutMarginsFromSafeArea_ = objc.registerName("setInsetsLayoutMarginsFromSafeArea:");
late final _sel_layoutMarginsDidChange = objc.registerName("layoutMarginsDidChange");
late final _sel_safeAreaInsets = objc.registerName("safeAreaInsets");
late final _sel_safeAreaInsetsDidChange = objc.registerName("safeAreaInsetsDidChange");
late final _sel_layoutMarginsGuide = objc.registerName("layoutMarginsGuide");
late final _sel_readableContentGuide = objc.registerName("readableContentGuide");
late final _sel_safeAreaLayoutGuide = objc.registerName("safeAreaLayoutGuide");

/// WARNING: UIKeyboardLayoutGuide is a stub. To generate bindings for this class, include
/// UIKeyboardLayoutGuide in your config's objc-interfaces list.
///
/// UIKeyboardLayoutGuide
class UIKeyboardLayoutGuide extends objc.ObjCObjectBase {
  UIKeyboardLayoutGuide._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIKeyboardLayoutGuide] that points to the same underlying object as [other].
  UIKeyboardLayoutGuide.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyboardLayoutGuide] that wraps the given raw object pointer.
  UIKeyboardLayoutGuide.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_keyboardLayoutGuide = objc.registerName("keyboardLayoutGuide");

/// UIViewHierarchy
extension UIViewHierarchy on UIView {
  /// addSubview:
  void addSubview(UIView view) {
    objc.checkOsVersionInternal('UIView.addSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addSubview_, view.ref.pointer);
  }

  /// bringSubviewToFront:
  void bringSubviewToFront(UIView view) {
    objc.checkOsVersionInternal('UIView.bringSubviewToFront:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_bringSubviewToFront_, view.ref.pointer);
  }

  /// didAddSubview:
  void didAddSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.didAddSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didAddSubview_, subview.ref.pointer);
  }

  /// didMoveToSuperview
  void didMoveToSuperview() {
    objc.checkOsVersionInternal('UIView.didMoveToSuperview', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToSuperview);
  }

  /// didMoveToWindow
  void didMoveToWindow() {
    objc.checkOsVersionInternal('UIView.didMoveToWindow', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_didMoveToWindow);
  }

  /// directionalLayoutMargins
  NSDirectionalEdgeInsets get directionalLayoutMargins {
    objc.checkOsVersionInternal('UIView.directionalLayoutMargins', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<NSDirectionalEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_12yjd2mStret($ptr, this.ref.pointer, _sel_directionalLayoutMargins)
        : $ptr.ref = _objc_msgSend_12yjd2m(this.ref.pointer, _sel_directionalLayoutMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<NSDirectionalEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<NSDirectionalEdgeInsets>($finalizable);
  }

  /// exchangeSubviewAtIndex:withSubviewAtIndex:
  void exchangeSubviewAtIndex(int index1, {required int withSubviewAtIndex}) {
    objc.checkOsVersionInternal('UIView.exchangeSubviewAtIndex:withSubviewAtIndex:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1w5k0al(
      this.ref.pointer,
      _sel_exchangeSubviewAtIndex_withSubviewAtIndex_,
      index1,
      withSubviewAtIndex,
    );
  }

  /// insertSubview:aboveSubview:
  void insertSubview(UIView view, {required UIView aboveSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:aboveSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_insertSubview_aboveSubview_,
      view.ref.pointer,
      aboveSubview.ref.pointer,
    );
  }

  /// insertSubview:atIndex:
  void insertSubview$1(UIView view, {required int atIndex}) {
    objc.checkOsVersionInternal('UIView.insertSubview:atIndex:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1nvl641(this.ref.pointer, _sel_insertSubview_atIndex_, view.ref.pointer, atIndex);
  }

  /// insertSubview:belowSubview:
  void insertSubview$2(UIView view, {required UIView belowSubview}) {
    objc.checkOsVersionInternal('UIView.insertSubview:belowSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_insertSubview_belowSubview_,
      view.ref.pointer,
      belowSubview.ref.pointer,
    );
  }

  /// insetsLayoutMarginsFromSafeArea
  bool get insetsLayoutMarginsFromSafeArea {
    objc.checkOsVersionInternal('UIView.insetsLayoutMarginsFromSafeArea', iOS: (false, (11, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_insetsLayoutMarginsFromSafeArea);
  }

  /// isDescendantOfView:
  bool isDescendantOfView(UIView view) {
    objc.checkOsVersionInternal('UIView.isDescendantOfView:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_isDescendantOfView_, view.ref.pointer);
  }

  /// Follows the keyboard when on screen and docked. When the keyboard is offscreen or undocked, keyboardLayoutGuide.topAnchor matches the view's safeAreaLayoutGuide.bottomAnchor.
  UIKeyboardLayoutGuide get keyboardLayoutGuide {
    objc.checkOsVersionInternal('UIView.keyboardLayoutGuide', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyboardLayoutGuide);
    return UIKeyboardLayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// layoutIfNeeded
  void layoutIfNeeded() {
    objc.checkOsVersionInternal('UIView.layoutIfNeeded', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutIfNeeded);
  }

  /// layoutMargins
  UIEdgeInsets get layoutMargins {
    objc.checkOsVersionInternal('UIView.layoutMargins', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_layoutMargins)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_layoutMargins);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// layoutMarginsDidChange
  void layoutMarginsDidChange() {
    objc.checkOsVersionInternal('UIView.layoutMarginsDidChange', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutMarginsDidChange);
  }

  /// layoutMarginsGuide
  UILayoutGuide get layoutMarginsGuide {
    objc.checkOsVersionInternal('UIView.layoutMarginsGuide', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutMarginsGuide);
    return UILayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// layoutSubviews
  void layoutSubviews() {
    objc.checkOsVersionInternal('UIView.layoutSubviews', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_layoutSubviews);
  }

  /// preservesSuperviewLayoutMargins
  bool get preservesSuperviewLayoutMargins {
    objc.checkOsVersionInternal('UIView.preservesSuperviewLayoutMargins', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_preservesSuperviewLayoutMargins);
  }

  /// This content guide provides a layout area that you can use to place text and related content whose width should generally be constrained to a size that is easy for the user to read. This guide provides a centered region that you can place content within to get this behavior for this view.
  UILayoutGuide get readableContentGuide {
    objc.checkOsVersionInternal('UIView.readableContentGuide', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_readableContentGuide);
    return UILayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// removeFromSuperview
  void removeFromSuperview() {
    objc.checkOsVersionInternal('UIView.removeFromSuperview', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeFromSuperview);
  }

  /// safeAreaInsets
  UIEdgeInsets get safeAreaInsets {
    objc.checkOsVersionInternal('UIView.safeAreaInsets', iOS: (false, (11, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_safeAreaInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_safeAreaInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// safeAreaInsetsDidChange
  void safeAreaInsetsDidChange() {
    objc.checkOsVersionInternal('UIView.safeAreaInsetsDidChange', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_safeAreaInsetsDidChange);
  }

  /// safeAreaLayoutGuide
  UILayoutGuide get safeAreaLayoutGuide {
    objc.checkOsVersionInternal('UIView.safeAreaLayoutGuide', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_safeAreaLayoutGuide);
    return UILayoutGuide.castFromPointer($ret, retain: true, release: true);
  }

  /// sendSubviewToBack:
  void sendSubviewToBack(UIView view) {
    objc.checkOsVersionInternal('UIView.sendSubviewToBack:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendSubviewToBack_, view.ref.pointer);
  }

  /// setDirectionalLayoutMargins:
  set directionalLayoutMargins(NSDirectionalEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setDirectionalLayoutMargins:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_s0isf8(this.ref.pointer, _sel_setDirectionalLayoutMargins_, value);
  }

  /// setInsetsLayoutMarginsFromSafeArea:
  set insetsLayoutMarginsFromSafeArea(bool value) {
    objc.checkOsVersionInternal('UIView.setInsetsLayoutMarginsFromSafeArea:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setInsetsLayoutMarginsFromSafeArea_, value);
  }

  /// setLayoutMargins:
  set layoutMargins(UIEdgeInsets value) {
    objc.checkOsVersionInternal('UIView.setLayoutMargins:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1g8fos5(this.ref.pointer, _sel_setLayoutMargins_, value);
  }

  /// setNeedsLayout
  void setNeedsLayout() {
    objc.checkOsVersionInternal('UIView.setNeedsLayout', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsLayout);
  }

  /// setPreservesSuperviewLayoutMargins:
  set preservesSuperviewLayoutMargins(bool value) {
    objc.checkOsVersionInternal('UIView.setPreservesSuperviewLayoutMargins:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setPreservesSuperviewLayoutMargins_, value);
  }

  /// subviews
  objc.NSArray get subviews {
    objc.checkOsVersionInternal('UIView.subviews', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_subviews);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// superview
  UIView? get superview {
    objc.checkOsVersionInternal('UIView.superview', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_superview);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// viewWithTag:
  UIView? viewWithTag(int tag) {
    objc.checkOsVersionInternal('UIView.viewWithTag:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_qugqlf(this.ref.pointer, _sel_viewWithTag_, tag);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// willMoveToSuperview:
  void willMoveToSuperview(UIView? newSuperview) {
    objc.checkOsVersionInternal('UIView.willMoveToSuperview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToSuperview_, newSuperview?.ref.pointer ?? ffi.nullptr);
  }

  /// willMoveToWindow:
  void willMoveToWindow(UIWindow? newWindow) {
    objc.checkOsVersionInternal('UIView.willMoveToWindow:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willMoveToWindow_, newWindow?.ref.pointer ?? ffi.nullptr);
  }

  /// willRemoveSubview:
  void willRemoveSubview(UIView subview) {
    objc.checkOsVersionInternal('UIView.willRemoveSubview:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_willRemoveSubview_, subview.ref.pointer);
  }

  /// window
  UIWindow? get window {
    objc.checkOsVersionInternal('UIView.window', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_window);
    return $ret.address == 0 ? null : UIWindow.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_drawRect_ = objc.registerName("drawRect:");
late final _sel_setNeedsDisplay = objc.registerName("setNeedsDisplay");
late final _sel_setNeedsDisplayInRect_ = objc.registerName("setNeedsDisplayInRect:");
late final _sel_clipsToBounds = objc.registerName("clipsToBounds");
late final _sel_setClipsToBounds_ = objc.registerName("setClipsToBounds:");
late final _sel_alpha = objc.registerName("alpha");
late final _sel_setAlpha_ = objc.registerName("setAlpha:");
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_setOpaque_ = objc.registerName("setOpaque:");
late final _sel_clearsContextBeforeDrawing = objc.registerName("clearsContextBeforeDrawing");
late final _sel_setClearsContextBeforeDrawing_ = objc.registerName("setClearsContextBeforeDrawing:");
late final _sel_isHidden = objc.registerName("isHidden");
late final _sel_setHidden_ = objc.registerName("setHidden:");
late final _sel_contentMode = objc.registerName("contentMode");
late final _sel_setContentMode_ = objc.registerName("setContentMode:");
late final _sel_contentStretch = objc.registerName("contentStretch");
late final _sel_setContentStretch_ = objc.registerName("setContentStretch:");
late final _sel_maskView = objc.registerName("maskView");
late final _sel_setMaskView_ = objc.registerName("setMaskView:");

enum UIViewTintAdjustmentMode {
  UIViewTintAdjustmentModeAutomatic(0),
  UIViewTintAdjustmentModeNormal(1),
  UIViewTintAdjustmentModeDimmed(2);

  final int value;
  const UIViewTintAdjustmentMode(this.value);

  static UIViewTintAdjustmentMode fromValue(int value) => switch (value) {
    0 => UIViewTintAdjustmentModeAutomatic,
    1 => UIViewTintAdjustmentModeNormal,
    2 => UIViewTintAdjustmentModeDimmed,
    _ => throw ArgumentError('Unknown value for UIViewTintAdjustmentMode: $value'),
  };
}

late final _sel_tintAdjustmentMode = objc.registerName("tintAdjustmentMode");
final _objc_msgSend_1tlsbkb = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTintAdjustmentMode_ = objc.registerName("setTintAdjustmentMode:");
final _objc_msgSend_15t6owj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_tintColorDidChange = objc.registerName("tintColorDidChange");

/// UIViewRendering
extension UIViewRendering on UIView {
  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('UIView.alpha', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_alpha);
  }

  /// backgroundColor
  UIColor? get backgroundColor {
    objc.checkOsVersionInternal('UIView.backgroundColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_backgroundColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// clearsContextBeforeDrawing
  bool get clearsContextBeforeDrawing {
    objc.checkOsVersionInternal('UIView.clearsContextBeforeDrawing', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_clearsContextBeforeDrawing);
  }

  /// clipsToBounds
  bool get clipsToBounds {
    objc.checkOsVersionInternal('UIView.clipsToBounds', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_clipsToBounds);
  }

  /// contentMode
  UIViewContentMode get contentMode {
    objc.checkOsVersionInternal('UIView.contentMode', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_12r2l30(this.ref.pointer, _sel_contentMode);
    return UIViewContentMode.fromValue($ret);
  }

  /// contentStretch
  objc.CGRect get contentStretch {
    objc.checkOsVersionInternal('UIView.contentStretch', iOS: (false, (3, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_contentStretch)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_contentStretch);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// drawRect:
  void drawRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.drawRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawRect_, rect);
  }

  /// isHidden
  bool get isHidden {
    objc.checkOsVersionInternal('UIView.isHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHidden);
  }

  /// isOpaque
  bool get isOpaque {
    objc.checkOsVersionInternal('UIView.isOpaque', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOpaque);
  }

  /// maskView
  UIView? get maskView {
    objc.checkOsVersionInternal('UIView.maskView', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maskView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// setAlpha:
  set alpha(double value) {
    objc.checkOsVersionInternal('UIView.setAlpha:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setAlpha_, value);
  }

  /// setBackgroundColor:
  set backgroundColor(UIColor? value) {
    objc.checkOsVersionInternal('UIView.setBackgroundColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBackgroundColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setClearsContextBeforeDrawing:
  set clearsContextBeforeDrawing(bool value) {
    objc.checkOsVersionInternal('UIView.setClearsContextBeforeDrawing:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClearsContextBeforeDrawing_, value);
  }

  /// setClipsToBounds:
  set clipsToBounds(bool value) {
    objc.checkOsVersionInternal('UIView.setClipsToBounds:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClipsToBounds_, value);
  }

  /// setContentMode:
  set contentMode(UIViewContentMode value) {
    objc.checkOsVersionInternal('UIView.setContentMode:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_26z7iq(this.ref.pointer, _sel_setContentMode_, value.value);
  }

  /// setContentStretch:
  set contentStretch(objc.CGRect value) {
    objc.checkOsVersionInternal('UIView.setContentStretch:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setContentStretch_, value);
  }

  /// setHidden:
  set isHidden(bool value) {
    objc.checkOsVersionInternal('UIView.setHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHidden_, value);
  }

  /// setMaskView:
  set maskView(UIView? value) {
    objc.checkOsVersionInternal('UIView.setMaskView:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMaskView_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setNeedsDisplay
  void setNeedsDisplay() {
    objc.checkOsVersionInternal('UIView.setNeedsDisplay', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsDisplay);
  }

  /// setNeedsDisplayInRect:
  void setNeedsDisplayInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.setNeedsDisplayInRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_setNeedsDisplayInRect_, rect);
  }

  /// setOpaque:
  set isOpaque(bool value) {
    objc.checkOsVersionInternal('UIView.setOpaque:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setOpaque_, value);
  }

  /// setTintAdjustmentMode:
  set tintAdjustmentMode(UIViewTintAdjustmentMode value) {
    objc.checkOsVersionInternal('UIView.setTintAdjustmentMode:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_15t6owj(this.ref.pointer, _sel_setTintAdjustmentMode_, value.value);
  }

  /// setTintColor:
  set tintColor(UIColor value) {
    objc.checkOsVersionInternal('UIView.setTintColor:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTintColor_, value.ref.pointer);
  }

  /// tintAdjustmentMode
  UIViewTintAdjustmentMode get tintAdjustmentMode {
    objc.checkOsVersionInternal('UIView.tintAdjustmentMode', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1tlsbkb(this.ref.pointer, _sel_tintAdjustmentMode);
    return UIViewTintAdjustmentMode.fromValue($ret);
  }

  /// tintColor
  UIColor get tintColor {
    objc.checkOsVersionInternal('UIView.tintColor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_tintColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// tintColorDidChange
  void tintColorDidChange() {
    objc.checkOsVersionInternal('UIView.tintColorDidChange', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_tintColorDidChange);
  }
}

late final _sel_setAnimationsEnabled_ = objc.registerName("setAnimationsEnabled:");
late final _sel_areAnimationsEnabled = objc.registerName("areAnimationsEnabled");
late final _sel_performWithoutAnimation_ = objc.registerName("performWithoutAnimation:");
late final _sel_inheritedAnimationDuration = objc.registerName("inheritedAnimationDuration");

/// UIViewAnimation
extension UIViewAnimation on UIView {
  /// areAnimationsEnabled
  static bool getAreAnimationsEnabled() {
    objc.checkOsVersionInternal('UIView.areAnimationsEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_areAnimationsEnabled);
  }

  /// inheritedAnimationDuration
  static double getInheritedAnimationDuration() {
    objc.checkOsVersionInternal('UIView.inheritedAnimationDuration', iOS: (false, (9, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIView, _sel_inheritedAnimationDuration)
        : _objc_msgSend_1ukqyt8(_class_UIView, _sel_inheritedAnimationDuration);
  }

  /// performWithoutAnimation:
  static void performWithoutAnimation(objc.ObjCBlock<ffi.Void Function()> actionsWithoutAnimation) {
    objc.checkOsVersionInternal('UIView.performWithoutAnimation:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_f167m6(_class_UIView, _sel_performWithoutAnimation_, actionsWithoutAnimation.ref.pointer);
  }

  /// setAnimationsEnabled:
  static void setAnimationsEnabled(bool enabled) {
    objc.checkOsVersionInternal('UIView.setAnimationsEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationsEnabled_, enabled);
  }
}

late final _sel_animateWithDuration_delay_options_animations_completion_ = objc.registerName(
  "animateWithDuration:delay:options:animations:completion:",
);
final _objc_msgSend_1pforg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_completion_ = objc.registerName(
  "animateWithDuration:animations:completion:",
);
final _objc_msgSend_1isavsq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_animations_ = objc.registerName("animateWithDuration:animations:");
final _objc_msgSend_16dy26p = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_ =
    objc.registerName(
      "animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:",
    );
final _objc_msgSend_r4l13g = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionWithView_duration_options_animations_completion_ = objc.registerName(
  "transitionWithView:duration:options:animations:completion:",
);
final _objc_msgSend_q6v4dl = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_transitionFromView_toView_duration_options_completion_ = objc.registerName(
  "transitionFromView:toView:duration:options:completion:",
);
final _objc_msgSend_1eh0loo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

enum UISystemAnimation {
  UISystemAnimationDelete(0);

  final int value;
  const UISystemAnimation(this.value);

  static UISystemAnimation fromValue(int value) => switch (value) {
    0 => UISystemAnimationDelete,
    _ => throw ArgumentError('Unknown value for UISystemAnimation: $value'),
  };
}

late final _sel_performSystemAnimation_onViews_options_animations_completion_ = objc.registerName(
  "performSystemAnimation:onViews:options:animations:completion:",
);
final _objc_msgSend_fqrtz5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_ = objc.registerName(
  "modifyAnimationsWithRepeatCount:autoreverses:animations:",
);
final _objc_msgSend_nxk2e9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Bool,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        bool,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewAnimationWithBlocks
extension UIViewAnimationWithBlocks on UIView {
  /// animateWithDuration:animations:
  static void animateWithDuration(double duration, {required objc.ObjCBlock<ffi.Void Function()> animations}) {
    objc.checkOsVersionInternal('UIView.animateWithDuration:animations:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_16dy26p(_class_UIView, _sel_animateWithDuration_animations_, duration, animations.ref.pointer);
  }

  /// animateWithDuration:animations:completion:
  static void animateWithDuration$1(
    double duration, {
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal('UIView.animateWithDuration:animations:completion:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1isavsq(
      _class_UIView,
      _sel_animateWithDuration_animations_completion_,
      duration,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:options:animations:completion:
  static void animateWithDuration$2(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1pforg(
      _class_UIView,
      _sel_animateWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:
  static void animateWithDuration$3(
    double duration, {
    required double delay,
    required double usingSpringWithDamping,
    required double initialSpringVelocity,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_r4l13g(
      _class_UIView,
      _sel_animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion_,
      duration,
      delay,
      usingSpringWithDamping,
      initialSpringVelocity,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// modifyAnimationsWithRepeatCount:autoreverses:animations:
  static void modifyAnimationsWithRepeatCount(
    double count, {
    required bool autoreverses,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.modifyAnimationsWithRepeatCount:autoreverses:animations:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_nxk2e9(
      _class_UIView,
      _sel_modifyAnimationsWithRepeatCount_autoreverses_animations_,
      count,
      autoreverses,
      animations.ref.pointer,
    );
  }

  /// performSystemAnimation:onViews:options:animations:completion:
  static void performSystemAnimation(
    UISystemAnimation animation, {
    required objc.NSArray onViews,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.performSystemAnimation:onViews:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_fqrtz5(
      _class_UIView,
      _sel_performSystemAnimation_onViews_options_animations_completion_,
      animation.value,
      onViews.ref.pointer,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionFromView:toView:duration:options:completion:
  static void transitionFromView(
    UIView fromView, {
    required UIView toView,
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionFromView:toView:duration:options:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_1eh0loo(
      _class_UIView,
      _sel_transitionFromView_toView_duration_options_completion_,
      fromView.ref.pointer,
      toView.ref.pointer,
      duration,
      options,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transitionWithView:duration:options:animations:completion:
  static void transitionWithView(
    UIView view, {
    required double duration,
    required int options,
    objc.ObjCBlock<ffi.Void Function()>? animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.transitionWithView:duration:options:animations:completion:',
      iOS: (false, (4, 0, 0)),
    );
    _objc_msgSend_q6v4dl(
      _class_UIView,
      _sel_transitionWithView_duration_options_animations_completion_,
      view.ref.pointer,
      duration,
      options,
      animations?.ref.pointer ?? ffi.nullptr,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

sealed class UIViewKeyframeAnimationOptions {
  static const UIViewKeyframeAnimationOptionLayoutSubviews = 1;
  static const UIViewKeyframeAnimationOptionAllowUserInteraction = 2;
  static const UIViewKeyframeAnimationOptionBeginFromCurrentState = 4;
  static const UIViewKeyframeAnimationOptionRepeat = 8;
  static const UIViewKeyframeAnimationOptionAutoreverse = 16;
  static const UIViewKeyframeAnimationOptionOverrideInheritedDuration = 32;
  static const UIViewKeyframeAnimationOptionOverrideInheritedOptions = 512;
  static const UIViewKeyframeAnimationOptionCalculationModeLinear = 0;
  static const UIViewKeyframeAnimationOptionCalculationModeDiscrete = 1024;
  static const UIViewKeyframeAnimationOptionCalculationModePaced = 2048;
  static const UIViewKeyframeAnimationOptionCalculationModeCubic = 3072;
  static const UIViewKeyframeAnimationOptionCalculationModeCubicPaced = 4096;
}

late final _sel_animateKeyframesWithDuration_delay_options_animations_completion_ = objc.registerName(
  "animateKeyframesWithDuration:delay:options:animations:completion:",
);
final _objc_msgSend_ciuhtc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_ = objc.registerName(
  "addKeyframeWithRelativeStartTime:relativeDuration:animations:",
);
final _objc_msgSend_6jt11a = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// UIViewKeyframeAnimations
extension UIViewKeyframeAnimations on UIView {
  /// addKeyframeWithRelativeStartTime:relativeDuration:animations:
  static void addKeyframeWithRelativeStartTime(
    double frameStartTime, {
    required double relativeDuration,
    required objc.ObjCBlock<ffi.Void Function()> animations,
  }) {
    objc.checkOsVersionInternal(
      'UIView.addKeyframeWithRelativeStartTime:relativeDuration:animations:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_6jt11a(
      _class_UIView,
      _sel_addKeyframeWithRelativeStartTime_relativeDuration_animations_,
      frameStartTime,
      relativeDuration,
      animations.ref.pointer,
    );
  }

  /// animateKeyframesWithDuration:delay:options:animations:completion:
  static void animateKeyframesWithDuration(
    double duration, {
    required double delay,
    required int options,
    required objc.ObjCBlock<ffi.Void Function()> animations,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completion,
  }) {
    objc.checkOsVersionInternal(
      'UIView.animateKeyframesWithDuration:delay:options:animations:completion:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_ciuhtc(
      _class_UIView,
      _sel_animateKeyframesWithDuration_delay_options_animations_completion_,
      duration,
      delay,
      options,
      animations.ref.pointer,
      completion?.ref.pointer ?? ffi.nullptr,
    );
  }
}

late final _sel_gestureRecognizers = objc.registerName("gestureRecognizers");
late final _sel_setGestureRecognizers_ = objc.registerName("setGestureRecognizers:");
late final _sel_addGestureRecognizer_ = objc.registerName("addGestureRecognizer:");
late final _sel_removeGestureRecognizer_ = objc.registerName("removeGestureRecognizer:");
late final _sel_gestureRecognizerShouldBegin_ = objc.registerName("gestureRecognizerShouldBegin:");

/// UIViewGestureRecognizers
extension UIViewGestureRecognizers on UIView {
  /// addGestureRecognizer:
  void addGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.addGestureRecognizer:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addGestureRecognizer_, gestureRecognizer.ref.pointer);
  }

  /// gestureRecognizerShouldBegin:
  bool gestureRecognizerShouldBegin(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.gestureRecognizerShouldBegin:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_gestureRecognizerShouldBegin_, gestureRecognizer.ref.pointer);
  }

  /// gestureRecognizers
  objc.NSArray? get gestureRecognizers {
    objc.checkOsVersionInternal('UIView.gestureRecognizers', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_gestureRecognizers);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// removeGestureRecognizer:
  void removeGestureRecognizer(UIGestureRecognizer gestureRecognizer) {
    objc.checkOsVersionInternal('UIView.removeGestureRecognizer:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeGestureRecognizer_, gestureRecognizer.ref.pointer);
  }

  /// setGestureRecognizers:
  set gestureRecognizers(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIView.setGestureRecognizers:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setGestureRecognizers_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIMotionEffect is a stub. To generate bindings for this class, include
/// UIMotionEffect in your config's objc-interfaces list.
///
/// UIMotionEffect
class UIMotionEffect extends objc.ObjCObjectBase {
  UIMotionEffect._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIMotionEffect] that points to the same underlying object as [other].
  UIMotionEffect.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIMotionEffect] that wraps the given raw object pointer.
  UIMotionEffect.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_addMotionEffect_ = objc.registerName("addMotionEffect:");
late final _sel_removeMotionEffect_ = objc.registerName("removeMotionEffect:");
late final _sel_motionEffects = objc.registerName("motionEffects");
late final _sel_setMotionEffects_ = objc.registerName("setMotionEffects:");

/// UIViewMotionEffects
extension UIViewMotionEffects on UIView {
  /// ! Begins applying `effect` to the receiver. The effect's emitted keyPath/value pairs will be
  /// applied to the view's presentation layer.
  ///
  /// Animates the transition to the motion effect's values using the present UIView animation
  /// context.
  void addMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.addMotionEffect:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addMotionEffect_, effect.ref.pointer);
  }

  /// motionEffects
  objc.NSArray get motionEffects {
    objc.checkOsVersionInternal('UIView.motionEffects', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_motionEffects);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// ! Stops applying `effect` to the receiver. Any affected presentation values will animate to
  /// their post-removal values using the present UIView animation context.
  void removeMotionEffect(UIMotionEffect effect) {
    objc.checkOsVersionInternal('UIView.removeMotionEffect:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeMotionEffect_, effect.ref.pointer);
  }

  /// setMotionEffects:
  set motionEffects(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setMotionEffects:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMotionEffects_, value.ref.pointer);
  }
}

late final _sel_constraints = objc.registerName("constraints");
late final _class_NSLayoutConstraint = objc.getClass("NSLayoutConstraint");

sealed class NSLayoutFormatOptions {
  static const NSLayoutFormatAlignAllLeft = 2;
  static const NSLayoutFormatAlignAllRight = 4;
  static const NSLayoutFormatAlignAllTop = 8;
  static const NSLayoutFormatAlignAllBottom = 16;
  static const NSLayoutFormatAlignAllLeading = 32;
  static const NSLayoutFormatAlignAllTrailing = 64;
  static const NSLayoutFormatAlignAllCenterX = 512;
  static const NSLayoutFormatAlignAllCenterY = 1024;
  static const NSLayoutFormatAlignAllLastBaseline = 2048;
  static const NSLayoutFormatAlignAllFirstBaseline = 4096;
  static const NSLayoutFormatAlignAllBaseline = 2048;
  static const NSLayoutFormatAlignmentMask = 65535;
  static const NSLayoutFormatDirectionLeadingToTrailing = 0;
  static const NSLayoutFormatDirectionLeftToRight = 65536;
  static const NSLayoutFormatDirectionRightToLeft = 131072;
  static const NSLayoutFormatDirectionMask = 196608;
}

late final _sel_constraintsWithVisualFormat_options_metrics_views_ = objc.registerName(
  "constraintsWithVisualFormat:options:metrics:views:",
);
final _objc_msgSend_1i24u6t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();

enum NSLayoutAttribute {
  NSLayoutAttributeLeft(1),
  NSLayoutAttributeRight(2),
  NSLayoutAttributeTop(3),
  NSLayoutAttributeBottom(4),
  NSLayoutAttributeLeading(5),
  NSLayoutAttributeTrailing(6),
  NSLayoutAttributeWidth(7),
  NSLayoutAttributeHeight(8),
  NSLayoutAttributeCenterX(9),
  NSLayoutAttributeCenterY(10),
  NSLayoutAttributeLastBaseline(11),
  NSLayoutAttributeFirstBaseline(12),
  NSLayoutAttributeNotAnAttribute(0);

  static const NSLayoutAttributeBaseline = NSLayoutAttributeLastBaseline;

  final int value;
  const NSLayoutAttribute(this.value);

  static NSLayoutAttribute fromValue(int value) => switch (value) {
    1 => NSLayoutAttributeLeft,
    2 => NSLayoutAttributeRight,
    3 => NSLayoutAttributeTop,
    4 => NSLayoutAttributeBottom,
    5 => NSLayoutAttributeLeading,
    6 => NSLayoutAttributeTrailing,
    7 => NSLayoutAttributeWidth,
    8 => NSLayoutAttributeHeight,
    9 => NSLayoutAttributeCenterX,
    10 => NSLayoutAttributeCenterY,
    11 => NSLayoutAttributeLastBaseline,
    12 => NSLayoutAttributeFirstBaseline,
    0 => NSLayoutAttributeNotAnAttribute,
    _ => throw ArgumentError('Unknown value for NSLayoutAttribute: $value'),
  };

  @override
  String toString() {
    if (this == NSLayoutAttributeLastBaseline)
      return "NSLayoutAttribute.NSLayoutAttributeLastBaseline, NSLayoutAttribute.NSLayoutAttributeBaseline";
    return super.toString();
  }
}

enum NSLayoutRelation {
  NSLayoutRelationLessThanOrEqual(-1),
  NSLayoutRelationEqual(0),
  NSLayoutRelationGreaterThanOrEqual(1);

  final int value;
  const NSLayoutRelation(this.value);

  static NSLayoutRelation fromValue(int value) => switch (value) {
    -1 => NSLayoutRelationLessThanOrEqual,
    0 => NSLayoutRelationEqual,
    1 => NSLayoutRelationGreaterThanOrEqual,
    _ => throw ArgumentError('Unknown value for NSLayoutRelation: $value'),
  };
}

late final _sel_constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant_ = objc.registerName(
  "constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:",
);
final _objc_msgSend_1h0kas2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Double,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        int,
        ffi.Pointer<objc.ObjCObject>,
        int,
        double,
        double,
      )
    >();
late final _sel_priority = objc.registerName("priority");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPriority_ = objc.registerName("setPriority:");
final _objc_msgSend_v5hmet = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Float)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_shouldBeArchived = objc.registerName("shouldBeArchived");
late final _sel_setShouldBeArchived_ = objc.registerName("setShouldBeArchived:");
late final _sel_firstItem = objc.registerName("firstItem");
late final _sel_secondItem = objc.registerName("secondItem");
late final _sel_firstAttribute = objc.registerName("firstAttribute");
final _objc_msgSend_ynhelg = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_secondAttribute = objc.registerName("secondAttribute");

/// WARNING: NSLayoutAnchor is a stub. To generate bindings for this class, include
/// NSLayoutAnchor in your config's objc-interfaces list.
///
/// NSLayoutAnchor
class NSLayoutAnchor extends objc.NSObject implements objc.NSCopying, objc.NSCoding {
  NSLayoutAnchor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutAnchor] that points to the same underlying object as [other].
  NSLayoutAnchor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutAnchor] that wraps the given raw object pointer.
  NSLayoutAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_firstAnchor = objc.registerName("firstAnchor");
late final _sel_secondAnchor = objc.registerName("secondAnchor");
late final _sel_relation = objc.registerName("relation");
final _objc_msgSend_utwjq8 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_multiplier = objc.registerName("multiplier");
late final _sel_constant = objc.registerName("constant");
late final _sel_setConstant_ = objc.registerName("setConstant:");
late final _sel_isActive = objc.registerName("isActive");
late final _sel_setActive_ = objc.registerName("setActive:");
late final _sel_activateConstraints_ = objc.registerName("activateConstraints:");
late final _sel_deactivateConstraints_ = objc.registerName("deactivateConstraints:");
late final _sel_setIdentifier_ = objc.registerName("setIdentifier:");

/// NSIdentifier
extension NSIdentifier on NSLayoutConstraint {
  /// identifier
  objc.NSString? get identifier {
    objc.checkOsVersionInternal('NSLayoutConstraint.identifier', iOS: (false, (7, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_identifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setIdentifier:
  set identifier(objc.NSString? value) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.setIdentifier:',
      iOS: (false, (7, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// NSLayoutConstraint
class NSLayoutConstraint extends objc.NSObject {
  NSLayoutConstraint._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSLayoutConstraint', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
  }

  /// Constructs a [NSLayoutConstraint] that points to the same underlying object as [other].
  NSLayoutConstraint.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutConstraint] that wraps the given raw object pointer.
  NSLayoutConstraint.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSLayoutConstraint].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_NSLayoutConstraint);
  }

  /// activateConstraints:
  static void activateConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.activateConstraints:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(_class_NSLayoutConstraint, _sel_activateConstraints_, constraints.ref.pointer);
  }

  /// alloc
  static NSLayoutConstraint alloc() {
    final $ret = _objc_msgSend_151sglz(_class_NSLayoutConstraint, _sel_alloc);
    return NSLayoutConstraint.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static NSLayoutConstraint allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_NSLayoutConstraint, _sel_allocWithZone_, zone);
    return NSLayoutConstraint.castFromPointer($ret, retain: false, release: true);
  }

  /// constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:
  static NSLayoutConstraint constraintWithItem(
    objc.ObjCObjectBase view1, {
    required NSLayoutAttribute attribute,
    required NSLayoutRelation relatedBy,
    objc.ObjCObjectBase? toItem,
    required NSLayoutAttribute attribute$1,
    required double multiplier,
    required double constant,
  }) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1h0kas2(
      _class_NSLayoutConstraint,
      _sel_constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant_,
      view1.ref.pointer,
      attribute.value,
      relatedBy.value,
      toItem?.ref.pointer ?? ffi.nullptr,
      attribute$1.value,
      multiplier,
      constant,
    );
    return NSLayoutConstraint.castFromPointer($ret, retain: true, release: true);
  }

  /// constraintsWithVisualFormat:options:metrics:views:
  static objc.NSArray constraintsWithVisualFormat(
    objc.NSString format, {
    required int options,
    objc.NSDictionary? metrics,
    required objc.NSDictionary views,
  }) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.constraintsWithVisualFormat:options:metrics:views:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_1i24u6t(
      _class_NSLayoutConstraint,
      _sel_constraintsWithVisualFormat_options_metrics_views_,
      format.ref.pointer,
      options,
      metrics?.ref.pointer ?? ffi.nullptr,
      views.ref.pointer,
    );
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// deactivateConstraints:
  static void deactivateConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.deactivateConstraints:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_xtuoz7(_class_NSLayoutConstraint, _sel_deactivateConstraints_, constraints.ref.pointer);
  }

  /// new
  static NSLayoutConstraint new$() {
    final $ret = _objc_msgSend_151sglz(_class_NSLayoutConstraint, _sel_new);
    return NSLayoutConstraint.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of NSLayoutConstraint constructed with the default `new` method.
  factory NSLayoutConstraint() => new$();
}

extension NSLayoutConstraint$Methods on NSLayoutConstraint {
  /// constant
  double get constant {
    objc.checkOsVersionInternal('NSLayoutConstraint.constant', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_constant)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_constant);
  }

  /// firstAnchor
  NSLayoutAnchor get firstAnchor {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.firstAnchor',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_firstAnchor);
    return NSLayoutAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// firstAttribute
  NSLayoutAttribute get firstAttribute {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.firstAttribute',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_ynhelg(this.ref.pointer, _sel_firstAttribute);
    return NSLayoutAttribute.fromValue($ret);
  }

  /// firstItem
  objc.ObjCObjectBase? get firstItem {
    objc.checkOsVersionInternal('NSLayoutConstraint.firstItem', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_firstItem);
    return $ret.address == 0 ? null : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// init
  NSLayoutConstraint init() {
    objc.checkOsVersionInternal('NSLayoutConstraint.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return NSLayoutConstraint.castFromPointer($ret, retain: false, release: true);
  }

  /// isActive
  bool get isActive {
    objc.checkOsVersionInternal('NSLayoutConstraint.isActive', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isActive);
  }

  /// multiplier
  double get multiplier {
    objc.checkOsVersionInternal('NSLayoutConstraint.multiplier', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_multiplier)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_multiplier);
  }

  /// priority
  double get priority {
    objc.checkOsVersionInternal('NSLayoutConstraint.priority', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_priority)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_priority);
  }

  /// relation
  NSLayoutRelation get relation {
    objc.checkOsVersionInternal('NSLayoutConstraint.relation', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_utwjq8(this.ref.pointer, _sel_relation);
    return NSLayoutRelation.fromValue($ret);
  }

  /// secondAnchor
  NSLayoutAnchor? get secondAnchor {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.secondAnchor',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_secondAnchor);
    return $ret.address == 0 ? null : NSLayoutAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// secondAttribute
  NSLayoutAttribute get secondAttribute {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.secondAttribute',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    final $ret = _objc_msgSend_ynhelg(this.ref.pointer, _sel_secondAttribute);
    return NSLayoutAttribute.fromValue($ret);
  }

  /// secondItem
  objc.ObjCObjectBase? get secondItem {
    objc.checkOsVersionInternal('NSLayoutConstraint.secondItem', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_secondItem);
    return $ret.address == 0 ? null : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// setActive:
  set isActive(bool value) {
    objc.checkOsVersionInternal('NSLayoutConstraint.setActive:', iOS: (false, (8, 0, 0)), macOS: (false, (10, 10, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setActive_, value);
  }

  /// setConstant:
  set constant(double value) {
    objc.checkOsVersionInternal('NSLayoutConstraint.setConstant:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setConstant_, value);
  }

  /// setPriority:
  set priority(double value) {
    objc.checkOsVersionInternal('NSLayoutConstraint.setPriority:', iOS: (false, (6, 0, 0)), macOS: (false, (10, 7, 0)));
    _objc_msgSend_v5hmet(this.ref.pointer, _sel_setPriority_, value);
  }

  /// setShouldBeArchived:
  set shouldBeArchived(bool value) {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.setShouldBeArchived:',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShouldBeArchived_, value);
  }

  /// shouldBeArchived
  bool get shouldBeArchived {
    objc.checkOsVersionInternal(
      'NSLayoutConstraint.shouldBeArchived',
      iOS: (false, (6, 0, 0)),
      macOS: (false, (10, 7, 0)),
    );
    return _objc_msgSend_91o635(this.ref.pointer, _sel_shouldBeArchived);
  }
}

late final _sel_addConstraint_ = objc.registerName("addConstraint:");
late final _sel_addConstraints_ = objc.registerName("addConstraints:");
late final _sel_removeConstraint_ = objc.registerName("removeConstraint:");
late final _sel_removeConstraints_ = objc.registerName("removeConstraints:");

/// UIConstraintBasedLayoutInstallingConstraints
extension UIConstraintBasedLayoutInstallingConstraints on UIView {
  /// addConstraint:
  void addConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.addConstraint:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addConstraint_, constraint.ref.pointer);
  }

  /// addConstraints:
  void addConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal('UIView.addConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addConstraints_, constraints.ref.pointer);
  }

  /// constraints
  objc.NSArray get constraints {
    objc.checkOsVersionInternal('UIView.constraints', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_constraints);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// removeConstraint:
  void removeConstraint(NSLayoutConstraint constraint) {
    objc.checkOsVersionInternal('UIView.removeConstraint:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeConstraint_, constraint.ref.pointer);
  }

  /// removeConstraints:
  void removeConstraints(objc.NSArray constraints) {
    objc.checkOsVersionInternal('UIView.removeConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeConstraints_, constraints.ref.pointer);
  }
}

late final _sel_updateConstraintsIfNeeded = objc.registerName("updateConstraintsIfNeeded");
late final _sel_updateConstraints = objc.registerName("updateConstraints");
late final _sel_needsUpdateConstraints = objc.registerName("needsUpdateConstraints");
late final _sel_setNeedsUpdateConstraints = objc.registerName("setNeedsUpdateConstraints");

/// UIConstraintBasedLayoutCoreMethods
extension UIConstraintBasedLayoutCoreMethods on UIView {
  /// needsUpdateConstraints
  bool needsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.needsUpdateConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_needsUpdateConstraints);
  }

  /// setNeedsUpdateConstraints
  void setNeedsUpdateConstraints() {
    objc.checkOsVersionInternal('UIView.setNeedsUpdateConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsUpdateConstraints);
  }

  /// updateConstraints
  void updateConstraints() {
    objc.checkOsVersionInternal('UIView.updateConstraints', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraints);
  }

  /// updateConstraintsIfNeeded
  void updateConstraintsIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateConstraintsIfNeeded', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateConstraintsIfNeeded);
  }
}

late final _sel_translatesAutoresizingMaskIntoConstraints = objc.registerName(
  "translatesAutoresizingMaskIntoConstraints",
);
late final _sel_setTranslatesAutoresizingMaskIntoConstraints_ = objc.registerName(
  "setTranslatesAutoresizingMaskIntoConstraints:",
);
late final _sel_requiresConstraintBasedLayout = objc.registerName("requiresConstraintBasedLayout");

/// UIConstraintBasedCompatibility
extension UIConstraintBasedCompatibility on UIView {
  /// setTranslatesAutoresizingMaskIntoConstraints:
  set translatesAutoresizingMaskIntoConstraints(bool value) {
    objc.checkOsVersionInternal('UIView.setTranslatesAutoresizingMaskIntoConstraints:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setTranslatesAutoresizingMaskIntoConstraints_, value);
  }

  /// translatesAutoresizingMaskIntoConstraints
  bool get translatesAutoresizingMaskIntoConstraints {
    objc.checkOsVersionInternal('UIView.translatesAutoresizingMaskIntoConstraints', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_translatesAutoresizingMaskIntoConstraints);
  }

  /// requiresConstraintBasedLayout
  static bool getRequiresConstraintBasedLayout() {
    objc.checkOsVersionInternal('UIView.requiresConstraintBasedLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(_class_UIView, _sel_requiresConstraintBasedLayout);
  }
}

late final _sel_alignmentRectForFrame_ = objc.registerName("alignmentRectForFrame:");
final _objc_msgSend_1gn1s3d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
      >
    >()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)>();
final _objc_msgSend_1gn1s3dStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.CGRect>, ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect)
    >();
late final _sel_frameForAlignmentRect_ = objc.registerName("frameForAlignmentRect:");
late final _sel_alignmentRectInsets = objc.registerName("alignmentRectInsets");
late final _sel_viewForBaselineLayout = objc.registerName("viewForBaselineLayout");
late final _sel_viewForFirstBaselineLayout = objc.registerName("viewForFirstBaselineLayout");
late final _sel_viewForLastBaselineLayout = objc.registerName("viewForLastBaselineLayout");
late final _sel_intrinsicContentSize = objc.registerName("intrinsicContentSize");
late final _sel_invalidateIntrinsicContentSize = objc.registerName("invalidateIntrinsicContentSize");

enum UILayoutConstraintAxis {
  UILayoutConstraintAxisHorizontal(0),
  UILayoutConstraintAxisVertical(1);

  final int value;
  const UILayoutConstraintAxis(this.value);

  static UILayoutConstraintAxis fromValue(int value) => switch (value) {
    0 => UILayoutConstraintAxisHorizontal,
    1 => UILayoutConstraintAxisVertical,
    _ => throw ArgumentError('Unknown value for UILayoutConstraintAxis: $value'),
  };
}

late final _sel_contentHuggingPriorityForAxis_ = objc.registerName("contentHuggingPriorityForAxis:");
final _objc_msgSend_qigf85 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_qigf85Fpret = objc.msgSendFpretPointer
    .cast<
      ffi.NativeFunction<ffi.Float Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<double Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setContentHuggingPriority_forAxis_ = objc.registerName("setContentHuggingPriority:forAxis:");
final _objc_msgSend_wd7esz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Float, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, double, int)>();
late final _sel_contentCompressionResistancePriorityForAxis_ = objc.registerName(
  "contentCompressionResistancePriorityForAxis:",
);
late final _sel_setContentCompressionResistancePriority_forAxis_ = objc.registerName(
  "setContentCompressionResistancePriority:forAxis:",
);

/// UIConstraintBasedLayoutLayering
extension UIConstraintBasedLayoutLayering on UIView {
  /// alignmentRectForFrame:
  objc.CGRect alignmentRectForFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.alignmentRectForFrame:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret($ptr, this.ref.pointer, _sel_alignmentRectForFrame_, frame)
        : $ptr.ref = _objc_msgSend_1gn1s3d(this.ref.pointer, _sel_alignmentRectForFrame_, frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// alignmentRectInsets
  UIEdgeInsets get alignmentRectInsets {
    objc.checkOsVersionInternal('UIView.alignmentRectInsets', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<UIEdgeInsets>();
    objc.useMsgSendVariants
        ? _objc_msgSend_ct4cu5Stret($ptr, this.ref.pointer, _sel_alignmentRectInsets)
        : $ptr.ref = _objc_msgSend_ct4cu5(this.ref.pointer, _sel_alignmentRectInsets);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<UIEdgeInsets>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<UIEdgeInsets>($finalizable);
  }

  /// contentCompressionResistancePriorityForAxis:
  double contentCompressionResistancePriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.contentCompressionResistancePriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(this.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(this.ref.pointer, _sel_contentCompressionResistancePriorityForAxis_, axis.value);
  }

  /// contentHuggingPriorityForAxis:
  double contentHuggingPriorityForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.contentHuggingPriorityForAxis:', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_qigf85Fpret(this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value)
        : _objc_msgSend_qigf85(this.ref.pointer, _sel_contentHuggingPriorityForAxis_, axis.value);
  }

  /// frameForAlignmentRect:
  objc.CGRect frameForAlignmentRect(objc.CGRect alignmentRect) {
    objc.checkOsVersionInternal('UIView.frameForAlignmentRect:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1gn1s3dStret($ptr, this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect)
        : $ptr.ref = _objc_msgSend_1gn1s3d(this.ref.pointer, _sel_frameForAlignmentRect_, alignmentRect);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// intrinsicContentSize
  objc.CGSize get intrinsicContentSize {
    objc.checkOsVersionInternal('UIView.intrinsicContentSize', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret($ptr, this.ref.pointer, _sel_intrinsicContentSize)
        : $ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_intrinsicContentSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// invalidateIntrinsicContentSize
  void invalidateIntrinsicContentSize() {
    objc.checkOsVersionInternal('UIView.invalidateIntrinsicContentSize', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_invalidateIntrinsicContentSize);
  }

  /// setContentCompressionResistancePriority:forAxis:
  void setContentCompressionResistancePriority(double priority, {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal('UIView.setContentCompressionResistancePriority:forAxis:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(
      this.ref.pointer,
      _sel_setContentCompressionResistancePriority_forAxis_,
      priority,
      forAxis.value,
    );
  }

  /// setContentHuggingPriority:forAxis:
  void setContentHuggingPriority(double priority, {required UILayoutConstraintAxis forAxis}) {
    objc.checkOsVersionInternal('UIView.setContentHuggingPriority:forAxis:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_wd7esz(this.ref.pointer, _sel_setContentHuggingPriority_forAxis_, priority, forAxis.value);
  }

  /// viewForBaselineLayout
  UIView viewForBaselineLayout() {
    objc.checkOsVersionInternal('UIView.viewForBaselineLayout', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForBaselineLayout);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// viewForFirstBaselineLayout
  UIView get viewForFirstBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForFirstBaselineLayout', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForFirstBaselineLayout);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// viewForLastBaselineLayout
  UIView get viewForLastBaselineLayout {
    objc.checkOsVersionInternal('UIView.viewForLastBaselineLayout', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_viewForLastBaselineLayout);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_systemLayoutSizeFittingSize_ = objc.registerName("systemLayoutSizeFittingSize:");
late final _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_ = objc.registerName(
  "systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:",
);
final _objc_msgSend_3fx2qn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGSize Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      objc.CGSize Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGSize, double, double)
    >();
final _objc_msgSend_3fx2qnStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGSize>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGSize,
          ffi.Float,
          ffi.Float,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGSize>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGSize,
        double,
        double,
      )
    >();

/// UIConstraintBasedLayoutFittingSize
extension UIConstraintBasedLayoutFittingSize on UIView {
  /// systemLayoutSizeFittingSize:
  objc.CGSize systemLayoutSizeFittingSize(objc.CGSize targetSize) {
    objc.checkOsVersionInternal('UIView.systemLayoutSizeFittingSize:', iOS: (false, (6, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1owrp3bStret($ptr, this.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize)
        : $ptr.ref = _objc_msgSend_1owrp3b(this.ref.pointer, _sel_systemLayoutSizeFittingSize_, targetSize);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:
  objc.CGSize systemLayoutSizeFittingSize$1(
    objc.CGSize targetSize, {
    required double withHorizontalFittingPriority,
    required double verticalFittingPriority,
  }) {
    objc.checkOsVersionInternal(
      'UIView.systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:',
      iOS: (false, (8, 0, 0)),
    );
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3fx2qnStret(
            $ptr,
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          )
        : $ptr.ref = _objc_msgSend_3fx2qn(
            this.ref.pointer,
            _sel_systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority_,
            targetSize,
            withHorizontalFittingPriority,
            verticalFittingPriority,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }
}

late final _sel_layoutGuides = objc.registerName("layoutGuides");
late final _sel_addLayoutGuide_ = objc.registerName("addLayoutGuide:");
late final _sel_removeLayoutGuide_ = objc.registerName("removeLayoutGuide:");

/// UILayoutGuideSupport
extension UILayoutGuideSupport on UIView {
  /// addLayoutGuide:
  void addLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.addLayoutGuide:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addLayoutGuide_, layoutGuide.ref.pointer);
  }

  /// layoutGuides
  objc.NSArray get layoutGuides {
    objc.checkOsVersionInternal('UIView.layoutGuides', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layoutGuides);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// removeLayoutGuide:
  void removeLayoutGuide(UILayoutGuide layoutGuide) {
    objc.checkOsVersionInternal('UIView.removeLayoutGuide:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeLayoutGuide_, layoutGuide.ref.pointer);
  }
}

/// WARNING: NSLayoutXAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutXAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutXAxisAnchor
class NSLayoutXAxisAnchor extends NSLayoutAnchor {
  NSLayoutXAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutXAxisAnchor] that points to the same underlying object as [other].
  NSLayoutXAxisAnchor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutXAxisAnchor] that wraps the given raw object pointer.
  NSLayoutXAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_leadingAnchor = objc.registerName("leadingAnchor");
late final _sel_trailingAnchor = objc.registerName("trailingAnchor");
late final _sel_leftAnchor = objc.registerName("leftAnchor");
late final _sel_rightAnchor = objc.registerName("rightAnchor");

/// WARNING: NSLayoutYAxisAnchor is a stub. To generate bindings for this class, include
/// NSLayoutYAxisAnchor in your config's objc-interfaces list.
///
/// NSLayoutYAxisAnchor
class NSLayoutYAxisAnchor extends NSLayoutAnchor {
  NSLayoutYAxisAnchor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutYAxisAnchor] that points to the same underlying object as [other].
  NSLayoutYAxisAnchor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutYAxisAnchor] that wraps the given raw object pointer.
  NSLayoutYAxisAnchor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_topAnchor = objc.registerName("topAnchor");
late final _sel_bottomAnchor = objc.registerName("bottomAnchor");

/// WARNING: NSLayoutDimension is a stub. To generate bindings for this class, include
/// NSLayoutDimension in your config's objc-interfaces list.
///
/// NSLayoutDimension
class NSLayoutDimension extends NSLayoutAnchor {
  NSLayoutDimension._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [NSLayoutDimension] that points to the same underlying object as [other].
  NSLayoutDimension.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSLayoutDimension] that wraps the given raw object pointer.
  NSLayoutDimension.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_widthAnchor = objc.registerName("widthAnchor");
late final _sel_heightAnchor = objc.registerName("heightAnchor");
late final _sel_centerXAnchor = objc.registerName("centerXAnchor");
late final _sel_centerYAnchor = objc.registerName("centerYAnchor");
late final _sel_firstBaselineAnchor = objc.registerName("firstBaselineAnchor");
late final _sel_lastBaselineAnchor = objc.registerName("lastBaselineAnchor");

/// UIViewLayoutConstraintCreation
extension UIViewLayoutConstraintCreation on UIView {
  /// bottomAnchor
  NSLayoutYAxisAnchor get bottomAnchor {
    objc.checkOsVersionInternal('UIView.bottomAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_bottomAnchor);
    return NSLayoutYAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// centerXAnchor
  NSLayoutXAxisAnchor get centerXAnchor {
    objc.checkOsVersionInternal('UIView.centerXAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerXAnchor);
    return NSLayoutXAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// centerYAnchor
  NSLayoutYAxisAnchor get centerYAnchor {
    objc.checkOsVersionInternal('UIView.centerYAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_centerYAnchor);
    return NSLayoutYAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// firstBaselineAnchor
  NSLayoutYAxisAnchor get firstBaselineAnchor {
    objc.checkOsVersionInternal('UIView.firstBaselineAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_firstBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// heightAnchor
  NSLayoutDimension get heightAnchor {
    objc.checkOsVersionInternal('UIView.heightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_heightAnchor);
    return NSLayoutDimension.castFromPointer($ret, retain: true, release: true);
  }

  /// lastBaselineAnchor
  NSLayoutYAxisAnchor get lastBaselineAnchor {
    objc.checkOsVersionInternal('UIView.lastBaselineAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_lastBaselineAnchor);
    return NSLayoutYAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// leadingAnchor
  NSLayoutXAxisAnchor get leadingAnchor {
    objc.checkOsVersionInternal('UIView.leadingAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leadingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// leftAnchor
  NSLayoutXAxisAnchor get leftAnchor {
    objc.checkOsVersionInternal('UIView.leftAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_leftAnchor);
    return NSLayoutXAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// rightAnchor
  NSLayoutXAxisAnchor get rightAnchor {
    objc.checkOsVersionInternal('UIView.rightAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_rightAnchor);
    return NSLayoutXAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// topAnchor
  NSLayoutYAxisAnchor get topAnchor {
    objc.checkOsVersionInternal('UIView.topAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_topAnchor);
    return NSLayoutYAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// trailingAnchor
  NSLayoutXAxisAnchor get trailingAnchor {
    objc.checkOsVersionInternal('UIView.trailingAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_trailingAnchor);
    return NSLayoutXAxisAnchor.castFromPointer($ret, retain: true, release: true);
  }

  /// widthAnchor
  NSLayoutDimension get widthAnchor {
    objc.checkOsVersionInternal('UIView.widthAnchor', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_widthAnchor);
    return NSLayoutDimension.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_constraintsAffectingLayoutForAxis_ = objc.registerName("constraintsAffectingLayoutForAxis:");
final _objc_msgSend_5swr7b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_hasAmbiguousLayout = objc.registerName("hasAmbiguousLayout");
late final _sel_exerciseAmbiguityInLayout = objc.registerName("exerciseAmbiguityInLayout");

/// UIConstraintBasedLayoutDebugging
extension UIConstraintBasedLayoutDebugging on UIView {
  /// constraintsAffectingLayoutForAxis:
  objc.NSArray constraintsAffectingLayoutForAxis(UILayoutConstraintAxis axis) {
    objc.checkOsVersionInternal('UIView.constraintsAffectingLayoutForAxis:', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_5swr7b(this.ref.pointer, _sel_constraintsAffectingLayoutForAxis_, axis.value);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// exerciseAmbiguityInLayout
  void exerciseAmbiguityInLayout() {
    objc.checkOsVersionInternal('UIView.exerciseAmbiguityInLayout', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_exerciseAmbiguityInLayout);
  }

  /// hasAmbiguousLayout
  bool get hasAmbiguousLayout {
    objc.checkOsVersionInternal('UIView.hasAmbiguousLayout', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_hasAmbiguousLayout);
  }
}

/// UIStateRestoration
extension UIStateRestoration on UIView {
  /// decodeRestorableStateWithCoder:
  void decodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.decodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// encodeRestorableStateWithCoder:
  void encodeRestorableStateWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIView.encodeRestorableStateWithCoder:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeRestorableStateWithCoder_, coder.ref.pointer);
  }

  /// restorationIdentifier
  objc.NSString? get restorationIdentifier {
    objc.checkOsVersionInternal('UIView.restorationIdentifier', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_restorationIdentifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setRestorationIdentifier:
  set restorationIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setRestorationIdentifier:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRestorationIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_snapshotViewAfterScreenUpdates_ = objc.registerName("snapshotViewAfterScreenUpdates:");
late final _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_ = objc.registerName(
  "resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:",
);
final _objc_msgSend_qvletk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Bool,
          UIEdgeInsets,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        bool,
        UIEdgeInsets,
      )
    >();
late final _sel_drawViewHierarchyInRect_afterScreenUpdates_ = objc.registerName(
  "drawViewHierarchyInRect:afterScreenUpdates:",
);
final _objc_msgSend_19ljaqg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Bool)
      >
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, bool)>();

/// UISnapshotting
extension UISnapshotting on UIView {
  /// drawViewHierarchyInRect:afterScreenUpdates:
  bool drawViewHierarchyInRect(objc.CGRect rect, {required bool afterScreenUpdates}) {
    objc.checkOsVersionInternal('UIView.drawViewHierarchyInRect:afterScreenUpdates:', iOS: (false, (7, 0, 0)));
    return _objc_msgSend_19ljaqg(
      this.ref.pointer,
      _sel_drawViewHierarchyInRect_afterScreenUpdates_,
      rect,
      afterScreenUpdates,
    );
  }

  /// resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:
  UIView? resizableSnapshotViewFromRect(
    objc.CGRect rect, {
    required bool afterScreenUpdates,
    required UIEdgeInsets withCapInsets,
  }) {
    objc.checkOsVersionInternal(
      'UIView.resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:',
      iOS: (false, (7, 0, 0)),
    );
    final $ret = _objc_msgSend_qvletk(
      this.ref.pointer,
      _sel_resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets_,
      rect,
      afterScreenUpdates,
      withCapInsets,
    );
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// snapshotViewAfterScreenUpdates:
  UIView? snapshotViewAfterScreenUpdates(bool afterUpdates) {
    objc.checkOsVersionInternal('UIView.snapshotViewAfterScreenUpdates:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1t6aok9(this.ref.pointer, _sel_snapshotViewAfterScreenUpdates_, afterUpdates);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_beginAnimations_context_ = objc.registerName("beginAnimations:context:");
final _objc_msgSend_1lzqwav = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_commitAnimations = objc.registerName("commitAnimations");
late final _sel_setAnimationDelegate_ = objc.registerName("setAnimationDelegate:");
late final _sel_setAnimationWillStartSelector_ = objc.registerName("setAnimationWillStartSelector:");
late final _sel_setAnimationDidStopSelector_ = objc.registerName("setAnimationDidStopSelector:");
late final _sel_setAnimationDuration_ = objc.registerName("setAnimationDuration:");
late final _sel_setAnimationDelay_ = objc.registerName("setAnimationDelay:");
late final _sel_setAnimationStartDate_ = objc.registerName("setAnimationStartDate:");

enum UIViewAnimationCurve {
  UIViewAnimationCurveEaseInOut(0),
  UIViewAnimationCurveEaseIn(1),
  UIViewAnimationCurveEaseOut(2),
  UIViewAnimationCurveLinear(3);

  final int value;
  const UIViewAnimationCurve(this.value);

  static UIViewAnimationCurve fromValue(int value) => switch (value) {
    0 => UIViewAnimationCurveEaseInOut,
    1 => UIViewAnimationCurveEaseIn,
    2 => UIViewAnimationCurveEaseOut,
    3 => UIViewAnimationCurveLinear,
    _ => throw ArgumentError('Unknown value for UIViewAnimationCurve: $value'),
  };
}

late final _sel_setAnimationCurve_ = objc.registerName("setAnimationCurve:");
final _objc_msgSend_up32gn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAnimationRepeatCount_ = objc.registerName("setAnimationRepeatCount:");
late final _sel_setAnimationRepeatAutoreverses_ = objc.registerName("setAnimationRepeatAutoreverses:");
late final _sel_setAnimationBeginsFromCurrentState_ = objc.registerName("setAnimationBeginsFromCurrentState:");

enum UIViewAnimationTransition {
  UIViewAnimationTransitionNone(0),
  UIViewAnimationTransitionFlipFromLeft(1),
  UIViewAnimationTransitionFlipFromRight(2),
  UIViewAnimationTransitionCurlUp(3),
  UIViewAnimationTransitionCurlDown(4);

  final int value;
  const UIViewAnimationTransition(this.value);

  static UIViewAnimationTransition fromValue(int value) => switch (value) {
    0 => UIViewAnimationTransitionNone,
    1 => UIViewAnimationTransitionFlipFromLeft,
    2 => UIViewAnimationTransitionFlipFromRight,
    3 => UIViewAnimationTransitionCurlUp,
    4 => UIViewAnimationTransitionCurlDown,
    _ => throw ArgumentError('Unknown value for UIViewAnimationTransition: $value'),
  };
}

late final _sel_setAnimationTransition_forView_cache_ = objc.registerName("setAnimationTransition:forView:cache:");
final _objc_msgSend_1ftk3d5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Long,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObject>,
        bool,
      )
    >();

/// DeprecatedAnimations
extension DeprecatedAnimations on UIView {
  /// beginAnimations:context:
  static void beginAnimations(objc.NSString? animationID, {required ffi.Pointer<ffi.Void> context}) {
    objc.checkOsVersionInternal('UIView.beginAnimations:context:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1lzqwav(
      _class_UIView,
      _sel_beginAnimations_context_,
      animationID?.ref.pointer ?? ffi.nullptr,
      context,
    );
  }

  /// commitAnimations
  static void commitAnimations() {
    objc.checkOsVersionInternal('UIView.commitAnimations', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(_class_UIView, _sel_commitAnimations);
  }

  /// setAnimationBeginsFromCurrentState:
  static void setAnimationBeginsFromCurrentState(bool fromCurrentState) {
    objc.checkOsVersionInternal('UIView.setAnimationBeginsFromCurrentState:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationBeginsFromCurrentState_, fromCurrentState);
  }

  /// setAnimationCurve:
  static void setAnimationCurve(UIViewAnimationCurve curve) {
    objc.checkOsVersionInternal('UIView.setAnimationCurve:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_up32gn(_class_UIView, _sel_setAnimationCurve_, curve.value);
  }

  /// setAnimationDelay:
  static void setAnimationDelay(double delay) {
    objc.checkOsVersionInternal('UIView.setAnimationDelay:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDelay_, delay);
  }

  /// setAnimationDelegate:
  static void setAnimationDelegate(objc.ObjCObjectBase? delegate) {
    objc.checkOsVersionInternal('UIView.setAnimationDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationDelegate_, delegate?.ref.pointer ?? ffi.nullptr);
  }

  /// setAnimationDidStopSelector:
  static void setAnimationDidStopSelector(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationDidStopSelector:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationDidStopSelector_, selector);
  }

  /// setAnimationDuration:
  static void setAnimationDuration(double duration) {
    objc.checkOsVersionInternal('UIView.setAnimationDuration:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(_class_UIView, _sel_setAnimationDuration_, duration);
  }

  /// setAnimationRepeatAutoreverses:
  static void setAnimationRepeatAutoreverses(bool repeatAutoreverses) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatAutoreverses:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(_class_UIView, _sel_setAnimationRepeatAutoreverses_, repeatAutoreverses);
  }

  /// setAnimationRepeatCount:
  static void setAnimationRepeatCount(double repeatCount) {
    objc.checkOsVersionInternal('UIView.setAnimationRepeatCount:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_v5hmet(_class_UIView, _sel_setAnimationRepeatCount_, repeatCount);
  }

  /// setAnimationStartDate:
  static void setAnimationStartDate(objc.NSDate startDate) {
    objc.checkOsVersionInternal('UIView.setAnimationStartDate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIView, _sel_setAnimationStartDate_, startDate.ref.pointer);
  }

  /// setAnimationTransition:forView:cache:
  static void setAnimationTransition(
    UIViewAnimationTransition transition, {
    required UIView forView,
    required bool cache,
  }) {
    objc.checkOsVersionInternal('UIView.setAnimationTransition:forView:cache:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1ftk3d5(
      _class_UIView,
      _sel_setAnimationTransition_forView_cache_,
      transition.value,
      forView.ref.pointer,
      cache,
    );
  }

  /// setAnimationWillStartSelector:
  static void setAnimationWillStartSelector(ffi.Pointer<objc.ObjCSelector> selector) {
    objc.checkOsVersionInternal('UIView.setAnimationWillStartSelector:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1d9e4oe(_class_UIView, _sel_setAnimationWillStartSelector_, selector);
  }
}

/// UserInterfaceStyle
extension UserInterfaceStyle on UIView {
  /// overrideUserInterfaceStyle
  UIUserInterfaceStyle get overrideUserInterfaceStyle {
    objc.checkOsVersionInternal('UIView.overrideUserInterfaceStyle', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_2x5ago(this.ref.pointer, _sel_overrideUserInterfaceStyle);
    return UIUserInterfaceStyle.fromValue($ret);
  }

  /// setOverrideUserInterfaceStyle:
  set overrideUserInterfaceStyle(UIUserInterfaceStyle value) {
    objc.checkOsVersionInternal('UIView.setOverrideUserInterfaceStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_15dz1ky(this.ref.pointer, _sel_setOverrideUserInterfaceStyle_, value.value);
  }
}

late final _sel_minimumContentSizeCategory = objc.registerName("minimumContentSizeCategory");
late final _sel_setMinimumContentSizeCategory_ = objc.registerName("setMinimumContentSizeCategory:");
late final _sel_maximumContentSizeCategory = objc.registerName("maximumContentSizeCategory");
late final _sel_setMaximumContentSizeCategory_ = objc.registerName("setMaximumContentSizeCategory:");
late final _sel_appliedContentSizeCategoryLimitsDescription = objc.registerName(
  "appliedContentSizeCategoryLimitsDescription",
);

/// UIContentSizeCategoryLimit
extension UIContentSizeCategoryLimit on UIView {
  /// Will return a string with a log of all the superviews of this view, alongside with what
  /// content size category each view has and if that view has limits applied.
  /// This is for debugging purposes only.
  objc.NSString get appliedContentSizeCategoryLimitsDescription {
    objc.checkOsVersionInternal('UIView.appliedContentSizeCategoryLimitsDescription', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_appliedContentSizeCategoryLimitsDescription);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// maximumContentSizeCategory
  objc.NSString? get maximumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.maximumContentSizeCategory', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_maximumContentSizeCategory);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// Specify content size category limits. Setting one or both of these properties will limit the
  /// content size category for this view (and its subviews) to a minimum or a maximum value.
  /// You can use this to limit the support content size categories on part of your view hierarchy.
  /// Setting this to nil removes the limit on the minimum or maximum.
  /// Limits will be applied immediately and when future content size category updates occur.
  ///
  /// Specifying a minimum limit that is greater than the maximum limit (or vice versa) will effectively
  /// only use the maximum limit.
  ///
  /// Example:
  ///
  /// // limit the support content size categories between .medium and .accessibilityExtraLarge (included).
  /// view.minimumContentSizeCategory = UIContentSizeCategoryMedium;
  /// view.maximumContentSizeCategory = UIContentSizeCategoryAccessibilityExtraLarge;
  objc.NSString? get minimumContentSizeCategory {
    objc.checkOsVersionInternal('UIView.minimumContentSizeCategory', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_minimumContentSizeCategory);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setMaximumContentSizeCategory:
  set maximumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMaximumContentSizeCategory:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMaximumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Specify content size category limits. Setting one or both of these properties will limit the
  /// content size category for this view (and its subviews) to a minimum or a maximum value.
  /// You can use this to limit the support content size categories on part of your view hierarchy.
  /// Setting this to nil removes the limit on the minimum or maximum.
  /// Limits will be applied immediately and when future content size category updates occur.
  ///
  /// Specifying a minimum limit that is greater than the maximum limit (or vice versa) will effectively
  /// only use the maximum limit.
  ///
  /// Example:
  ///
  /// // limit the support content size categories between .medium and .accessibilityExtraLarge (included).
  /// view.minimumContentSizeCategory = UIContentSizeCategoryMedium;
  /// view.maximumContentSizeCategory = UIContentSizeCategoryAccessibilityExtraLarge;
  set minimumContentSizeCategory(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setMinimumContentSizeCategory:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMinimumContentSizeCategory_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIInteraction is a stub. To generate bindings for this class, include
/// UIInteraction in your config's objc-protocols list.
///
/// UIInteraction
interface class UIInteraction extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIInteraction] that points to the same underlying object as [other].
  UIInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInteraction] that wraps the given raw object pointer.
  UIInteraction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_addInteraction_ = objc.registerName("addInteraction:");
late final _sel_removeInteraction_ = objc.registerName("removeInteraction:");
late final _sel_interactions = objc.registerName("interactions");
late final _sel_setInteractions_ = objc.registerName("setInteractions:");

/// Interactions
extension Interactions on UIView {
  /// addInteraction:
  void addInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.addInteraction:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addInteraction_, interaction.ref.pointer);
  }

  /// interactions
  objc.NSArray get interactions {
    objc.checkOsVersionInternal('UIView.interactions', iOS: (false, (11, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_interactions);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// removeInteraction:
  void removeInteraction(UIInteraction interaction) {
    objc.checkOsVersionInternal('UIView.removeInteraction:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_removeInteraction_, interaction.ref.pointer);
  }

  /// setInteractions:
  set interactions(objc.NSArray value) {
    objc.checkOsVersionInternal('UIView.setInteractions:', iOS: (false, (11, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setInteractions_, value.ref.pointer);
  }
}

late final _sel_endEditing_ = objc.registerName("endEditing:");

/// UITextField
extension UITextField on UIView {
  /// endEditing:
  bool endEditing(bool force) {
    objc.checkOsVersionInternal('UIView.endEditing:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_41h7k3(this.ref.pointer, _sel_endEditing_, force);
  }
}

/// WARNING: UIDynamicItem is a stub. To generate bindings for this class, include
/// UIDynamicItem in your config's objc-protocols list.
///
/// UIDynamicItem
interface class UIDynamicItem extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIDynamicItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIDynamicItem] that points to the same underlying object as [other].
  UIDynamicItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIDynamicItem] that wraps the given raw object pointer.
  UIDynamicItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIFocusItem is a stub. To generate bindings for this class, include
/// UIFocusItem in your config's objc-protocols list.
///
/// Objects conforming to UIFocusItem are considered capable of participating in focus. Only UIFocusItems can ever be focused.
interface class UIFocusItem extends objc.ObjCProtocolBase implements UIFocusEnvironment {
  UIFocusItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIFocusItem] that points to the same underlying object as [other].
  UIFocusItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFocusItem] that wraps the given raw object pointer.
  UIFocusItem.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: CALayerDelegate is a stub. To generate bindings for this class, include
/// CALayerDelegate in your config's objc-protocols list.
///
/// CALayerDelegate
interface class CALayerDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  CALayerDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CALayerDelegate] that points to the same underlying object as [other].
  CALayerDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CALayerDelegate] that wraps the given raw object pointer.
  CALayerDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// UIView
class UIView extends UIResponder
    implements
        objc.NSCoding,
        UIAppearance,
        UIAppearanceContainer,
        UIDynamicItem,
        UITraitEnvironment,
        UICoordinateSpace,
        UIFocusItem,
        UIFocusItemContainer,
        CALayerDelegate {
  UIView._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIView', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIView] that points to the same underlying object as [other].
  UIView.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIView] that wraps the given raw object pointer.
  UIView.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIView].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIView);
  }

  /// alloc
  static UIView alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_alloc);
    return UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIView allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIView, _sel_allocWithZone_, zone);
    return UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UIView appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_appearance);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UIView appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIView, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UIView appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UIView.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UIView appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UIView.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIView,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UIView appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UIView.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UIView appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UIView.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UIView,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIView.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// new
  static UIView new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIView, _sel_new);
    return UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIView.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UIView,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of UIView constructed with the default `new` method.
  factory UIView() => new$();
}

extension UIView$Methods on UIView {
  /// actionForLayer:forKey:
  CAAction? actionForLayer(CALayer layer, {required objc.NSString forKey}) {
    objc.checkOsVersionInternal('UIView.actionForLayer:forKey:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_actionForLayer_forKey_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'actionForLayer:forKey:');
    }
    final $ret = _objc_msgSend_15qeuct(
      this.ref.pointer,
      _sel_actionForLayer_forKey_,
      layer.ref.pointer,
      forKey.ref.pointer,
    );
    return $ret.address == 0 ? null : CAAction.castFromPointer($ret, retain: true, release: true);
  }

  /// bounds
  objc.CGRect get bounds {
    objc.checkOsVersionInternal('UIView.bounds', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_bounds)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_bounds);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// Indicates whether or not this item is currently allowed to become focused.
  /// Returning NO restricts the item from being focusable, even if it is visible in the user interface. For example, UIControls return NO if they are disabled.
  bool get canBecomeFocused {
    objc.checkOsVersionInternal('UIView.canBecomeFocused', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFocused);
  }

  /// center
  objc.CGPoint get center {
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1uwdhlkStret($ptr, this.ref.pointer, _sel_center)
        : $ptr.ref = _objc_msgSend_1uwdhlk(this.ref.pointer, _sel_center);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// The path must represent a convex polygon with counter clockwise winding and no self intersection.
  /// The point (0,0) in the path corresponds to the dynamic item's center.
  UIBezierPath get collisionBoundingPath {
    objc.checkOsVersionInternal('UIView.collisionBoundingPath', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_collisionBoundingPath)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundingPath');
    }
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_collisionBoundingPath);
    return UIBezierPath.castFromPointer($ret, retain: true, release: true);
  }

  /// The collision type represents how the dynamics system will evaluate collisions with
  /// respect to the dynamic item. defaults to UIDynamicItemCollisionBoundsTypeRectangle
  UIDynamicItemCollisionBoundsType get collisionBoundsType {
    objc.checkOsVersionInternal('UIView.collisionBoundsType', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_collisionBoundsType)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'collisionBoundsType');
    }
    final $ret = _objc_msgSend_k9iunc(this.ref.pointer, _sel_collisionBoundsType);
    return UIDynamicItemCollisionBoundsType.fromValue($ret);
  }

  /// convertPoint:fromCoordinateSpace:
  objc.CGPoint convertPoint(objc.CGPoint point, {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_fromCoordinateSpace_,
            point,
            fromCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertPoint:toCoordinateSpace:
  objc.CGPoint convertPoint$1(objc.CGPoint point, {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertPoint:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_3l1tu1Stret(
            $ptr,
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_3l1tu1(
            this.ref.pointer,
            _sel_convertPoint_toCoordinateSpace_,
            point,
            toCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// convertRect:fromCoordinateSpace:
  objc.CGRect convertRect(objc.CGRect rect, {required UICoordinateSpace fromCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:fromCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_fromCoordinateSpace_,
            rect,
            fromCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// convertRect:toCoordinateSpace:
  objc.CGRect convertRect$1(objc.CGRect rect, {required UICoordinateSpace toCoordinateSpace}) {
    objc.checkOsVersionInternal('UIView.convertRect:toCoordinateSpace:', iOS: (false, (8, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_2olghrStret(
            $ptr,
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_2olghr(
            this.ref.pointer,
            _sel_convertRect_toCoordinateSpace_,
            rect,
            toCoordinateSpace.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// The coordinate space of the focus items contained in this container. The focus items returned by focusItemsInRect: should report their frames in this coordinate space.
  /// If you are implementing this protocol, you may find it convenient to return the UIScreen as your coordinate space, and ensure that your contained items report their frames in screen space.
  /// Similarly, you might find that your focus items' containing UIView or UIWindow is the most convenient coordinate space to use.
  /// You may also choose to implement your own object that conforms to UICoordinateSpace, if that is the most natural solution for your architecture.
  UICoordinateSpace get coordinateSpace {
    objc.checkOsVersionInternal('UIView.coordinateSpace', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_coordinateSpace);
    return UICoordinateSpace.castFromPointer($ret, retain: true, release: true);
  }

  /// Called whenever this focus item is hinting to the user a focus movement might occur.
  /// The provided object is mutated by the focus engine whenever the user's finger moves.
  void didHintFocusMovement(UIFocusMovementHint hint) {
    objc.checkOsVersionInternal('UIView.didHintFocusMovement:', iOS: (false, (12, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_didHintFocusMovement_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'didHintFocusMovement:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_didHintFocusMovement_, hint.ref.pointer);
  }

  /// Called when the screens focused item has been updated to a new item. Use the animation coordinator to schedule focus-related animations in response to the update.
  void didUpdateFocusInContext(
    UIFocusUpdateContext context, {
    required UIFocusAnimationCoordinator withAnimationCoordinator,
  }) {
    objc.checkOsVersionInternal('UIView.didUpdateFocusInContext:withAnimationCoordinator:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_didUpdateFocusInContext_withAnimationCoordinator_,
      context.ref.pointer,
      withAnimationCoordinator.ref.pointer,
    );
  }

  /// displayLayer:
  void displayLayer(CALayer layer) {
    objc.checkOsVersionInternal('UIView.displayLayer:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_displayLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'displayLayer:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_displayLayer_, layer.ref.pointer);
  }

  /// drawLayer:inContext:
  void drawLayer(CALayer layer, {required ffi.Pointer<CGContext> inContext}) {
    objc.checkOsVersionInternal('UIView.drawLayer:inContext:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_drawLayer_inContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'drawLayer:inContext:');
    }
    _objc_msgSend_a4xp11(this.ref.pointer, _sel_drawLayer_inContext_, layer.ref.pointer, inContext);
  }

  /// effectiveUserInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get effectiveUserInterfaceLayoutDirection {
    objc.checkOsVersionInternal('UIView.effectiveUserInterfaceLayoutDirection', iOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_qj4fey(this.ref.pointer, _sel_effectiveUserInterfaceLayoutDirection);
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// Describes a visual effect to apply when this item is focused. If this property is nil no effect will be applied when this view becomes focused.
  UIFocusEffect? get focusEffect {
    objc.checkOsVersionInternal('UIView.focusEffect', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusEffect);
    return $ret.address == 0 ? null : UIFocusEffect.castFromPointer($ret, retain: true, release: true);
  }

  /// The identifier of the focus group that this view belongs to. If this is nil, subviews inherit their superview's focus group.
  objc.NSString? get focusGroupIdentifier {
    objc.checkOsVersionInternal('UIView.focusGroupIdentifier', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusGroupIdentifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// The priority this item has in its focus group. The higher the priority, the more likely it is to get picked when focus moves into this group.
  /// Note: this method can only be used to increase an item's priority, not decrease it. For example if an item is currently selected, the actual priority of this item will be determined by MAX(focusGroupPriority, UIFocusGroupPrioritySelected).
  int get focusGroupPriority {
    objc.checkOsVersionInternal('UIView.focusGroupPriority', iOS: (false, (15, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_focusGroupPriority);
  }

  /// The container of any child focus items in this focus environment, or nil if no container exists.
  UIFocusItemContainer? get focusItemContainer {
    objc.checkOsVersionInternal('UIView.focusItemContainer', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focusItemContainer);
    return $ret.address == 0 ? null : UIFocusItemContainer.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns an array of all focus items within this container that intersect with the provided rect. `rect` is expressed in `coordinateSpace`.
  objc.NSArray focusItemsInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UIView.focusItemsInRect:', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.pointer, _sel_focusItemsInRect_, rect);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// The geometric frame of this item, represented in the `coordinateSpace` of the UIFocusItemContainer in which it is contained.
  objc.CGRect get frame {
    objc.checkOsVersionInternal('UIView.frame', iOS: (false, (12, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_frame)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_frame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// init
  UIView init() {
    objc.checkOsVersionInternal('UIView.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIView? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UIView initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIView.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIView.castFromPointer($ret, retain: false, release: true);
  }

  /// isFocused
  bool get isFocused {
    objc.checkOsVersionInternal('UIView.isFocused', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFocused);
  }

  /// If this returns YES, the focus item is considered transparent in terms of occlusion. Items that are behind it are focusable.
  /// This value is ignored when the item is focusable, in which case the item is never considered transparent.
  bool get isTransparentFocusItem {
    objc.checkOsVersionInternal('UIView.isTransparentFocusItem', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_isTransparentFocusItem)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'isTransparentFocusItem');
    }
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTransparentFocusItem);
  }

  /// isUserInteractionEnabled
  bool get isUserInteractionEnabled {
    objc.checkOsVersionInternal('UIView.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// layer
  CALayer get layer {
    objc.checkOsVersionInternal('UIView.layer', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_layer);
    return CALayer.castFromPointer($ret, retain: true, release: true);
  }

  /// layerWillDraw:
  void layerWillDraw(CALayer layer) {
    objc.checkOsVersionInternal('UIView.layerWillDraw:', iOS: (false, (10, 0, 0)), macOS: (false, (10, 12, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_layerWillDraw_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layerWillDraw:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_layerWillDraw_, layer.ref.pointer);
  }

  /// layoutSublayersOfLayer:
  void layoutSublayersOfLayer(CALayer layer) {
    objc.checkOsVersionInternal(
      'UIView.layoutSublayersOfLayer:',
      iOS: (false, (10, 0, 0)),
      macOS: (false, (10, 12, 0)),
    );
    if (!objc.respondsToSelector(this.ref.pointer, _sel_layoutSublayersOfLayer_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'layoutSublayersOfLayer:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_layoutSublayersOfLayer_, layer.ref.pointer);
  }

  /// The parent focus environment of this environment, or nil if no parent exists.
  /// NOTE: If you implement this method, you must return a non-nil value for parent focus environment, otherwise your focus environment will not participate in focus interactions.
  UIFocusEnvironment? get parentFocusEnvironment {
    objc.checkOsVersionInternal('UIView.parentFocusEnvironment', iOS: (false, (12, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_parentFocusEnvironment);
    return $ret.address == 0 ? null : UIFocusEnvironment.castFromPointer($ret, retain: true, release: true);
  }

  /// The preferred focus environments define where to search for the default focused item in an environment, such as when focus updates programmatically.
  /// Starting from the target environment, each preferred focus environment is recursively searched in the order of the array until an eligible, focusable item is found.
  /// Preferred focus environments can include focusable and non-focusable items, in addition to non-item environments. Returning an empty array is equivalent to returning an array containing only 'self'.
  objc.NSArray get preferredFocusEnvironments {
    objc.checkOsVersionInternal('UIView.preferredFocusEnvironments', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusEnvironments);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredFocusedView
  UIView? get preferredFocusedView {
    objc.checkOsVersionInternal('UIView.preferredFocusedView', iOS: (false, (9, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_preferredFocusedView)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'preferredFocusedView');
    }
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredFocusedView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// semanticContentAttribute
  UISemanticContentAttribute get semanticContentAttribute {
    objc.checkOsVersionInternal('UIView.semanticContentAttribute', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_i2u4x4(this.ref.pointer, _sel_semanticContentAttribute);
    return UISemanticContentAttribute.fromValue($ret);
  }

  /// setCenter:
  set center(objc.CGPoint value) {
    _objc_msgSend_iy8iz6(this.ref.pointer, _sel_setCenter_, value);
  }

  /// Describes a visual effect to apply when this item is focused. If this property is nil no effect will be applied when this view becomes focused.
  set focusEffect(UIFocusEffect? value) {
    objc.checkOsVersionInternal('UIView.setFocusEffect:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusEffect_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The identifier of the focus group that this view belongs to. If this is nil, subviews inherit their superview's focus group.
  set focusGroupIdentifier(objc.NSString? value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupIdentifier:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFocusGroupIdentifier_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The priority this item has in its focus group. The higher the priority, the more likely it is to get picked when focus moves into this group.
  /// Note: this method can only be used to increase an item's priority, not decrease it. For example if an item is currently selected, the actual priority of this item will be determined by MAX(focusGroupPriority, UIFocusGroupPrioritySelected).
  set focusGroupPriority(int value) {
    objc.checkOsVersionInternal('UIView.setFocusGroupPriority:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setFocusGroupPriority_, value);
  }

  /// Marks this environment as needing a focus update, which if accepted will attempt to reset focus to this environment, or one of its preferred focus environments, on the next update cycle. If this environment does not currently contain the focused item, then calling this method has no effect. If a parent of this environment is also requesting focus, then this environment's request is rejected in favor of the parent's.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] requestFocusUpdateToEnvironment:self]`;
  void setNeedsFocusUpdate() {
    objc.checkOsVersionInternal('UIView.setNeedsFocusUpdate', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setNeedsFocusUpdate);
  }

  /// setSemanticContentAttribute:
  set semanticContentAttribute(UISemanticContentAttribute value) {
    objc.checkOsVersionInternal('UIView.setSemanticContentAttribute:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_162qwxu(this.ref.pointer, _sel_setSemanticContentAttribute_, value.value);
  }

  /// setTag:
  set tag(int value) {
    objc.checkOsVersionInternal('UIView.setTag:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setTag_, value);
  }

  /// setTransform:
  set transform(CGAffineTransform value) {
    _objc_msgSend_qgt66z(this.ref.pointer, _sel_setTransform_, value);
  }

  /// setUserInteractionEnabled:
  set isUserInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIView.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// Asks whether the system should allow a focus update to occur.
  bool shouldUpdateFocusInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIView.shouldUpdateFocusInContext:', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_shouldUpdateFocusInContext_, context.ref.pointer);
  }

  /// Specifies an identifier corresponding to a sound that should be played for a focus update.
  /// Return UIFocusSoundIdentifierNone to opt out of sounds, UIFocusSoundIdentifierDefault for the system
  /// default sounds, a previously registered identifier for a custom sound, or nil to defer the decision
  /// to the parent.
  objc.NSString? soundIdentifierForFocusUpdateInContext(UIFocusUpdateContext context) {
    objc.checkOsVersionInternal('UIView.soundIdentifierForFocusUpdateInContext:', iOS: (true, null));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_soundIdentifierForFocusUpdateInContext_)) {
      throw objc.UnimplementedOptionalMethodException('UIView', 'soundIdentifierForFocusUpdateInContext:');
    }
    final $ret = _objc_msgSend_1sotr3r(
      this.ref.pointer,
      _sel_soundIdentifierForFocusUpdateInContext_,
      context.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// tag
  int get tag {
    objc.checkOsVersionInternal('UIView.tag', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_tag);
  }

  /// traitCollection
  UITraitCollection get traitCollection {
    objc.checkOsVersionInternal('UIView.traitCollection', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_traitCollection);
    return UITraitCollection.castFromPointer($ret, retain: true, release: true);
  }

  /// ! To be overridden as needed to provide custom behavior when the environment's traits change.
  void traitCollectionDidChange(UITraitCollection? previousTraitCollection) {
    objc.checkOsVersionInternal('UIView.traitCollectionDidChange:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_traitCollectionDidChange_,
      previousTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// transform
  CGAffineTransform get transform {
    final $ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_5qswvjStret($ptr, this.ref.pointer, _sel_transform)
        : $ptr.ref = _objc_msgSend_5qswvj(this.ref.pointer, _sel_transform);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<CGAffineTransform>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<CGAffineTransform>($finalizable);
  }

  /// Forces focus to be updated immediately. If there is an environment that has requested a focus update via -setNeedsFocusUpdate, and the request was accepted, then focus will be updated to that environment or one of its preferred focus environments.
  /// NOTE: If you provide your own implementation, it must call `[[UIFocusSystem focusSystemForEnvironment:self] updateFocusIfNeeded];`.
  void updateFocusIfNeeded() {
    objc.checkOsVersionInternal('UIView.updateFocusIfNeeded', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_updateFocusIfNeeded);
  }
}

late final _sel_inputView = objc.registerName("inputView");
late final _sel_inputAccessoryView = objc.registerName("inputAccessoryView");

/// WARNING: UITextInputAssistantItem is a stub. To generate bindings for this class, include
/// UITextInputAssistantItem in your config's objc-interfaces list.
///
/// UITextInputAssistantItem
class UITextInputAssistantItem extends objc.NSObject {
  UITextInputAssistantItem._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputAssistantItem', iOS: (false, (9, 0, 0)));
  }

  /// Constructs a [UITextInputAssistantItem] that points to the same underlying object as [other].
  UITextInputAssistantItem.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputAssistantItem] that wraps the given raw object pointer.
  UITextInputAssistantItem.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_inputAssistantItem = objc.registerName("inputAssistantItem");

/// WARNING: UIInputViewController is a stub. To generate bindings for this class, include
/// UIInputViewController in your config's objc-interfaces list.
///
/// UIInputViewController
class UIInputViewController extends objc.ObjCObjectBase {
  UIInputViewController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIInputViewController] that points to the same underlying object as [other].
  UIInputViewController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIInputViewController] that wraps the given raw object pointer.
  UIInputViewController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_inputViewController = objc.registerName("inputViewController");
late final _sel_inputAccessoryViewController = objc.registerName("inputAccessoryViewController");

/// WARNING: UITextInputMode is a stub. To generate bindings for this class, include
/// UITextInputMode in your config's objc-interfaces list.
///
/// UITextInputMode
class UITextInputMode extends objc.NSObject implements objc.NSSecureCoding {
  UITextInputMode._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextInputMode', iOS: (false, (4, 2, 0)));
  }

  /// Constructs a [UITextInputMode] that points to the same underlying object as [other].
  UITextInputMode.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputMode] that wraps the given raw object pointer.
  UITextInputMode.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_textInputMode = objc.registerName("textInputMode");
late final _sel_textInputContextIdentifier = objc.registerName("textInputContextIdentifier");
late final _sel_clearTextInputContextIdentifier_ = objc.registerName("clearTextInputContextIdentifier:");
late final _sel_reloadInputViews = objc.registerName("reloadInputViews");

/// UIResponderInputViewAdditions
extension UIResponderInputViewAdditions on UIResponder {
  /// inputAccessoryView
  UIView? get inputAccessoryView {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryView', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAccessoryView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// inputAccessoryViewController
  UIInputViewController? get inputAccessoryViewController {
    objc.checkOsVersionInternal('UIResponder.inputAccessoryViewController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAccessoryViewController);
    return $ret.address == 0 ? null : UIInputViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// This method is for clients that wish to put buttons on the Shortcuts Bar, shown on top of the keyboard.
  /// You may modify the returned inputAssistantItem to add to or replace the existing items on the bar.
  /// Modifications made to the returned UITextInputAssistantItem are reflected automatically.
  /// This method should not be overridden. Goes up the responder chain.
  UITextInputAssistantItem get inputAssistantItem {
    objc.checkOsVersionInternal('UIResponder.inputAssistantItem', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputAssistantItem);
    return UITextInputAssistantItem.castFromPointer($ret, retain: true, release: true);
  }

  /// inputView
  UIView? get inputView {
    objc.checkOsVersionInternal('UIResponder.inputView', iOS: (false, (3, 2, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputView);
    return $ret.address == 0 ? null : UIView.castFromPointer($ret, retain: true, release: true);
  }

  /// inputViewController
  UIInputViewController? get inputViewController {
    objc.checkOsVersionInternal('UIResponder.inputViewController', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputViewController);
    return $ret.address == 0 ? null : UIInputViewController.castFromPointer($ret, retain: true, release: true);
  }

  /// reloadInputViews
  void reloadInputViews() {
    objc.checkOsVersionInternal('UIResponder.reloadInputViews', iOS: (false, (3, 2, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_reloadInputViews);
  }

  /// textInputContextIdentifier
  objc.NSString? get textInputContextIdentifier {
    objc.checkOsVersionInternal('UIResponder.textInputContextIdentifier', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textInputContextIdentifier);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// textInputMode
  UITextInputMode? get textInputMode {
    objc.checkOsVersionInternal('UIResponder.textInputMode', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textInputMode);
    return $ret.address == 0 ? null : UITextInputMode.castFromPointer($ret, retain: true, release: true);
  }

  /// clearTextInputContextIdentifier:
  static void clearTextInputContextIdentifier(objc.NSString identifier) {
    objc.checkOsVersionInternal('UIResponder.clearTextInputContextIdentifier:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_xtuoz7(_class_UIResponder, _sel_clearTextInputContextIdentifier_, identifier.ref.pointer);
  }
}

late final _sel_userActivity = objc.registerName("userActivity");
late final _sel_setUserActivity_ = objc.registerName("setUserActivity:");
late final _sel_updateUserActivityState_ = objc.registerName("updateUserActivityState:");
late final _sel_restoreUserActivityState_ = objc.registerName("restoreUserActivityState:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSUserActivity {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> listener(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> blocking(
    void Function(ffi.Pointer<ffi.Void>, NSUserActivity) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
          fn(arg0, NSUserActivity.castFromPointer(arg1, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_18v1jvf(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
  ) => (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSUserActivity$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, NSUserActivity)> {
  void call(ffi.Pointer<ffi.Void> arg0, NSUserActivity arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
          )
        >
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0, arg1.ref.pointer);
}

/// ActivityContinuation
extension ActivityContinuation on UIResponder {
  /// restoreUserActivityState:
  void restoreUserActivityState(NSUserActivity userActivity) {
    objc.checkOsVersionInternal('UIResponder.restoreUserActivityState:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_restoreUserActivityState_, userActivity.ref.pointer);
  }

  /// setUserActivity:
  set userActivity(NSUserActivity? value) {
    objc.checkOsVersionInternal('UIResponder.setUserActivity:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setUserActivity_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// updateUserActivityState:
  void updateUserActivityState(NSUserActivity activity) {
    objc.checkOsVersionInternal('UIResponder.updateUserActivityState:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_updateUserActivityState_, activity.ref.pointer);
  }

  /// userActivity
  NSUserActivity? get userActivity {
    objc.checkOsVersionInternal('UIResponder.userActivity', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_userActivity);
    return $ret.address == 0 ? null : NSUserActivity.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_captureTextFromCamera_ = objc.registerName("captureTextFromCamera:");

/// UICaptureTextFromCameraSupporting
extension UICaptureTextFromCameraSupporting on UIResponder {
  /// captureTextFromCamera:
  void captureTextFromCamera(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.captureTextFromCamera:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_captureTextFromCamera_, sender?.ref.pointer ?? ffi.nullptr);
  }
}

/// UIResponder
class UIResponder extends objc.NSObject implements UIResponderStandardEditActions {
  UIResponder._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIResponder', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIResponder] that points to the same underlying object as [other].
  UIResponder.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIResponder] that wraps the given raw object pointer.
  UIResponder.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIResponder].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIResponder);
  }

  /// alloc
  static UIResponder alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_alloc);
    return UIResponder.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIResponder allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIResponder, _sel_allocWithZone_, zone);
    return UIResponder.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIResponder new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIResponder, _sel_new);
    return UIResponder.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIResponder constructed with the default `new` method.
  factory UIResponder() => new$();
}

extension UIResponder$Methods on UIResponder {
  /// becomeFirstResponder
  bool becomeFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.becomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_becomeFirstResponder);
  }

  /// buildMenuWithBuilder:
  void buildMenuWithBuilder(UIMenuBuilder builder) {
    objc.checkOsVersionInternal('UIResponder.buildMenuWithBuilder:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_buildMenuWithBuilder_, builder.ref.pointer);
  }

  /// canBecomeFirstResponder
  bool get canBecomeFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canBecomeFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canBecomeFirstResponder);
  }

  /// canPerformAction:withSender:
  bool canPerformAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.canPerformAction:withSender:', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_1f04296(
      this.ref.pointer,
      _sel_canPerformAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// canResignFirstResponder
  bool get canResignFirstResponder {
    objc.checkOsVersionInternal('UIResponder.canResignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_canResignFirstResponder);
  }

  /// copy:
  void copy$1(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.copy:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_copy_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'copy:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_copy_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// cut:
  void cut(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.cut:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_cut_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'cut:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cut_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// decreaseSize:
  void decreaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.decreaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_decreaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'decreaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_decreaseSize_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// delete:
  void delete(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.delete:', iOS: (false, (3, 2, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_delete_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'delete:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_delete_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// editingInteractionConfiguration
  UIEditingInteractionConfiguration get editingInteractionConfiguration {
    objc.checkOsVersionInternal('UIResponder.editingInteractionConfiguration', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_15pfzxv(this.ref.pointer, _sel_editingInteractionConfiguration);
    return UIEditingInteractionConfiguration.fromValue($ret);
  }

  /// increaseSize:
  void increaseSize(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.increaseSize:', iOS: (false, (7, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_increaseSize_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'increaseSize:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_increaseSize_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// init
  UIResponder init() {
    objc.checkOsVersionInternal('UIResponder.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIResponder.castFromPointer($ret, retain: false, release: true);
  }

  /// isFirstResponder
  bool get isFirstResponder {
    objc.checkOsVersionInternal('UIResponder.isFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFirstResponder);
  }

  /// makeTextWritingDirectionLeftToRight:
  void makeTextWritingDirectionLeftToRight(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionLeftToRight:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_makeTextWritingDirectionLeftToRight_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionLeftToRight:');
    }
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_makeTextWritingDirectionLeftToRight_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// makeTextWritingDirectionRightToLeft:
  void makeTextWritingDirectionRightToLeft(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.makeTextWritingDirectionRightToLeft:', iOS: (false, (5, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_makeTextWritingDirectionRightToLeft_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'makeTextWritingDirectionRightToLeft:');
    }
    _objc_msgSend_xtuoz7(
      this.ref.pointer,
      _sel_makeTextWritingDirectionRightToLeft_,
      sender?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionBegan:withEvent:
  void motionBegan(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionBegan:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionBegan_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionCancelled:withEvent:
  void motionCancelled(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionCancelled:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionCancelled_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// motionEnded:withEvent:
  void motionEnded(UIEventSubtype motion, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.motionEnded:withEvent:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_pov02z(
      this.ref.pointer,
      _sel_motionEnded_withEvent_,
      motion.value,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// nextResponder
  UIResponder? get nextResponder {
    objc.checkOsVersionInternal('UIResponder.nextResponder', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_nextResponder);
    return $ret.address == 0 ? null : UIResponder.castFromPointer($ret, retain: true, release: true);
  }

  /// paste:
  void paste(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.paste:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_paste_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'paste:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_paste_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndGo:
  void pasteAndGo(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndGo:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndGo_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndGo:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndGo_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndMatchStyle:
  void pasteAndMatchStyle(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndMatchStyle:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndMatchStyle_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndMatchStyle:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndMatchStyle_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pasteAndSearch:
  void pasteAndSearch(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.pasteAndSearch:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_pasteAndSearch_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'pasteAndSearch:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_pasteAndSearch_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// pressesBegan:withEvent:
  void pressesBegan(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesBegan:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesBegan_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesCancelled:withEvent:
  void pressesCancelled(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesCancelled:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesCancelled_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesChanged:withEvent:
  void pressesChanged(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesChanged:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesChanged_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// pressesEnded:withEvent:
  void pressesEnded(objc.NSSet presses, {UIPressesEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.pressesEnded:withEvent:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_pressesEnded_withEvent_,
      presses.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// print:
  void print(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.print:', iOS: (false, (15, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_print_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'print:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_print_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// remoteControlReceivedWithEvent:
  void remoteControlReceivedWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal('UIResponder.remoteControlReceivedWithEvent:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_remoteControlReceivedWithEvent_, event?.ref.pointer ?? ffi.nullptr);
  }

  /// resignFirstResponder
  bool resignFirstResponder() {
    objc.checkOsVersionInternal('UIResponder.resignFirstResponder', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_resignFirstResponder);
  }

  /// select:
  void select(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.select:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_select_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'select:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_select_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// selectAll:
  void selectAll(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.selectAll:', iOS: (false, (3, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_selectAll_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'selectAll:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_selectAll_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// targetForAction:withSender:
  objc.ObjCObjectBase? targetForAction(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? withSender}) {
    objc.checkOsVersionInternal('UIResponder.targetForAction:withSender:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_gx50so(
      this.ref.pointer,
      _sel_targetForAction_withSender_,
      action,
      withSender?.ref.pointer ?? ffi.nullptr,
    );
    return $ret.address == 0 ? null : objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// toggleBoldface:
  void toggleBoldface(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleBoldface:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleBoldface_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleBoldface:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleBoldface_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleItalics:
  void toggleItalics(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleItalics:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleItalics_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleItalics:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleItalics_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// toggleUnderline:
  void toggleUnderline(objc.ObjCObjectBase? sender) {
    objc.checkOsVersionInternal('UIResponder.toggleUnderline:', iOS: (false, (6, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_toggleUnderline_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'toggleUnderline:');
    }
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_toggleUnderline_, sender?.ref.pointer ?? ffi.nullptr);
  }

  /// touchesBegan:withEvent:
  void touchesBegan(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesBegan:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesBegan_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesCancelled:withEvent:
  void touchesCancelled(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesCancelled:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesCancelled_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEnded:withEvent:
  void touchesEnded(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesEnded:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesEnded_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// touchesEstimatedPropertiesUpdated:
  void touchesEstimatedPropertiesUpdated(objc.NSSet touches) {
    objc.checkOsVersionInternal('UIResponder.touchesEstimatedPropertiesUpdated:', iOS: (false, (9, 1, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_touchesEstimatedPropertiesUpdated_, touches.ref.pointer);
  }

  /// touchesMoved:withEvent:
  void touchesMoved(objc.NSSet touches, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIResponder.touchesMoved:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_touchesMoved_withEvent_,
      touches.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// undoManager
  NSUndoManager? get undoManager {
    objc.checkOsVersionInternal('UIResponder.undoManager', iOS: (false, (3, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_undoManager);
    return $ret.address == 0 ? null : NSUndoManager.castFromPointer($ret, retain: true, release: true);
  }

  /// updateTextAttributesWithConversionHandler:
  void updateTextAttributesWithConversionHandler(
    objc.ObjCBlock<objc.NSDictionary Function(objc.NSDictionary)> conversionHandler,
  ) {
    objc.checkOsVersionInternal('UIResponder.updateTextAttributesWithConversionHandler:', iOS: (false, (13, 0, 0)));
    if (!objc.respondsToSelector(this.ref.pointer, _sel_updateTextAttributesWithConversionHandler_)) {
      throw objc.UnimplementedOptionalMethodException('UIResponder', 'updateTextAttributesWithConversionHandler:');
    }
    _objc_msgSend_f167m6(
      this.ref.pointer,
      _sel_updateTextAttributesWithConversionHandler_,
      conversionHandler.ref.pointer,
    );
  }

  /// validateCommand:
  void validateCommand(UICommand command) {
    objc.checkOsVersionInternal('UIResponder.validateCommand:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_validateCommand_, command.ref.pointer);
  }
}

/// WARNING: UIScene is a stub. To generate bindings for this class, include
/// UIScene in your config's objc-interfaces list.
///
/// UIScene
class UIScene extends UIResponder {
  UIScene._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIScene', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIScene] that points to the same underlying object as [other].
  UIScene.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIScene] that wraps the given raw object pointer.
  UIScene.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

final class __CVBuffer extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
    1 => kCGImagePropertyOrientationUp,
    2 => kCGImagePropertyOrientationUpMirrored,
    3 => kCGImagePropertyOrientationDown,
    4 => kCGImagePropertyOrientationDownMirrored,
    5 => kCGImagePropertyOrientationLeftMirrored,
    6 => kCGImagePropertyOrientationRight,
    7 => kCGImagePropertyOrientationRightMirrored,
    8 => kCGImagePropertyOrientationLeft,
    _ => throw ArgumentError('Unknown value for CGImagePropertyOrientation: $value'),
  };
}

/// Construction methods for `objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>`.
abstract final class ObjCBlock_CGRect_ffiInt_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<objc.CGRect Function(ffi.Int arg0, objc.CGRect arg1)>> ptr,
  ) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> fromFunction(
    objc.CGRect Function(int, objc.CGRect) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>(
    objc.newClosureBlock(_closureCallable, (int arg0, objc.CGRect arg1) => fn(arg0, arg1), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static objc.CGRect _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, int arg0, objc.CGRect arg1) => block
      .ref
      .target
      .cast<ffi.NativeFunction<objc.CGRect Function(ffi.Int arg0, objc.CGRect arg1)>>()
      .asFunction<objc.CGRect Function(int, objc.CGRect)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int, objc.CGRect)>(
        _fnPtrTrampoline,
      ).cast();
  static objc.CGRect _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, int arg0, objc.CGRect arg1) =>
      (objc.getBlockClosure(block) as objc.CGRect Function(int, objc.CGRect))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int, objc.CGRect)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)>`.
extension ObjCBlock_CGRect_ffiInt_CGRect$CallExtension on objc.ObjCBlock<objc.CGRect Function(ffi.Int, objc.CGRect)> {
  objc.CGRect call(int arg0, objc.CGRect arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Int arg0, objc.CGRect arg1)>
      >()
      .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, int, objc.CGRect)>()(ref.pointer, arg0, arg1);
}

sealed class UIFontDescriptorSymbolicTraits {
  static const UIFontDescriptorTraitItalic = 1;
  static const UIFontDescriptorTraitBold = 2;
  static const UIFontDescriptorTraitExpanded = 32;
  static const UIFontDescriptorTraitCondensed = 64;
  static const UIFontDescriptorTraitMonoSpace = 1024;
  static const UIFontDescriptorTraitVertical = 2048;
  static const UIFontDescriptorTraitUIOptimized = 4096;
  static const UIFontDescriptorTraitTightLeading = 32768;
  static const UIFontDescriptorTraitLooseLeading = 65536;
  static const UIFontDescriptorClassMask = -268435456;
  static const UIFontDescriptorClassUnknown = 0;
  static const UIFontDescriptorClassOldStyleSerifs = 268435456;
  static const UIFontDescriptorClassTransitionalSerifs = 536870912;
  static const UIFontDescriptorClassModernSerifs = 805306368;
  static const UIFontDescriptorClassClarendonSerifs = 1073741824;
  static const UIFontDescriptorClassSlabSerifs = 1342177280;
  static const UIFontDescriptorClassFreeformSerifs = 1879048192;
  static const UIFontDescriptorClassSansSerif = -2147483648;
  static const UIFontDescriptorClassOrnamentals = -1879048192;
  static const UIFontDescriptorClassScripts = -1610612736;
  static const UIFontDescriptorClassSymbolic = -1073741824;
}

/// WARNING: UIFontDescriptor is a stub. To generate bindings for this class, include
/// UIFontDescriptor in your config's objc-interfaces list.
///
/// UIFontDescriptor
class UIFontDescriptor extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIFontDescriptor._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFontDescriptor', iOS: (false, (7, 0, 0)));
  }

  /// Constructs a [UIFontDescriptor] that points to the same underlying object as [other].
  UIFontDescriptor.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFontDescriptor] that wraps the given raw object pointer.
  UIFontDescriptor.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _class_UIFont = objc.getClass("UIFont");
late final _sel_preferredFontForTextStyle_ = objc.registerName("preferredFontForTextStyle:");
late final _sel_preferredFontForTextStyle_compatibleWithTraitCollection_ = objc.registerName(
  "preferredFontForTextStyle:compatibleWithTraitCollection:",
);
late final _sel_fontWithName_size_ = objc.registerName("fontWithName:size:");
final _objc_msgSend_6plvbo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Double,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        double,
      )
    >();
late final _sel_familyNames = objc.registerName("familyNames");
late final _sel_fontNamesForFamilyName_ = objc.registerName("fontNamesForFamilyName:");
late final _sel_systemFontOfSize_ = objc.registerName("systemFontOfSize:");
late final _sel_boldSystemFontOfSize_ = objc.registerName("boldSystemFontOfSize:");
late final _sel_italicSystemFontOfSize_ = objc.registerName("italicSystemFontOfSize:");
late final _sel_systemFontOfSize_weight_ = objc.registerName("systemFontOfSize:weight:");
late final _sel_monospacedDigitSystemFontOfSize_weight_ = objc.registerName("monospacedDigitSystemFontOfSize:weight:");
late final _sel_monospacedSystemFontOfSize_weight_ = objc.registerName("monospacedSystemFontOfSize:weight:");
late final _sel_familyName = objc.registerName("familyName");
late final _sel_fontName = objc.registerName("fontName");
late final _sel_pointSize = objc.registerName("pointSize");
late final _sel_ascender = objc.registerName("ascender");
late final _sel_descender = objc.registerName("descender");
late final _sel_capHeight = objc.registerName("capHeight");
late final _sel_xHeight = objc.registerName("xHeight");
late final _sel_lineHeight = objc.registerName("lineHeight");
late final _sel_leading = objc.registerName("leading");
late final _sel_fontWithSize_ = objc.registerName("fontWithSize:");
late final _sel_fontWithDescriptor_size_ = objc.registerName("fontWithDescriptor:size:");
late final _sel_fontDescriptor = objc.registerName("fontDescriptor");
late final _sel_self = objc.registerName("self");
late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_labelFontSize = objc.registerName("labelFontSize");
late final _sel_buttonFontSize = objc.registerName("buttonFontSize");
late final _sel_smallSystemFontSize = objc.registerName("smallSystemFontSize");
late final _sel_systemFontSize = objc.registerName("systemFontSize");
late final _sel_defaultFontSize = objc.registerName("defaultFontSize");
late final _sel_systemMinimumFontSize = objc.registerName("systemMinimumFontSize");

/// UIFontSystemFonts
extension UIFontSystemFonts on UIFont {
  /// buttonFontSize
  static double getButtonFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_buttonFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_buttonFontSize);
  }

  /// defaultFontSize
  static double getDefaultFontSize() {
    objc.checkOsVersionInternal('UIFont.defaultFontSize', iOS: (true, null), macOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_defaultFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_defaultFontSize);
  }

  /// labelFontSize
  static double getLabelFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_labelFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_labelFontSize);
  }

  /// smallSystemFontSize
  static double getSmallSystemFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_smallSystemFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_smallSystemFontSize);
  }

  /// systemFontSize
  static double getSystemFontSize() {
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_systemFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_systemFontSize);
  }

  /// systemMinimumFontSize
  static double getSystemMinimumFontSize() {
    objc.checkOsVersionInternal('UIFont.systemMinimumFontSize', iOS: (true, null), macOS: (true, null));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(_class_UIFont, _sel_systemMinimumFontSize)
        : _objc_msgSend_1ukqyt8(_class_UIFont, _sel_systemMinimumFontSize);
  }
}

/// UIFont
class UIFont extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIFont._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIFont', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIFont] that points to the same underlying object as [other].
  UIFont.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIFont] that wraps the given raw object pointer.
  UIFont.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIFont].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIFont);
  }

  /// alloc
  static UIFont alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIFont, _sel_alloc);
    return UIFont.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIFont allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIFont, _sel_allocWithZone_, zone);
    return UIFont.castFromPointer($ret, retain: false, release: true);
  }

  /// boldSystemFontOfSize:
  static UIFont boldSystemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.boldSystemFontOfSize:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_boldSystemFontOfSize_, fontSize);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// familyNames
  static objc.NSArray getFamilyNames() {
    objc.checkOsVersionInternal('UIFont.familyNames', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIFont, _sel_familyNames);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// fontNamesForFamilyName:
  static objc.NSArray fontNamesForFamilyName(objc.NSString familyName) {
    objc.checkOsVersionInternal('UIFont.fontNamesForFamilyName:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIFont, _sel_fontNamesForFamilyName_, familyName.ref.pointer);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// fontWithDescriptor:size:
  static UIFont fontWithDescriptor(UIFontDescriptor descriptor, {required double size}) {
    objc.checkOsVersionInternal('UIFont.fontWithDescriptor:size:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(_class_UIFont, _sel_fontWithDescriptor_size_, descriptor.ref.pointer, size);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// fontWithName:size:
  static UIFont? fontWithName(objc.NSString fontName, {required double size}) {
    objc.checkOsVersionInternal('UIFont.fontWithName:size:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_6plvbo(_class_UIFont, _sel_fontWithName_size_, fontName.ref.pointer, size);
    return $ret.address == 0 ? null : UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// italicSystemFontOfSize:
  static UIFont italicSystemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.italicSystemFontOfSize:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_italicSystemFontOfSize_, fontSize);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// monospacedDigitSystemFontOfSize:weight:
  static UIFont monospacedDigitSystemFontOfSize(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.monospacedDigitSystemFontOfSize:weight:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_monospacedDigitSystemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// monospacedSystemFontOfSize:weight:
  static UIFont monospacedSystemFontOfSize(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.monospacedSystemFontOfSize:weight:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_monospacedSystemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// new
  static UIFont new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIFont, _sel_new);
    return UIFont.castFromPointer($ret, retain: false, release: true);
  }

  /// preferredFontForTextStyle:
  static UIFont preferredFontForTextStyle(objc.NSString style) {
    objc.checkOsVersionInternal('UIFont.preferredFontForTextStyle:', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UIFont, _sel_preferredFontForTextStyle_, style.ref.pointer);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredFontForTextStyle:compatibleWithTraitCollection:
  static UIFont preferredFontForTextStyle$1(objc.NSString style, {UITraitCollection? compatibleWithTraitCollection}) {
    objc.checkOsVersionInternal(
      'UIFont.preferredFontForTextStyle:compatibleWithTraitCollection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UIFont,
      _sel_preferredFontForTextStyle_compatibleWithTraitCollection_,
      style.ref.pointer,
      compatibleWithTraitCollection?.ref.pointer ?? ffi.nullptr,
    );
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIFont, _sel_supportsSecureCoding);
  }

  /// systemFontOfSize:
  static UIFont systemFontOfSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.systemFontOfSize:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(_class_UIFont, _sel_systemFontOfSize_, fontSize);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// systemFontOfSize:weight:
  static UIFont systemFontOfSize$1(double fontSize, {required double weight}) {
    objc.checkOsVersionInternal('UIFont.systemFontOfSize:weight:', iOS: (false, (8, 2, 0)));
    final $ret = _objc_msgSend_1n2vn5t(_class_UIFont, _sel_systemFontOfSize_weight_, fontSize, weight);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of UIFont constructed with the default `new` method.
  factory UIFont() => new$();
}

extension UIFont$Methods on UIFont {
  /// ascender
  double get ascender {
    objc.checkOsVersionInternal('UIFont.ascender', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_ascender)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_ascender);
  }

  /// autorelease
  UIFont autorelease() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// capHeight
  double get capHeight {
    objc.checkOsVersionInternal('UIFont.capHeight', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_capHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_capHeight);
  }

  /// descender
  double get descender {
    objc.checkOsVersionInternal('UIFont.descender', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_descender)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_descender);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// familyName
  objc.NSString get familyName {
    objc.checkOsVersionInternal('UIFont.familyName', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_familyName);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// fontDescriptor
  UIFontDescriptor get fontDescriptor {
    objc.checkOsVersionInternal('UIFont.fontDescriptor', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fontDescriptor);
    return UIFontDescriptor.castFromPointer($ret, retain: true, release: true);
  }

  /// fontName
  objc.NSString get fontName {
    objc.checkOsVersionInternal('UIFont.fontName', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_fontName);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// fontWithSize:
  UIFont fontWithSize(double fontSize) {
    objc.checkOsVersionInternal('UIFont.fontWithSize:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_oa8mke(this.ref.pointer, _sel_fontWithSize_, fontSize);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UIFont init() {
    objc.checkOsVersionInternal('UIFont.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIFont.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIFont? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIFont.castFromPointer($ret, retain: false, release: true);
  }

  /// leading
  double get leading {
    objc.checkOsVersionInternal('UIFont.leading', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_leading)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_leading);
  }

  /// lineHeight
  double get lineHeight {
    objc.checkOsVersionInternal('UIFont.lineHeight', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_lineHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_lineHeight);
  }

  /// pointSize
  double get pointSize {
    objc.checkOsVersionInternal('UIFont.pointSize', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_pointSize)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_pointSize);
  }

  /// retain
  UIFont retain() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// self
  UIFont self() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// xHeight
  double get xHeight {
    objc.checkOsVersionInternal('UIFont.xHeight', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_xHeight)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_xHeight);
  }
}

enum UIUserInterfaceSizeClass {
  UIUserInterfaceSizeClassUnspecified(0),
  UIUserInterfaceSizeClassCompact(1),
  UIUserInterfaceSizeClassRegular(2);

  final int value;
  const UIUserInterfaceSizeClass(this.value);

  static UIUserInterfaceSizeClass fromValue(int value) => switch (value) {
    0 => UIUserInterfaceSizeClassUnspecified,
    1 => UIUserInterfaceSizeClassCompact,
    2 => UIUserInterfaceSizeClassRegular,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceSizeClass: $value'),
  };
}

enum UITraitEnvironmentLayoutDirection {
  UITraitEnvironmentLayoutDirectionUnspecified(-1),
  UITraitEnvironmentLayoutDirectionLeftToRight(0),
  UITraitEnvironmentLayoutDirectionRightToLeft(1);

  final int value;
  const UITraitEnvironmentLayoutDirection(this.value);

  static UITraitEnvironmentLayoutDirection fromValue(int value) => switch (value) {
    -1 => UITraitEnvironmentLayoutDirectionUnspecified,
    0 => UITraitEnvironmentLayoutDirectionLeftToRight,
    1 => UITraitEnvironmentLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for UITraitEnvironmentLayoutDirection: $value'),
  };
}

enum UIDisplayGamut {
  UIDisplayGamutUnspecified(-1),
  UIDisplayGamutSRGB(0),
  UIDisplayGamutP3(1);

  final int value;
  const UIDisplayGamut(this.value);

  static UIDisplayGamut fromValue(int value) => switch (value) {
    -1 => UIDisplayGamutUnspecified,
    0 => UIDisplayGamutSRGB,
    1 => UIDisplayGamutP3,
    _ => throw ArgumentError('Unknown value for UIDisplayGamut: $value'),
  };
}

enum UIAccessibilityContrast {
  UIAccessibilityContrastUnspecified(-1),
  UIAccessibilityContrastNormal(0),
  UIAccessibilityContrastHigh(1);

  final int value;
  const UIAccessibilityContrast(this.value);

  static UIAccessibilityContrast fromValue(int value) => switch (value) {
    -1 => UIAccessibilityContrastUnspecified,
    0 => UIAccessibilityContrastNormal,
    1 => UIAccessibilityContrastHigh,
    _ => throw ArgumentError('Unknown value for UIAccessibilityContrast: $value'),
  };
}

enum UILegibilityWeight {
  UILegibilityWeightUnspecified(-1),
  UILegibilityWeightRegular(0),
  UILegibilityWeightBold(1);

  final int value;
  const UILegibilityWeight(this.value);

  static UILegibilityWeight fromValue(int value) => switch (value) {
    -1 => UILegibilityWeightUnspecified,
    0 => UILegibilityWeightRegular,
    1 => UILegibilityWeightBold,
    _ => throw ArgumentError('Unknown value for UILegibilityWeight: $value'),
  };
}

enum UIUserInterfaceLevel {
  UIUserInterfaceLevelUnspecified(-1),
  UIUserInterfaceLevelBase(0),
  UIUserInterfaceLevelElevated(1);

  final int value;
  const UIUserInterfaceLevel(this.value);

  static UIUserInterfaceLevel fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceLevelUnspecified,
    0 => UIUserInterfaceLevelBase,
    1 => UIUserInterfaceLevelElevated,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceLevel: $value'),
  };
}

enum UIUserInterfaceActiveAppearance {
  UIUserInterfaceActiveAppearanceUnspecified(-1),
  UIUserInterfaceActiveAppearanceInactive(0),
  UIUserInterfaceActiveAppearanceActive(1);

  final int value;
  const UIUserInterfaceActiveAppearance(this.value);

  static UIUserInterfaceActiveAppearance fromValue(int value) => switch (value) {
    -1 => UIUserInterfaceActiveAppearanceUnspecified,
    0 => UIUserInterfaceActiveAppearanceInactive,
    1 => UIUserInterfaceActiveAppearanceActive,
    _ => throw ArgumentError('Unknown value for UIUserInterfaceActiveAppearance: $value'),
  };
}

/// WARNING: CAMediaTiming is a stub. To generate bindings for this class, include
/// CAMediaTiming in your config's objc-protocols list.
///
/// CAMediaTiming
interface class CAMediaTiming extends objc.ObjCProtocolBase {
  CAMediaTiming._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [CAMediaTiming] that points to the same underlying object as [other].
  CAMediaTiming.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CAMediaTiming] that wraps the given raw object pointer.
  CAMediaTiming.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

sealed class CAAutoresizingMask {
  static const kCALayerNotSizable = 0;
  static const kCALayerMinXMargin = 1;
  static const kCALayerWidthSizable = 2;
  static const kCALayerMaxXMargin = 4;
  static const kCALayerMinYMargin = 8;
  static const kCALayerHeightSizable = 16;
  static const kCALayerMaxYMargin = 32;
}

sealed class CAEdgeAntialiasingMask {
  static const kCALayerLeftEdge = 1;
  static const kCALayerRightEdge = 2;
  static const kCALayerBottomEdge = 4;
  static const kCALayerTopEdge = 8;
}

sealed class CACornerMask {
  static const kCALayerMinXMinYCorner = 1;
  static const kCALayerMaxXMinYCorner = 2;
  static const kCALayerMinXMaxYCorner = 4;
  static const kCALayerMaxXMaxYCorner = 8;
}

final class CAFrameRateRange extends ffi.Struct {
  @ffi.Float()
  external double minimum;

  @ffi.Float()
  external double maximum;

  @ffi.Float()
  external double preferred;
}

enum CAConstraintAttribute {
  kCAConstraintMinX(0),
  kCAConstraintMidX(1),
  kCAConstraintMaxX(2),
  kCAConstraintWidth(3),
  kCAConstraintMinY(4),
  kCAConstraintMidY(5),
  kCAConstraintMaxY(6),
  kCAConstraintHeight(7);

  final int value;
  const CAConstraintAttribute(this.value);

  static CAConstraintAttribute fromValue(int value) => switch (value) {
    0 => kCAConstraintMinX,
    1 => kCAConstraintMidX,
    2 => kCAConstraintMaxX,
    3 => kCAConstraintWidth,
    4 => kCAConstraintMinY,
    5 => kCAConstraintMidY,
    6 => kCAConstraintMaxY,
    7 => kCAConstraintHeight,
    _ => throw ArgumentError('Unknown value for CAConstraintAttribute: $value'),
  };
}

enum UITouchPhase {
  UITouchPhaseBegan(0),
  UITouchPhaseMoved(1),
  UITouchPhaseStationary(2),
  UITouchPhaseEnded(3),
  UITouchPhaseCancelled(4),
  UITouchPhaseRegionEntered(5),
  UITouchPhaseRegionMoved(6),
  UITouchPhaseRegionExited(7);

  final int value;
  const UITouchPhase(this.value);

  static UITouchPhase fromValue(int value) => switch (value) {
    0 => UITouchPhaseBegan,
    1 => UITouchPhaseMoved,
    2 => UITouchPhaseStationary,
    3 => UITouchPhaseEnded,
    4 => UITouchPhaseCancelled,
    5 => UITouchPhaseRegionEntered,
    6 => UITouchPhaseRegionMoved,
    7 => UITouchPhaseRegionExited,
    _ => throw ArgumentError('Unknown value for UITouchPhase: $value'),
  };
}

enum UIForceTouchCapability {
  UIForceTouchCapabilityUnknown(0),
  UIForceTouchCapabilityUnavailable(1),
  UIForceTouchCapabilityAvailable(2);

  final int value;
  const UIForceTouchCapability(this.value);

  static UIForceTouchCapability fromValue(int value) => switch (value) {
    0 => UIForceTouchCapabilityUnknown,
    1 => UIForceTouchCapabilityUnavailable,
    2 => UIForceTouchCapabilityAvailable,
    _ => throw ArgumentError('Unknown value for UIForceTouchCapability: $value'),
  };
}

enum UITouchType {
  UITouchTypeDirect(0),
  UITouchTypeIndirect(1),
  UITouchTypePencil(2),
  UITouchTypeIndirectPointer(3);

  static const UITouchTypeStylus = UITouchTypePencil;

  final int value;
  const UITouchType(this.value);

  static UITouchType fromValue(int value) => switch (value) {
    0 => UITouchTypeDirect,
    1 => UITouchTypeIndirect,
    2 => UITouchTypePencil,
    3 => UITouchTypeIndirectPointer,
    _ => throw ArgumentError('Unknown value for UITouchType: $value'),
  };

  @override
  String toString() {
    if (this == UITouchTypePencil) return "UITouchType.UITouchTypePencil, UITouchType.UITouchTypeStylus";
    return super.toString();
  }
}

sealed class UITouchProperties {
  static const UITouchPropertyForce = 1;
  static const UITouchPropertyAzimuth = 2;
  static const UITouchPropertyAltitude = 4;
  static const UITouchPropertyLocation = 8;
}

/// WARNING: UITouch is a stub. To generate bindings for this class, include
/// UITouch in your config's objc-interfaces list.
///
/// UITouch
class UITouch extends objc.NSObject {
  UITouch._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITouch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITouch] that points to the same underlying object as [other].
  UITouch.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITouch] that wraps the given raw object pointer.
  UITouch.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

sealed class UIFocusHeading {
  static const UIFocusHeadingNone = 0;
  static const UIFocusHeadingUp = 1;
  static const UIFocusHeadingDown = 2;
  static const UIFocusHeadingLeft = 4;
  static const UIFocusHeadingRight = 8;
  static const UIFocusHeadingNext = 16;
  static const UIFocusHeadingPrevious = 32;
  static const UIFocusHeadingFirst = 256;
  static const UIFocusHeadingLast = 512;
}

/// Construction methods for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
abstract final class ObjCBlock_UIMenu_NSArray {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIMenu? Function(objc.NSArray)> fromFunction(
    UIMenu? Function(objc.NSArray) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIMenu? Function(objc.NSArray)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(objc.NSArray.castFromPointer(arg0, retain: true, release: true))?.ref.retainAndAutorelease() ??
          ffi.nullptr,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<UIMenu? Function(objc.NSArray)>`.
extension ObjCBlock_UIMenu_NSArray$CallExtension on objc.ObjCBlock<UIMenu? Function(objc.NSArray)> {
  UIMenu? call(objc.NSArray arg0) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
              >()(ref.pointer, arg0.ref.pointer)
              .address ==
          0
      ? null
      : UIMenu.castFromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<objc.ObjCObject> arg0,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
              >()(ref.pointer, arg0.ref.pointer),
          retain: true,
          release: true,
        );
}

/// Construction methods for `objc.ObjCBlock<UIViewController? Function()>`.
abstract final class ObjCBlock_UIViewController {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<UIViewController? Function()> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<UIViewController? Function()>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<UIViewController? Function()> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>> ptr,
  ) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<UIViewController? Function()> fromFunction(
    UIViewController? Function() fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<UIViewController? Function()>(
    objc.newClosureBlock(_closureCallable, () => fn()?.ref.retainAndAutorelease() ?? ffi.nullptr, keepIsolateAlive),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObject> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>()
      .asFunction<ffi.Pointer<objc.ObjCObject> Function()>()();
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
        _fnPtrTrampoline,
      ).cast();
  static ffi.Pointer<objc.ObjCObject> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function())();
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<UIViewController? Function()>`.
extension ObjCBlock_UIViewController$CallExtension on objc.ObjCBlock<UIViewController? Function()> {
  UIViewController? call() =>
      ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
                ref.pointer,
              )
              .address ==
          0
      ? null
      : UIViewController.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>)>()(
            ref.pointer,
          ),
          retain: true,
          release: true,
        );
}

/// WARNING: UIContextMenuConfiguration is a stub. To generate bindings for this class, include
/// UIContextMenuConfiguration in your config's objc-interfaces list.
///
/// UIContextMenuConfiguration
class UIContextMenuConfiguration extends objc.NSObject {
  UIContextMenuConfiguration._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIContextMenuConfiguration', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIContextMenuConfiguration] that points to the same underlying object as [other].
  UIContextMenuConfiguration.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContextMenuConfiguration] that wraps the given raw object pointer.
  UIContextMenuConfiguration.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum UIContextMenuInteractionCommitStyle {
  UIContextMenuInteractionCommitStyleDismiss(0),
  UIContextMenuInteractionCommitStylePop(1);

  final int value;
  const UIContextMenuInteractionCommitStyle(this.value);

  static UIContextMenuInteractionCommitStyle fromValue(int value) => switch (value) {
    0 => UIContextMenuInteractionCommitStyleDismiss,
    1 => UIContextMenuInteractionCommitStylePop,
    _ => throw ArgumentError('Unknown value for UIContextMenuInteractionCommitStyle: $value'),
  };
}

enum UIContextMenuInteractionAppearance {
  UIContextMenuInteractionAppearanceUnknown(0),
  UIContextMenuInteractionAppearanceRich(1),
  UIContextMenuInteractionAppearanceCompact(2);

  final int value;
  const UIContextMenuInteractionAppearance(this.value);

  static UIContextMenuInteractionAppearance fromValue(int value) => switch (value) {
    0 => UIContextMenuInteractionAppearanceUnknown,
    1 => UIContextMenuInteractionAppearanceRich,
    2 => UIContextMenuInteractionAppearanceCompact,
    _ => throw ArgumentError('Unknown value for UIContextMenuInteractionAppearance: $value'),
  };
}

/// WARNING: UIContextMenuInteraction is a stub. To generate bindings for this class, include
/// UIContextMenuInteraction in your config's objc-interfaces list.
///
/// UIContextMenuInteraction
class UIContextMenuInteraction extends objc.NSObject implements UIInteraction {
  UIContextMenuInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIContextMenuInteraction', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIContextMenuInteraction] that points to the same underlying object as [other].
  UIContextMenuInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContextMenuInteraction] that wraps the given raw object pointer.
  UIContextMenuInteraction.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

sealed class UIControlEvents {
  static const UIControlEventTouchDown = 1;
  static const UIControlEventTouchDownRepeat = 2;
  static const UIControlEventTouchDragInside = 4;
  static const UIControlEventTouchDragOutside = 8;
  static const UIControlEventTouchDragEnter = 16;
  static const UIControlEventTouchDragExit = 32;
  static const UIControlEventTouchUpInside = 64;
  static const UIControlEventTouchUpOutside = 128;
  static const UIControlEventTouchCancel = 256;
  static const UIControlEventValueChanged = 4096;
  static const UIControlEventPrimaryActionTriggered = 8192;
  static const UIControlEventMenuActionTriggered = 16384;
  static const UIControlEventEditingDidBegin = 65536;
  static const UIControlEventEditingChanged = 131072;
  static const UIControlEventEditingDidEnd = 262144;
  static const UIControlEventEditingDidEndOnExit = 524288;
  static const UIControlEventAllTouchEvents = 4095;
  static const UIControlEventAllEditingEvents = 983040;
  static const UIControlEventApplicationReserved = 251658240;
  static const UIControlEventSystemReserved = 4026531840;
  static const UIControlEventAllEvents = 4294967295;
}

enum UIControlContentVerticalAlignment {
  UIControlContentVerticalAlignmentCenter(0),
  UIControlContentVerticalAlignmentTop(1),
  UIControlContentVerticalAlignmentBottom(2),
  UIControlContentVerticalAlignmentFill(3);

  final int value;
  const UIControlContentVerticalAlignment(this.value);

  static UIControlContentVerticalAlignment fromValue(int value) => switch (value) {
    0 => UIControlContentVerticalAlignmentCenter,
    1 => UIControlContentVerticalAlignmentTop,
    2 => UIControlContentVerticalAlignmentBottom,
    3 => UIControlContentVerticalAlignmentFill,
    _ => throw ArgumentError('Unknown value for UIControlContentVerticalAlignment: $value'),
  };
}

enum UIControlContentHorizontalAlignment {
  UIControlContentHorizontalAlignmentCenter(0),
  UIControlContentHorizontalAlignmentLeft(1),
  UIControlContentHorizontalAlignmentRight(2),
  UIControlContentHorizontalAlignmentFill(3),
  UIControlContentHorizontalAlignmentLeading(4),
  UIControlContentHorizontalAlignmentTrailing(5);

  final int value;
  const UIControlContentHorizontalAlignment(this.value);

  static UIControlContentHorizontalAlignment fromValue(int value) => switch (value) {
    0 => UIControlContentHorizontalAlignmentCenter,
    1 => UIControlContentHorizontalAlignmentLeft,
    2 => UIControlContentHorizontalAlignmentRight,
    3 => UIControlContentHorizontalAlignmentFill,
    4 => UIControlContentHorizontalAlignmentLeading,
    5 => UIControlContentHorizontalAlignmentTrailing,
    _ => throw ArgumentError('Unknown value for UIControlContentHorizontalAlignment: $value'),
  };
}

late final _class_UIControl = objc.getClass("UIControl");
late final _sel_initWithFrame_primaryAction_ = objc.registerName("initWithFrame:primaryAction:");
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_isHighlighted = objc.registerName("isHighlighted");
late final _sel_setHighlighted_ = objc.registerName("setHighlighted:");
late final _sel_contentVerticalAlignment = objc.registerName("contentVerticalAlignment");
final _objc_msgSend_nqfjlo = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentVerticalAlignment_ = objc.registerName("setContentVerticalAlignment:");
final _objc_msgSend_1jk7esa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contentHorizontalAlignment = objc.registerName("contentHorizontalAlignment");
final _objc_msgSend_18109rm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setContentHorizontalAlignment_ = objc.registerName("setContentHorizontalAlignment:");
final _objc_msgSend_96rhcc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_effectiveContentHorizontalAlignment = objc.registerName("effectiveContentHorizontalAlignment");
late final _sel_state = objc.registerName("state");
final _objc_msgSend_1as6oil = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isTouchInside = objc.registerName("isTouchInside");
late final _sel_beginTrackingWithTouch_withEvent_ = objc.registerName("beginTrackingWithTouch:withEvent:");
late final _sel_continueTrackingWithTouch_withEvent_ = objc.registerName("continueTrackingWithTouch:withEvent:");
late final _sel_endTrackingWithTouch_withEvent_ = objc.registerName("endTrackingWithTouch:withEvent:");
late final _sel_cancelTrackingWithEvent_ = objc.registerName("cancelTrackingWithEvent:");
late final _sel_addTarget_action_forControlEvents_ = objc.registerName("addTarget:action:forControlEvents:");
final _objc_msgSend_1tj22xm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
      )
    >();
late final _sel_removeTarget_action_forControlEvents_ = objc.registerName("removeTarget:action:forControlEvents:");
late final _sel_addAction_forControlEvents_ = objc.registerName("addAction:forControlEvents:");
final _objc_msgSend_10736wn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>, int)
    >();
late final _sel_removeAction_forControlEvents_ = objc.registerName("removeAction:forControlEvents:");
late final _sel_removeActionForIdentifier_forControlEvents_ = objc.registerName(
  "removeActionForIdentifier:forControlEvents:",
);
late final _sel_allTargets = objc.registerName("allTargets");
late final _sel_allControlEvents = objc.registerName("allControlEvents");
final _objc_msgSend_61dbeh = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_actionsForTarget_forControlEvent_ = objc.registerName("actionsForTarget:forControlEvent:");
final _objc_msgSend_364s2b = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAction?, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
abstract final class ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject> arg0,
          ffi.Pointer<objc.ObjCObject> arg1,
          ffi.Pointer<objc.ObjCSelector> arg2,
          ffi.UnsignedLong arg3,
          ffi.Pointer<ffi.Bool> arg4,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  fromFunction(
    void Function(UIAction?, objc.ObjCObjectBase?, ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          UIAction?,
          ffi.Pointer<objc.ObjCObject>?,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
          ffi.Pointer<ffi.Bool>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2,
            int arg3,
            ffi.Pointer<ffi.Bool> arg4,
          ) => fn(
            arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: true, release: true),
            arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: true, release: true),
            arg2,
            arg3,
            arg4,
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  listener(
    void Function(UIAction?, objc.ObjCObjectBase?, ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_1cxqo1i(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      UIAction?,
      ffi.Pointer<objc.ObjCObject>?,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  blocking(
    void Function(UIAction?, objc.ObjCObjectBase?, ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<ffi.Bool>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCObject> arg0,
        ffi.Pointer<objc.ObjCObject> arg1,
        ffi.Pointer<objc.ObjCSelector> arg2,
        int arg3,
        ffi.Pointer<ffi.Bool> arg4,
      ) => fn(
        arg0.address == 0 ? null : UIAction.castFromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.ObjCObjectBase(arg1, retain: false, release: true),
        arg2,
        arg3,
        arg4,
      ),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_1cxqo1i(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    int arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        ))(arg0, arg1, arg2, arg3, arg4);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    int arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2, arg3, arg4);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCObject>,
      ffi.Pointer<objc.ObjCSelector>,
      ffi.UnsignedLong,
      ffi.Pointer<ffi.Bool>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    int arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2,
            ffi.UnsignedLong arg3,
            ffi.Pointer<ffi.Bool> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        )
      >()(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObject> arg0,
    ffi.Pointer<objc.ObjCObject> arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    int arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<ffi.Bool>,
          ))(arg0, arg1, arg2, arg3, arg4);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCObject>,
              ffi.Pointer<objc.ObjCSelector>,
              ffi.UnsignedLong,
              ffi.Pointer<ffi.Bool>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAction?, ffi.Pointer<objc.ObjCObject>?, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong, ffi.Pointer<ffi.Bool>)>`.
extension ObjCBlock_ffiVoid_UIAction_objcObjCObject_objcObjCSelector_UIControlEvents_bool$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            UIAction?,
            ffi.Pointer<objc.ObjCObject>?,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.UnsignedLong,
            ffi.Pointer<ffi.Bool>,
          )
        > {
  void call(
    UIAction? arg0,
    objc.ObjCObjectBase? arg1,
    ffi.Pointer<objc.ObjCSelector> arg2,
    int arg3,
    ffi.Pointer<ffi.Bool> arg4,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObject> arg0,
            ffi.Pointer<objc.ObjCObject> arg1,
            ffi.Pointer<objc.ObjCSelector> arg2,
            ffi.UnsignedLong arg3,
            ffi.Pointer<ffi.Bool> arg4,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          int,
          ffi.Pointer<ffi.Bool>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr, arg2, arg3, arg4);
}

late final _sel_enumerateEventHandlers_ = objc.registerName("enumerateEventHandlers:");
late final _sel_sendAction_to_forEvent_ = objc.registerName("sendAction:to:forEvent:");
final _objc_msgSend_lzbvjm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_sendAction_ = objc.registerName("sendAction:");
late final _sel_sendActionsForControlEvents_ = objc.registerName("sendActionsForControlEvents:");
final _objc_msgSend_n08htp = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contextMenuInteraction = objc.registerName("contextMenuInteraction");
late final _sel_isContextMenuInteractionEnabled = objc.registerName("isContextMenuInteractionEnabled");
late final _sel_setContextMenuInteractionEnabled_ = objc.registerName("setContextMenuInteractionEnabled:");
late final _sel_showsMenuAsPrimaryAction = objc.registerName("showsMenuAsPrimaryAction");
late final _sel_setShowsMenuAsPrimaryAction_ = objc.registerName("setShowsMenuAsPrimaryAction:");
late final _sel_menuAttachmentPointForConfiguration_ = objc.registerName("menuAttachmentPointForConfiguration:");
final _objc_msgSend_1mpyy6y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGPoint Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      objc.CGPoint Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
final _objc_msgSend_1mpyy6yStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGPoint>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGPoint>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_toolTip = objc.registerName("toolTip");
late final _sel_setToolTip_ = objc.registerName("setToolTip:");

/// WARNING: UIToolTipInteraction is a stub. To generate bindings for this class, include
/// UIToolTipInteraction in your config's objc-interfaces list.
///
/// UIToolTipInteraction
class UIToolTipInteraction extends objc.ObjCObjectBase {
  UIToolTipInteraction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIToolTipInteraction] that points to the same underlying object as [other].
  UIToolTipInteraction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIToolTipInteraction] that wraps the given raw object pointer.
  UIToolTipInteraction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_toolTipInteraction = objc.registerName("toolTipInteraction");

/// UIControl
class UIControl extends UIView {
  UIControl._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIControl', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIControl] that points to the same underlying object as [other].
  UIControl.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIControl] that wraps the given raw object pointer.
  UIControl.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIControl].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIControl);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UIControl.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UIControl, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UIControl.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UIControl,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UIControl.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UIControl,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }
}

extension UIControl$Methods on UIControl {
  /// actionsForTarget:forControlEvent:
  objc.NSArray? actionsForTarget(objc.ObjCObjectBase? target, {required int forControlEvent}) {
    objc.checkOsVersionInternal('UIControl.actionsForTarget:forControlEvent:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_364s2b(
      this.ref.pointer,
      _sel_actionsForTarget_forControlEvent_,
      target?.ref.pointer ?? ffi.nullptr,
      forControlEvent,
    );
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// Adds the UIAction to a given event. UIActions are uniqued based on their identifier, and subsequent actions with the same identifier replace previously added actions. You may add multiple UIActions for corresponding controlEvents, and you may add the same action to multiple controlEvents.
  void addAction(UIAction action, {required int forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.addAction:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(this.ref.pointer, _sel_addAction_forControlEvents_, action.ref.pointer, forControlEvents);
  }

  /// addTarget:action:forControlEvents:
  void addTarget(
    objc.ObjCObjectBase? target, {
    required ffi.Pointer<objc.ObjCSelector> action,
    required int forControlEvents,
  }) {
    objc.checkOsVersionInternal('UIControl.addTarget:action:forControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1tj22xm(
      this.ref.pointer,
      _sel_addTarget_action_forControlEvents_,
      target?.ref.pointer ?? ffi.nullptr,
      action,
      forControlEvents,
    );
  }

  /// allControlEvents
  int get allControlEvents {
    objc.checkOsVersionInternal('UIControl.allControlEvents', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_61dbeh(this.ref.pointer, _sel_allControlEvents);
  }

  /// allTargets
  objc.NSSet get allTargets {
    objc.checkOsVersionInternal('UIControl.allTargets', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allTargets);
    return objc.NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// beginTrackingWithTouch:withEvent:
  bool beginTrackingWithTouch(UITouch touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.beginTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_beginTrackingWithTouch_withEvent_,
      touch.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// cancelTrackingWithEvent:
  void cancelTrackingWithEvent(UIEvent? event) {
    objc.checkOsVersionInternal('UIControl.cancelTrackingWithEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cancelTrackingWithEvent_, event?.ref.pointer ?? ffi.nullptr);
  }

  /// contentHorizontalAlignment
  UIControlContentHorizontalAlignment get contentHorizontalAlignment {
    objc.checkOsVersionInternal('UIControl.contentHorizontalAlignment', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_18109rm(this.ref.pointer, _sel_contentHorizontalAlignment);
    return UIControlContentHorizontalAlignment.fromValue($ret);
  }

  /// contentVerticalAlignment
  UIControlContentVerticalAlignment get contentVerticalAlignment {
    objc.checkOsVersionInternal('UIControl.contentVerticalAlignment', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_nqfjlo(this.ref.pointer, _sel_contentVerticalAlignment);
    return UIControlContentVerticalAlignment.fromValue($ret);
  }

  /// Returns a UIContextMenuInteraction with this control set as its delegate. Before constructing the UIContextMenuInteraction, UIControl verifies 'self' is a viable delegate. See 'Implementing UIControl Menus' below for more details.
  UIContextMenuInteraction? get contextMenuInteraction {
    objc.checkOsVersionInternal('UIControl.contextMenuInteraction', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_contextMenuInteraction);
    return $ret.address == 0 ? null : UIContextMenuInteraction.castFromPointer($ret, retain: true, release: true);
  }

  /// continueTrackingWithTouch:withEvent:
  bool continueTrackingWithTouch(UITouch touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.continueTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1lsax7n(
      this.ref.pointer,
      _sel_continueTrackingWithTouch_withEvent_,
      touch.ref.pointer,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// effectiveContentHorizontalAlignment
  UIControlContentHorizontalAlignment get effectiveContentHorizontalAlignment {
    objc.checkOsVersionInternal('UIControl.effectiveContentHorizontalAlignment', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_18109rm(this.ref.pointer, _sel_effectiveContentHorizontalAlignment);
    return UIControlContentHorizontalAlignment.fromValue($ret);
  }

  /// endTrackingWithTouch:withEvent:
  void endTrackingWithTouch(UITouch? touch, {UIEvent? withEvent}) {
    objc.checkOsVersionInternal('UIControl.endTrackingWithTouch:withEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_pfv6jd(
      this.ref.pointer,
      _sel_endTrackingWithTouch_withEvent_,
      touch?.ref.pointer ?? ffi.nullptr,
      withEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// Iterate over the event handlers installed on this control at the time this method is called. For each call, either actionHandler or action will be non-nil. controlEvents is always non-zero. Setting *stop to YES will terminate the enumeration early. It is legal to manipulate the control's event handlers within the block.
  void enumerateEventHandlers(
    objc.ObjCBlock<
      ffi.Void Function(
        UIAction?,
        ffi.Pointer<objc.ObjCObject>?,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.UnsignedLong,
        ffi.Pointer<ffi.Bool>,
      )
    >
    iterator,
  ) {
    objc.checkOsVersionInternal('UIControl.enumerateEventHandlers:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_f167m6(this.ref.pointer, _sel_enumerateEventHandlers_, iterator.ref.pointer);
  }

  /// initWithCoder:
  UIControl? initWithCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('UIControl.initWithCoder:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIControl.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UIControl initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UIControl.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UIControl.castFromPointer($ret, retain: false, release: true);
  }

  /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
  UIControl initWithFrame$1(objc.CGRect frame, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UIControl.initWithFrame:primaryAction:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_gxusyk(
      this.ref.retainAndReturnPointer(),
      _sel_initWithFrame_primaryAction_,
      frame,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UIControl.castFromPointer($ret, retain: false, release: true);
  }

  /// Specifies if the context menu interaction is enabled. NO by default.
  bool get isContextMenuInteractionEnabled {
    objc.checkOsVersionInternal('UIControl.isContextMenuInteractionEnabled', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isContextMenuInteractionEnabled);
  }

  /// isEnabled
  bool get isEnabled {
    objc.checkOsVersionInternal('UIControl.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// isHighlighted
  bool get isHighlighted {
    objc.checkOsVersionInternal('UIControl.isHighlighted', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// isSelected
  bool get isSelected {
    objc.checkOsVersionInternal('UIControl.isSelected', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isSelected);
  }

  /// isTouchInside
  bool get isTouchInside {
    objc.checkOsVersionInternal('UIControl.isTouchInside', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTouchInside);
  }

  /// isTracking
  bool get isTracking {
    objc.checkOsVersionInternal('UIControl.isTracking', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isTracking);
  }

  /// Return a point in this control's coordinate space to which to attach the given configuration's menu.
  objc.CGPoint menuAttachmentPointForConfiguration(UIContextMenuConfiguration configuration) {
    objc.checkOsVersionInternal('UIControl.menuAttachmentPointForConfiguration:', iOS: (false, (14, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGPoint>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1mpyy6yStret(
            $ptr,
            this.ref.pointer,
            _sel_menuAttachmentPointForConfiguration_,
            configuration.ref.pointer,
          )
        : $ptr.ref = _objc_msgSend_1mpyy6y(
            this.ref.pointer,
            _sel_menuAttachmentPointForConfiguration_,
            configuration.ref.pointer,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGPoint>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGPoint>($finalizable);
  }

  /// Removes the action from the set of passed control events.
  void removeAction(UIAction action, {required int forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.removeAction:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(this.ref.pointer, _sel_removeAction_forControlEvents_, action.ref.pointer, forControlEvents);
  }

  /// Removes the action with the provided identifier from the set of passed control events.
  void removeActionForIdentifier(objc.NSString actionIdentifier, {required int forControlEvents}) {
    objc.checkOsVersionInternal('UIControl.removeActionForIdentifier:forControlEvents:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_10736wn(
      this.ref.pointer,
      _sel_removeActionForIdentifier_forControlEvents_,
      actionIdentifier.ref.pointer,
      forControlEvents,
    );
  }

  /// removeTarget:action:forControlEvents:
  void removeTarget(
    objc.ObjCObjectBase? target, {
    required ffi.Pointer<objc.ObjCSelector> action,
    required int forControlEvents,
  }) {
    objc.checkOsVersionInternal('UIControl.removeTarget:action:forControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1tj22xm(
      this.ref.pointer,
      _sel_removeTarget_action_forControlEvents_,
      target?.ref.pointer ?? ffi.nullptr,
      action,
      forControlEvents,
    );
  }

  /// Like -sendAction:to:forEvent:, this method is called by -sendActionsForControlEvents:. You may override this method to observe or modify behavior. If you override this method, you should call super precisely once to dispatch the action, or not call super to suppress sending that action.
  void sendAction(UIAction action) {
    objc.checkOsVersionInternal('UIControl.sendAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendAction_, action.ref.pointer);
  }

  /// Dispatch the target-action pair. This method is called repeatedly by -sendActionsForControlEvents: and is a point at which you can observe or override behavior.
  void sendAction$1(ffi.Pointer<objc.ObjCSelector> action, {objc.ObjCObjectBase? to, UIEvent? forEvent}) {
    objc.checkOsVersionInternal('UIControl.sendAction:to:forEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_lzbvjm(
      this.ref.pointer,
      _sel_sendAction_to_forEvent_,
      action,
      to?.ref.pointer ?? ffi.nullptr,
      forEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// send all actions associated with the given control events
  void sendActionsForControlEvents(int controlEvents) {
    objc.checkOsVersionInternal('UIControl.sendActionsForControlEvents:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_n08htp(this.ref.pointer, _sel_sendActionsForControlEvents_, controlEvents);
  }

  /// setContentHorizontalAlignment:
  set contentHorizontalAlignment(UIControlContentHorizontalAlignment value) {
    objc.checkOsVersionInternal('UIControl.setContentHorizontalAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_96rhcc(this.ref.pointer, _sel_setContentHorizontalAlignment_, value.value);
  }

  /// setContentVerticalAlignment:
  set contentVerticalAlignment(UIControlContentVerticalAlignment value) {
    objc.checkOsVersionInternal('UIControl.setContentVerticalAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1jk7esa(this.ref.pointer, _sel_setContentVerticalAlignment_, value.value);
  }

  /// Specifies if the context menu interaction is enabled. NO by default.
  set isContextMenuInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UIControl.setContextMenuInteractionEnabled:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setContextMenuInteractionEnabled_, value);
  }

  /// setEnabled:
  set isEnabled(bool value) {
    objc.checkOsVersionInternal('UIControl.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// setHighlighted:
  set isHighlighted(bool value) {
    objc.checkOsVersionInternal('UIControl.setHighlighted:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// setSelected:
  set isSelected(bool value) {
    objc.checkOsVersionInternal('UIControl.setSelected:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setSelected_, value);
  }

  /// If the contextMenuInteraction is the primary action of the control, invoked on touch-down. NO by default.
  set showsMenuAsPrimaryAction(bool value) {
    objc.checkOsVersionInternal('UIControl.setShowsMenuAsPrimaryAction:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsMenuAsPrimaryAction_, value);
  }

  /// Assigning a value to this property causes the tool tip to be displayed for the view. Setting the property to nil cancels the display of the tool tip for the view.
  set toolTip(objc.NSString? value) {
    objc.checkOsVersionInternal('UIControl.setToolTip:', iOS: (false, (15, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolTip_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// If the contextMenuInteraction is the primary action of the control, invoked on touch-down. NO by default.
  bool get showsMenuAsPrimaryAction {
    objc.checkOsVersionInternal('UIControl.showsMenuAsPrimaryAction', iOS: (false, (14, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsMenuAsPrimaryAction);
  }

  /// state
  int get state {
    objc.checkOsVersionInternal('UIControl.state', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1as6oil(this.ref.pointer, _sel_state);
  }

  /// Assigning a value to this property causes the tool tip to be displayed for the view. Setting the property to nil cancels the display of the tool tip for the view.
  objc.NSString? get toolTip {
    objc.checkOsVersionInternal('UIControl.toolTip', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolTip);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns the control's default UIToolTipInteraction.
  UIToolTipInteraction? get toolTipInteraction {
    objc.checkOsVersionInternal('UIControl.toolTipInteraction', iOS: (false, (15, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolTipInteraction);
    return $ret.address == 0 ? null : UIToolTipInteraction.castFromPointer($ret, retain: true, release: true);
  }
}

enum NSWritingDirection {
  NSWritingDirectionNatural(-1),
  NSWritingDirectionLeftToRight(0),
  NSWritingDirectionRightToLeft(1);

  final int value;
  const NSWritingDirection(this.value);

  static NSWritingDirection fromValue(int value) => switch (value) {
    -1 => NSWritingDirectionNatural,
    0 => NSWritingDirectionLeftToRight,
    1 => NSWritingDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSWritingDirection: $value'),
  };
}

enum NSPasteboardAccessBehavior {
  NSPasteboardAccessBehaviorDefault(0),
  NSPasteboardAccessBehaviorAsk(1),
  NSPasteboardAccessBehaviorAlwaysAllow(2),
  NSPasteboardAccessBehaviorAlwaysDeny(3);

  final int value;
  const NSPasteboardAccessBehavior(this.value);

  static NSPasteboardAccessBehavior fromValue(int value) => switch (value) {
    0 => NSPasteboardAccessBehaviorDefault,
    1 => NSPasteboardAccessBehaviorAsk,
    2 => NSPasteboardAccessBehaviorAlwaysAllow,
    3 => NSPasteboardAccessBehaviorAlwaysDeny,
    _ => throw ArgumentError('Unknown value for NSPasteboardAccessBehavior: $value'),
  };
}

sealed class NSPasteboardContentsOptions {
  static const NSPasteboardContentsCurrentHostOnly = 1;
}

sealed class NSDragOperation {
  static const NSDragOperationNone = 0;
  static const NSDragOperationCopy = 1;
  static const NSDragOperationLink = 2;
  static const NSDragOperationGeneric = 4;
  static const NSDragOperationPrivate = 8;
  static const NSDragOperationMove = 16;
  static const NSDragOperationDelete = 32;
  static const NSDragOperationEvery = -1;
  static const NSDragOperationAll_Obsolete = 15;
  static const NSDragOperationAll = 15;
}

enum NSDraggingFormation {
  NSDraggingFormationDefault(0),
  NSDraggingFormationNone(1),
  NSDraggingFormationPile(2),
  NSDraggingFormationList(3),
  NSDraggingFormationStack(4);

  final int value;
  const NSDraggingFormation(this.value);

  static NSDraggingFormation fromValue(int value) => switch (value) {
    0 => NSDraggingFormationDefault,
    1 => NSDraggingFormationNone,
    2 => NSDraggingFormationPile,
    3 => NSDraggingFormationList,
    4 => NSDraggingFormationStack,
    _ => throw ArgumentError('Unknown value for NSDraggingFormation: $value'),
  };
}

enum NSDraggingContext {
  NSDraggingContextOutsideApplication(0),
  NSDraggingContextWithinApplication(1);

  final int value;
  const NSDraggingContext(this.value);

  static NSDraggingContext fromValue(int value) => switch (value) {
    0 => NSDraggingContextOutsideApplication,
    1 => NSDraggingContextWithinApplication,
    _ => throw ArgumentError('Unknown value for NSDraggingContext: $value'),
  };
}

sealed class NSDraggingItemEnumerationOptions {
  static const NSDraggingItemEnumerationConcurrent = 1;
  static const NSDraggingItemEnumerationClearNonenumeratedImages = 65536;
}

enum NSSpringLoadingHighlight {
  NSSpringLoadingHighlightNone(0),
  NSSpringLoadingHighlightStandard(1),
  NSSpringLoadingHighlightEmphasized(2);

  final int value;
  const NSSpringLoadingHighlight(this.value);

  static NSSpringLoadingHighlight fromValue(int value) => switch (value) {
    0 => NSSpringLoadingHighlightNone,
    1 => NSSpringLoadingHighlightStandard,
    2 => NSSpringLoadingHighlightEmphasized,
    _ => throw ArgumentError('Unknown value for NSSpringLoadingHighlight: $value'),
  };
}

enum NSWindowOrderingMode {
  NSWindowAbove(1),
  NSWindowBelow(-1),
  NSWindowOut(0);

  final int value;
  const NSWindowOrderingMode(this.value);

  static NSWindowOrderingMode fromValue(int value) => switch (value) {
    1 => NSWindowAbove,
    -1 => NSWindowBelow,
    0 => NSWindowOut,
    _ => throw ArgumentError('Unknown value for NSWindowOrderingMode: $value'),
  };
}

enum NSFocusRingType {
  NSFocusRingTypeDefault(0),
  NSFocusRingTypeNone(1),
  NSFocusRingTypeExterior(2);

  final int value;
  const NSFocusRingType(this.value);

  static NSFocusRingType fromValue(int value) => switch (value) {
    0 => NSFocusRingTypeDefault,
    1 => NSFocusRingTypeNone,
    2 => NSFocusRingTypeExterior,
    _ => throw ArgumentError('Unknown value for NSFocusRingType: $value'),
  };
}

sealed class NSTouchPhase {
  static const NSTouchPhaseBegan = 1;
  static const NSTouchPhaseMoved = 2;
  static const NSTouchPhaseStationary = 4;
  static const NSTouchPhaseEnded = 8;
  static const NSTouchPhaseCancelled = 16;
  static const NSTouchPhaseTouching = 7;
  static const NSTouchPhaseAny = -1;
}

enum NSTouchType {
  NSTouchTypeDirect(0),
  NSTouchTypeIndirect(1);

  final int value;
  const NSTouchType(this.value);

  static NSTouchType fromValue(int value) => switch (value) {
    0 => NSTouchTypeDirect,
    1 => NSTouchTypeIndirect,
    _ => throw ArgumentError('Unknown value for NSTouchType: $value'),
  };
}

sealed class NSTouchTypeMask {
  static const NSTouchTypeMaskDirect = 1;
  static const NSTouchTypeMaskIndirect = 2;
}

enum NSEventType {
  NSEventTypeLeftMouseDown(1),
  NSEventTypeLeftMouseUp(2),
  NSEventTypeRightMouseDown(3),
  NSEventTypeRightMouseUp(4),
  NSEventTypeMouseMoved(5),
  NSEventTypeLeftMouseDragged(6),
  NSEventTypeRightMouseDragged(7),
  NSEventTypeMouseEntered(8),
  NSEventTypeMouseExited(9),
  NSEventTypeKeyDown(10),
  NSEventTypeKeyUp(11),
  NSEventTypeFlagsChanged(12),
  NSEventTypeAppKitDefined(13),
  NSEventTypeSystemDefined(14),
  NSEventTypeApplicationDefined(15),
  NSEventTypePeriodic(16),
  NSEventTypeCursorUpdate(17),
  NSEventTypeScrollWheel(22),
  NSEventTypeTabletPoint(23),
  NSEventTypeTabletProximity(24),
  NSEventTypeOtherMouseDown(25),
  NSEventTypeOtherMouseUp(26),
  NSEventTypeOtherMouseDragged(27),
  NSEventTypeGesture(29),
  NSEventTypeMagnify(30),
  NSEventTypeSwipe(31),
  NSEventTypeRotate(18),
  NSEventTypeBeginGesture(19),
  NSEventTypeEndGesture(20),
  NSEventTypeSmartMagnify(32),
  NSEventTypeQuickLook(33),
  NSEventTypePressure(34),
  NSEventTypeDirectTouch(37),
  NSEventTypeChangeMode(38),
  NSEventTypeMouseCancelled(40);

  final int value;
  const NSEventType(this.value);

  static NSEventType fromValue(int value) => switch (value) {
    1 => NSEventTypeLeftMouseDown,
    2 => NSEventTypeLeftMouseUp,
    3 => NSEventTypeRightMouseDown,
    4 => NSEventTypeRightMouseUp,
    5 => NSEventTypeMouseMoved,
    6 => NSEventTypeLeftMouseDragged,
    7 => NSEventTypeRightMouseDragged,
    8 => NSEventTypeMouseEntered,
    9 => NSEventTypeMouseExited,
    10 => NSEventTypeKeyDown,
    11 => NSEventTypeKeyUp,
    12 => NSEventTypeFlagsChanged,
    13 => NSEventTypeAppKitDefined,
    14 => NSEventTypeSystemDefined,
    15 => NSEventTypeApplicationDefined,
    16 => NSEventTypePeriodic,
    17 => NSEventTypeCursorUpdate,
    22 => NSEventTypeScrollWheel,
    23 => NSEventTypeTabletPoint,
    24 => NSEventTypeTabletProximity,
    25 => NSEventTypeOtherMouseDown,
    26 => NSEventTypeOtherMouseUp,
    27 => NSEventTypeOtherMouseDragged,
    29 => NSEventTypeGesture,
    30 => NSEventTypeMagnify,
    31 => NSEventTypeSwipe,
    18 => NSEventTypeRotate,
    19 => NSEventTypeBeginGesture,
    20 => NSEventTypeEndGesture,
    32 => NSEventTypeSmartMagnify,
    33 => NSEventTypeQuickLook,
    34 => NSEventTypePressure,
    37 => NSEventTypeDirectTouch,
    38 => NSEventTypeChangeMode,
    40 => NSEventTypeMouseCancelled,
    _ => throw ArgumentError('Unknown value for NSEventType: $value'),
  };
}

sealed class NSEventMask {
  static const NSEventMaskLeftMouseDown = 2;
  static const NSEventMaskLeftMouseUp = 4;
  static const NSEventMaskRightMouseDown = 8;
  static const NSEventMaskRightMouseUp = 16;
  static const NSEventMaskMouseMoved = 32;
  static const NSEventMaskLeftMouseDragged = 64;
  static const NSEventMaskRightMouseDragged = 128;
  static const NSEventMaskMouseEntered = 256;
  static const NSEventMaskMouseExited = 512;
  static const NSEventMaskKeyDown = 1024;
  static const NSEventMaskKeyUp = 2048;
  static const NSEventMaskFlagsChanged = 4096;
  static const NSEventMaskAppKitDefined = 8192;
  static const NSEventMaskSystemDefined = 16384;
  static const NSEventMaskApplicationDefined = 32768;
  static const NSEventMaskPeriodic = 65536;
  static const NSEventMaskCursorUpdate = 131072;
  static const NSEventMaskScrollWheel = 4194304;
  static const NSEventMaskTabletPoint = 8388608;
  static const NSEventMaskTabletProximity = 16777216;
  static const NSEventMaskOtherMouseDown = 33554432;
  static const NSEventMaskOtherMouseUp = 67108864;
  static const NSEventMaskOtherMouseDragged = 134217728;
  static const NSEventMaskGesture = 536870912;
  static const NSEventMaskMagnify = 1073741824;
  static const NSEventMaskSwipe = 2147483648;
  static const NSEventMaskRotate = 262144;
  static const NSEventMaskBeginGesture = 524288;
  static const NSEventMaskEndGesture = 1048576;
  static const NSEventMaskSmartMagnify = 4294967296;
  static const NSEventMaskPressure = 17179869184;
  static const NSEventMaskDirectTouch = 137438953472;
  static const NSEventMaskChangeMode = 274877906944;
  static const NSEventMaskMouseCancelled = 1099511627776;
  static const NSEventMaskAny = -1;
}

sealed class NSEventModifierFlags {
  static const NSEventModifierFlagCapsLock = 65536;
  static const NSEventModifierFlagShift = 131072;
  static const NSEventModifierFlagControl = 262144;
  static const NSEventModifierFlagOption = 524288;
  static const NSEventModifierFlagCommand = 1048576;
  static const NSEventModifierFlagNumericPad = 2097152;
  static const NSEventModifierFlagHelp = 4194304;
  static const NSEventModifierFlagFunction = 8388608;
  static const NSEventModifierFlagDeviceIndependentFlagsMask = 4294901760;
}

enum NSPointingDeviceType {
  NSPointingDeviceTypeUnknown(0),
  NSPointingDeviceTypePen(1),
  NSPointingDeviceTypeCursor(2),
  NSPointingDeviceTypeEraser(3);

  final int value;
  const NSPointingDeviceType(this.value);

  static NSPointingDeviceType fromValue(int value) => switch (value) {
    0 => NSPointingDeviceTypeUnknown,
    1 => NSPointingDeviceTypePen,
    2 => NSPointingDeviceTypeCursor,
    3 => NSPointingDeviceTypeEraser,
    _ => throw ArgumentError('Unknown value for NSPointingDeviceType: $value'),
  };
}

sealed class NSEventButtonMask {
  static const NSEventButtonMaskPenTip = 1;
  static const NSEventButtonMaskPenLowerSide = 2;
  static const NSEventButtonMaskPenUpperSide = 4;
}

sealed class NSEventPhase {
  static const NSEventPhaseNone = 0;
  static const NSEventPhaseBegan = 1;
  static const NSEventPhaseStationary = 2;
  static const NSEventPhaseChanged = 4;
  static const NSEventPhaseEnded = 8;
  static const NSEventPhaseCancelled = 16;
  static const NSEventPhaseMayBegin = 32;
}

enum NSEventGestureAxis {
  NSEventGestureAxisNone(0),
  NSEventGestureAxisHorizontal(1),
  NSEventGestureAxisVertical(2);

  final int value;
  const NSEventGestureAxis(this.value);

  static NSEventGestureAxis fromValue(int value) => switch (value) {
    0 => NSEventGestureAxisNone,
    1 => NSEventGestureAxisHorizontal,
    2 => NSEventGestureAxisVertical,
    _ => throw ArgumentError('Unknown value for NSEventGestureAxis: $value'),
  };
}

sealed class NSEventSwipeTrackingOptions {
  static const NSEventSwipeTrackingLockDirection = 1;
  static const NSEventSwipeTrackingClampGestureAmount = 2;
}

enum NSEventSubtype {
  NSEventSubtypeWindowExposed(0),
  NSEventSubtypeApplicationActivated(1),
  NSEventSubtypeApplicationDeactivated(2),
  NSEventSubtypeWindowMoved(4),
  NSEventSubtypeScreenChanged(8),
  NSEventSubtypeTouch(3);

  static const NSEventSubtypePowerOff = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeMouseEvent = NSEventSubtypeWindowExposed;
  static const NSEventSubtypeTabletPoint = NSEventSubtypeApplicationActivated;
  static const NSEventSubtypeTabletProximity = NSEventSubtypeApplicationDeactivated;

  final int value;
  const NSEventSubtype(this.value);

  static NSEventSubtype fromValue(int value) => switch (value) {
    0 => NSEventSubtypeWindowExposed,
    1 => NSEventSubtypeApplicationActivated,
    2 => NSEventSubtypeApplicationDeactivated,
    4 => NSEventSubtypeWindowMoved,
    8 => NSEventSubtypeScreenChanged,
    3 => NSEventSubtypeTouch,
    _ => throw ArgumentError('Unknown value for NSEventSubtype: $value'),
  };

  @override
  String toString() {
    if (this == NSEventSubtypeWindowExposed)
      return "NSEventSubtype.NSEventSubtypeWindowExposed, NSEventSubtype.NSEventSubtypeMouseEvent";
    if (this == NSEventSubtypeApplicationActivated)
      return "NSEventSubtype.NSEventSubtypeApplicationActivated, NSEventSubtype.NSEventSubtypePowerOff, NSEventSubtype.NSEventSubtypeTabletPoint";
    if (this == NSEventSubtypeApplicationDeactivated)
      return "NSEventSubtype.NSEventSubtypeApplicationDeactivated, NSEventSubtype.NSEventSubtypeTabletProximity";
    return super.toString();
  }
}

enum NSPressureBehavior {
  NSPressureBehaviorUnknown(-1),
  NSPressureBehaviorPrimaryDefault(0),
  NSPressureBehaviorPrimaryClick(1),
  NSPressureBehaviorPrimaryGeneric(2),
  NSPressureBehaviorPrimaryAccelerator(3),
  NSPressureBehaviorPrimaryDeepClick(5),
  NSPressureBehaviorPrimaryDeepDrag(6);

  final int value;
  const NSPressureBehavior(this.value);

  static NSPressureBehavior fromValue(int value) => switch (value) {
    -1 => NSPressureBehaviorUnknown,
    0 => NSPressureBehaviorPrimaryDefault,
    1 => NSPressureBehaviorPrimaryClick,
    2 => NSPressureBehaviorPrimaryGeneric,
    3 => NSPressureBehaviorPrimaryAccelerator,
    5 => NSPressureBehaviorPrimaryDeepClick,
    6 => NSPressureBehaviorPrimaryDeepDrag,
    _ => throw ArgumentError('Unknown value for NSPressureBehavior: $value'),
  };
}

enum NSAccessibilityOrientation {
  NSAccessibilityOrientationUnknown(0),
  NSAccessibilityOrientationVertical(1),
  NSAccessibilityOrientationHorizontal(2);

  final int value;
  const NSAccessibilityOrientation(this.value);

  static NSAccessibilityOrientation fromValue(int value) => switch (value) {
    0 => NSAccessibilityOrientationUnknown,
    1 => NSAccessibilityOrientationVertical,
    2 => NSAccessibilityOrientationHorizontal,
    _ => throw ArgumentError('Unknown value for NSAccessibilityOrientation: $value'),
  };
}

enum NSAccessibilitySortDirection {
  NSAccessibilitySortDirectionUnknown(0),
  NSAccessibilitySortDirectionAscending(1),
  NSAccessibilitySortDirectionDescending(2);

  final int value;
  const NSAccessibilitySortDirection(this.value);

  static NSAccessibilitySortDirection fromValue(int value) => switch (value) {
    0 => NSAccessibilitySortDirectionUnknown,
    1 => NSAccessibilitySortDirectionAscending,
    2 => NSAccessibilitySortDirectionDescending,
    _ => throw ArgumentError('Unknown value for NSAccessibilitySortDirection: $value'),
  };
}

enum NSAccessibilityRulerMarkerType {
  NSAccessibilityRulerMarkerTypeUnknown(0),
  NSAccessibilityRulerMarkerTypeTabStopLeft(1),
  NSAccessibilityRulerMarkerTypeTabStopRight(2),
  NSAccessibilityRulerMarkerTypeTabStopCenter(3),
  NSAccessibilityRulerMarkerTypeTabStopDecimal(4),
  NSAccessibilityRulerMarkerTypeIndentHead(5),
  NSAccessibilityRulerMarkerTypeIndentTail(6),
  NSAccessibilityRulerMarkerTypeIndentFirstLine(7);

  final int value;
  const NSAccessibilityRulerMarkerType(this.value);

  static NSAccessibilityRulerMarkerType fromValue(int value) => switch (value) {
    0 => NSAccessibilityRulerMarkerTypeUnknown,
    1 => NSAccessibilityRulerMarkerTypeTabStopLeft,
    2 => NSAccessibilityRulerMarkerTypeTabStopRight,
    3 => NSAccessibilityRulerMarkerTypeTabStopCenter,
    4 => NSAccessibilityRulerMarkerTypeTabStopDecimal,
    5 => NSAccessibilityRulerMarkerTypeIndentHead,
    6 => NSAccessibilityRulerMarkerTypeIndentTail,
    7 => NSAccessibilityRulerMarkerTypeIndentFirstLine,
    _ => throw ArgumentError('Unknown value for NSAccessibilityRulerMarkerType: $value'),
  };
}

enum NSAccessibilityUnits {
  NSAccessibilityUnitsUnknown(0),
  NSAccessibilityUnitsInches(1),
  NSAccessibilityUnitsCentimeters(2),
  NSAccessibilityUnitsPoints(3),
  NSAccessibilityUnitsPicas(4);

  final int value;
  const NSAccessibilityUnits(this.value);

  static NSAccessibilityUnits fromValue(int value) => switch (value) {
    0 => NSAccessibilityUnitsUnknown,
    1 => NSAccessibilityUnitsInches,
    2 => NSAccessibilityUnitsCentimeters,
    3 => NSAccessibilityUnitsPoints,
    4 => NSAccessibilityUnitsPicas,
    _ => throw ArgumentError('Unknown value for NSAccessibilityUnits: $value'),
  };
}

enum NSUserInterfaceLayoutDirection {
  NSUserInterfaceLayoutDirectionLeftToRight(0),
  NSUserInterfaceLayoutDirectionRightToLeft(1);

  final int value;
  const NSUserInterfaceLayoutDirection(this.value);

  static NSUserInterfaceLayoutDirection fromValue(int value) => switch (value) {
    0 => NSUserInterfaceLayoutDirectionLeftToRight,
    1 => NSUserInterfaceLayoutDirectionRightToLeft,
    _ => throw ArgumentError('Unknown value for NSUserInterfaceLayoutDirection: $value'),
  };
}

sealed class NSAutoresizingMaskOptions {
  static const NSViewNotSizable = 0;
  static const NSViewMinXMargin = 1;
  static const NSViewWidthSizable = 2;
  static const NSViewMaxXMargin = 4;
  static const NSViewMinYMargin = 8;
  static const NSViewHeightSizable = 16;
  static const NSViewMaxYMargin = 32;
}

enum NSViewLayerContentsRedrawPolicy {
  NSViewLayerContentsRedrawNever(0),
  NSViewLayerContentsRedrawOnSetNeedsDisplay(1),
  NSViewLayerContentsRedrawDuringViewResize(2),
  NSViewLayerContentsRedrawBeforeViewResize(3),
  NSViewLayerContentsRedrawCrossfade(4);

  final int value;
  const NSViewLayerContentsRedrawPolicy(this.value);

  static NSViewLayerContentsRedrawPolicy fromValue(int value) => switch (value) {
    0 => NSViewLayerContentsRedrawNever,
    1 => NSViewLayerContentsRedrawOnSetNeedsDisplay,
    2 => NSViewLayerContentsRedrawDuringViewResize,
    3 => NSViewLayerContentsRedrawBeforeViewResize,
    4 => NSViewLayerContentsRedrawCrossfade,
    _ => throw ArgumentError('Unknown value for NSViewLayerContentsRedrawPolicy: $value'),
  };
}

enum NSViewLayerContentsPlacement {
  NSViewLayerContentsPlacementScaleAxesIndependently(0),
  NSViewLayerContentsPlacementScaleProportionallyToFit(1),
  NSViewLayerContentsPlacementScaleProportionallyToFill(2),
  NSViewLayerContentsPlacementCenter(3),
  NSViewLayerContentsPlacementTop(4),
  NSViewLayerContentsPlacementTopRight(5),
  NSViewLayerContentsPlacementRight(6),
  NSViewLayerContentsPlacementBottomRight(7),
  NSViewLayerContentsPlacementBottom(8),
  NSViewLayerContentsPlacementBottomLeft(9),
  NSViewLayerContentsPlacementLeft(10),
  NSViewLayerContentsPlacementTopLeft(11);

  final int value;
  const NSViewLayerContentsPlacement(this.value);

  static NSViewLayerContentsPlacement fromValue(int value) => switch (value) {
    0 => NSViewLayerContentsPlacementScaleAxesIndependently,
    1 => NSViewLayerContentsPlacementScaleProportionallyToFit,
    2 => NSViewLayerContentsPlacementScaleProportionallyToFill,
    3 => NSViewLayerContentsPlacementCenter,
    4 => NSViewLayerContentsPlacementTop,
    5 => NSViewLayerContentsPlacementTopRight,
    6 => NSViewLayerContentsPlacementRight,
    7 => NSViewLayerContentsPlacementBottomRight,
    8 => NSViewLayerContentsPlacementBottom,
    9 => NSViewLayerContentsPlacementBottomLeft,
    10 => NSViewLayerContentsPlacementLeft,
    11 => NSViewLayerContentsPlacementTopLeft,
    _ => throw ArgumentError('Unknown value for NSViewLayerContentsPlacement: $value'),
  };
}

enum NSTextAlignment {
  NSTextAlignmentLeft(0),
  NSTextAlignmentCenter(1),
  NSTextAlignmentRight(2),
  NSTextAlignmentJustified(3),
  NSTextAlignmentNatural(4);

  final int value;
  const NSTextAlignment(this.value);

  static NSTextAlignment fromValue(int value) => switch (value) {
    0 => NSTextAlignmentLeft,
    1 => NSTextAlignmentCenter,
    2 => NSTextAlignmentRight,
    3 => NSTextAlignmentJustified,
    4 => NSTextAlignmentNatural,
    _ => throw ArgumentError('Unknown value for NSTextAlignment: $value'),
  };
}

enum NSLineBreakMode {
  NSLineBreakByWordWrapping(0),
  NSLineBreakByCharWrapping(1),
  NSLineBreakByClipping(2),
  NSLineBreakByTruncatingHead(3),
  NSLineBreakByTruncatingTail(4),
  NSLineBreakByTruncatingMiddle(5);

  final int value;
  const NSLineBreakMode(this.value);

  static NSLineBreakMode fromValue(int value) => switch (value) {
    0 => NSLineBreakByWordWrapping,
    1 => NSLineBreakByCharWrapping,
    2 => NSLineBreakByClipping,
    3 => NSLineBreakByTruncatingHead,
    4 => NSLineBreakByTruncatingTail,
    5 => NSLineBreakByTruncatingMiddle,
    _ => throw ArgumentError('Unknown value for NSLineBreakMode: $value'),
  };
}

sealed class NSLineBreakStrategy {
  static const NSLineBreakStrategyNone = 0;
  static const NSLineBreakStrategyPushOut = 1;
  static const NSLineBreakStrategyHangulWordPriority = 2;
  static const NSLineBreakStrategyStandard = 65535;
}

enum UIBaselineAdjustment {
  UIBaselineAdjustmentAlignBaselines(0),
  UIBaselineAdjustmentAlignCenters(1),
  UIBaselineAdjustmentNone(2);

  final int value;
  const UIBaselineAdjustment(this.value);

  static UIBaselineAdjustment fromValue(int value) => switch (value) {
    0 => UIBaselineAdjustmentAlignBaselines,
    1 => UIBaselineAdjustmentAlignCenters,
    2 => UIBaselineAdjustmentNone,
    _ => throw ArgumentError('Unknown value for UIBaselineAdjustment: $value'),
  };
}

enum UITextAutocapitalizationType {
  UITextAutocapitalizationTypeNone(0),
  UITextAutocapitalizationTypeWords(1),
  UITextAutocapitalizationTypeSentences(2),
  UITextAutocapitalizationTypeAllCharacters(3);

  final int value;
  const UITextAutocapitalizationType(this.value);

  static UITextAutocapitalizationType fromValue(int value) => switch (value) {
    0 => UITextAutocapitalizationTypeNone,
    1 => UITextAutocapitalizationTypeWords,
    2 => UITextAutocapitalizationTypeSentences,
    3 => UITextAutocapitalizationTypeAllCharacters,
    _ => throw ArgumentError('Unknown value for UITextAutocapitalizationType: $value'),
  };
}

enum UITextAutocorrectionType {
  UITextAutocorrectionTypeDefault(0),
  UITextAutocorrectionTypeNo(1),
  UITextAutocorrectionTypeYes(2);

  final int value;
  const UITextAutocorrectionType(this.value);

  static UITextAutocorrectionType fromValue(int value) => switch (value) {
    0 => UITextAutocorrectionTypeDefault,
    1 => UITextAutocorrectionTypeNo,
    2 => UITextAutocorrectionTypeYes,
    _ => throw ArgumentError('Unknown value for UITextAutocorrectionType: $value'),
  };
}

enum UITextSpellCheckingType {
  UITextSpellCheckingTypeDefault(0),
  UITextSpellCheckingTypeNo(1),
  UITextSpellCheckingTypeYes(2);

  final int value;
  const UITextSpellCheckingType(this.value);

  static UITextSpellCheckingType fromValue(int value) => switch (value) {
    0 => UITextSpellCheckingTypeDefault,
    1 => UITextSpellCheckingTypeNo,
    2 => UITextSpellCheckingTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSpellCheckingType: $value'),
  };
}

enum UITextSmartQuotesType {
  UITextSmartQuotesTypeDefault(0),
  UITextSmartQuotesTypeNo(1),
  UITextSmartQuotesTypeYes(2);

  final int value;
  const UITextSmartQuotesType(this.value);

  static UITextSmartQuotesType fromValue(int value) => switch (value) {
    0 => UITextSmartQuotesTypeDefault,
    1 => UITextSmartQuotesTypeNo,
    2 => UITextSmartQuotesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartQuotesType: $value'),
  };
}

enum UITextSmartDashesType {
  UITextSmartDashesTypeDefault(0),
  UITextSmartDashesTypeNo(1),
  UITextSmartDashesTypeYes(2);

  final int value;
  const UITextSmartDashesType(this.value);

  static UITextSmartDashesType fromValue(int value) => switch (value) {
    0 => UITextSmartDashesTypeDefault,
    1 => UITextSmartDashesTypeNo,
    2 => UITextSmartDashesTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartDashesType: $value'),
  };
}

enum UITextSmartInsertDeleteType {
  UITextSmartInsertDeleteTypeDefault(0),
  UITextSmartInsertDeleteTypeNo(1),
  UITextSmartInsertDeleteTypeYes(2);

  final int value;
  const UITextSmartInsertDeleteType(this.value);

  static UITextSmartInsertDeleteType fromValue(int value) => switch (value) {
    0 => UITextSmartInsertDeleteTypeDefault,
    1 => UITextSmartInsertDeleteTypeNo,
    2 => UITextSmartInsertDeleteTypeYes,
    _ => throw ArgumentError('Unknown value for UITextSmartInsertDeleteType: $value'),
  };
}

enum UIKeyboardType {
  UIKeyboardTypeDefault(0),
  UIKeyboardTypeASCIICapable(1),
  UIKeyboardTypeNumbersAndPunctuation(2),
  UIKeyboardTypeURL(3),
  UIKeyboardTypeNumberPad(4),
  UIKeyboardTypePhonePad(5),
  UIKeyboardTypeNamePhonePad(6),
  UIKeyboardTypeEmailAddress(7),
  UIKeyboardTypeDecimalPad(8),
  UIKeyboardTypeTwitter(9),
  UIKeyboardTypeWebSearch(10),
  UIKeyboardTypeASCIICapableNumberPad(11);

  static const UIKeyboardTypeAlphabet = UIKeyboardTypeASCIICapable;

  final int value;
  const UIKeyboardType(this.value);

  static UIKeyboardType fromValue(int value) => switch (value) {
    0 => UIKeyboardTypeDefault,
    1 => UIKeyboardTypeASCIICapable,
    2 => UIKeyboardTypeNumbersAndPunctuation,
    3 => UIKeyboardTypeURL,
    4 => UIKeyboardTypeNumberPad,
    5 => UIKeyboardTypePhonePad,
    6 => UIKeyboardTypeNamePhonePad,
    7 => UIKeyboardTypeEmailAddress,
    8 => UIKeyboardTypeDecimalPad,
    9 => UIKeyboardTypeTwitter,
    10 => UIKeyboardTypeWebSearch,
    11 => UIKeyboardTypeASCIICapableNumberPad,
    _ => throw ArgumentError('Unknown value for UIKeyboardType: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardTypeASCIICapable)
      return "UIKeyboardType.UIKeyboardTypeASCIICapable, UIKeyboardType.UIKeyboardTypeAlphabet";
    return super.toString();
  }
}

enum UIKeyboardAppearance {
  UIKeyboardAppearanceDefault(0),
  UIKeyboardAppearanceDark(1),
  UIKeyboardAppearanceLight(2);

  static const UIKeyboardAppearanceAlert = UIKeyboardAppearanceDark;

  final int value;
  const UIKeyboardAppearance(this.value);

  static UIKeyboardAppearance fromValue(int value) => switch (value) {
    0 => UIKeyboardAppearanceDefault,
    1 => UIKeyboardAppearanceDark,
    2 => UIKeyboardAppearanceLight,
    _ => throw ArgumentError('Unknown value for UIKeyboardAppearance: $value'),
  };

  @override
  String toString() {
    if (this == UIKeyboardAppearanceDark)
      return "UIKeyboardAppearance.UIKeyboardAppearanceDark, UIKeyboardAppearance.UIKeyboardAppearanceAlert";
    return super.toString();
  }
}

enum UIReturnKeyType {
  UIReturnKeyDefault(0),
  UIReturnKeyGo(1),
  UIReturnKeyGoogle(2),
  UIReturnKeyJoin(3),
  UIReturnKeyNext(4),
  UIReturnKeyRoute(5),
  UIReturnKeySearch(6),
  UIReturnKeySend(7),
  UIReturnKeyYahoo(8),
  UIReturnKeyDone(9),
  UIReturnKeyEmergencyCall(10),
  UIReturnKeyContinue(11);

  final int value;
  const UIReturnKeyType(this.value);

  static UIReturnKeyType fromValue(int value) => switch (value) {
    0 => UIReturnKeyDefault,
    1 => UIReturnKeyGo,
    2 => UIReturnKeyGoogle,
    3 => UIReturnKeyJoin,
    4 => UIReturnKeyNext,
    5 => UIReturnKeyRoute,
    6 => UIReturnKeySearch,
    7 => UIReturnKeySend,
    8 => UIReturnKeyYahoo,
    9 => UIReturnKeyDone,
    10 => UIReturnKeyEmergencyCall,
    11 => UIReturnKeyContinue,
    _ => throw ArgumentError('Unknown value for UIReturnKeyType: $value'),
  };
}

/// WARNING: UITextInputTraits is a stub. To generate bindings for this class, include
/// UITextInputTraits in your config's objc-protocols list.
///
/// UITextInputTraits
interface class UITextInputTraits extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UITextInputTraits._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITextInputTraits] that points to the same underlying object as [other].
  UITextInputTraits.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInputTraits] that wraps the given raw object pointer.
  UITextInputTraits.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIKeyInput is a stub. To generate bindings for this class, include
/// UIKeyInput in your config's objc-protocols list.
///
/// UIKeyInput
interface class UIKeyInput extends objc.ObjCProtocolBase implements UITextInputTraits {
  UIKeyInput._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIKeyInput] that points to the same underlying object as [other].
  UIKeyInput.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIKeyInput] that wraps the given raw object pointer.
  UIKeyInput.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum UITextStorageDirection {
  UITextStorageDirectionForward(0),
  UITextStorageDirectionBackward(1);

  final int value;
  const UITextStorageDirection(this.value);

  static UITextStorageDirection fromValue(int value) => switch (value) {
    0 => UITextStorageDirectionForward,
    1 => UITextStorageDirectionBackward,
    _ => throw ArgumentError('Unknown value for UITextStorageDirection: $value'),
  };
}

enum UITextLayoutDirection {
  UITextLayoutDirectionRight(2),
  UITextLayoutDirectionLeft(3),
  UITextLayoutDirectionUp(4),
  UITextLayoutDirectionDown(5);

  final int value;
  const UITextLayoutDirection(this.value);

  static UITextLayoutDirection fromValue(int value) => switch (value) {
    2 => UITextLayoutDirectionRight,
    3 => UITextLayoutDirectionLeft,
    4 => UITextLayoutDirectionUp,
    5 => UITextLayoutDirectionDown,
    _ => throw ArgumentError('Unknown value for UITextLayoutDirection: $value'),
  };
}

enum UITextGranularity {
  UITextGranularityCharacter(0),
  UITextGranularityWord(1),
  UITextGranularitySentence(2),
  UITextGranularityParagraph(3),
  UITextGranularityLine(4),
  UITextGranularityDocument(5);

  final int value;
  const UITextGranularity(this.value);

  static UITextGranularity fromValue(int value) => switch (value) {
    0 => UITextGranularityCharacter,
    1 => UITextGranularityWord,
    2 => UITextGranularitySentence,
    3 => UITextGranularityParagraph,
    4 => UITextGranularityLine,
    5 => UITextGranularityDocument,
    _ => throw ArgumentError('Unknown value for UITextGranularity: $value'),
  };
}

enum UITextAlternativeStyle {
  UITextAlternativeStyleNone(0),
  UITextAlternativeStyleLowConfidence(1);

  final int value;
  const UITextAlternativeStyle(this.value);

  static UITextAlternativeStyle fromValue(int value) => switch (value) {
    0 => UITextAlternativeStyleNone,
    1 => UITextAlternativeStyleLowConfidence,
    _ => throw ArgumentError('Unknown value for UITextAlternativeStyle: $value'),
  };
}

/// WARNING: UITextInput is a stub. To generate bindings for this class, include
/// UITextInput in your config's objc-protocols list.
///
/// UITextInput
interface class UITextInput extends objc.ObjCProtocolBase implements UIKeyInput {
  UITextInput._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UITextInput] that points to the same underlying object as [other].
  UITextInput.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextInput] that wraps the given raw object pointer.
  UITextInput.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UIContentSizeCategoryAdjusting is a stub. To generate bindings for this class, include
/// UIContentSizeCategoryAdjusting in your config's objc-protocols list.
///
/// UIContentSizeCategoryAdjusting
interface class UIContentSizeCategoryAdjusting extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIContentSizeCategoryAdjusting._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIContentSizeCategoryAdjusting] that points to the same underlying object as [other].
  UIContentSizeCategoryAdjusting.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIContentSizeCategoryAdjusting] that wraps the given raw object pointer.
  UIContentSizeCategoryAdjusting.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

enum UITextBorderStyle {
  UITextBorderStyleNone(0),
  UITextBorderStyleLine(1),
  UITextBorderStyleBezel(2),
  UITextBorderStyleRoundedRect(3);

  final int value;
  const UITextBorderStyle(this.value);

  static UITextBorderStyle fromValue(int value) => switch (value) {
    0 => UITextBorderStyleNone,
    1 => UITextBorderStyleLine,
    2 => UITextBorderStyleBezel,
    3 => UITextBorderStyleRoundedRect,
    _ => throw ArgumentError('Unknown value for UITextBorderStyle: $value'),
  };
}

enum UITextFieldViewMode {
  UITextFieldViewModeNever(0),
  UITextFieldViewModeWhileEditing(1),
  UITextFieldViewModeUnlessEditing(2),
  UITextFieldViewModeAlways(3);

  final int value;
  const UITextFieldViewMode(this.value);

  static UITextFieldViewMode fromValue(int value) => switch (value) {
    0 => UITextFieldViewModeNever,
    1 => UITextFieldViewModeWhileEditing,
    2 => UITextFieldViewModeUnlessEditing,
    3 => UITextFieldViewModeAlways,
    _ => throw ArgumentError('Unknown value for UITextFieldViewMode: $value'),
  };
}

enum UITextFieldDidEndEditingReason {
  UITextFieldDidEndEditingReasonCommitted(0),
  UITextFieldDidEndEditingReasonCancelled(1);

  final int value;
  const UITextFieldDidEndEditingReason(this.value);

  static UITextFieldDidEndEditingReason fromValue(int value) => switch (value) {
    0 => UITextFieldDidEndEditingReasonCommitted,
    1 => UITextFieldDidEndEditingReasonCancelled,
    _ => throw ArgumentError('Unknown value for UITextFieldDidEndEditingReason: $value'),
  };
}

/// WARNING: UITextField$1 is a stub. To generate bindings for this class, include
/// UITextField in your config's objc-interfaces list.
///
/// UITextField
class UITextField$1 extends UIControl implements UITextInput, objc.NSCoding, UIContentSizeCategoryAdjusting {
  UITextField$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UITextField', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UITextField$1] that points to the same underlying object as [other].
  UITextField$1.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITextField$1] that wraps the given raw object pointer.
  UITextField$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

sealed class UIRemoteNotificationType {
  static const UIRemoteNotificationTypeNone = 0;
  static const UIRemoteNotificationTypeBadge = 1;
  static const UIRemoteNotificationTypeSound = 2;
  static const UIRemoteNotificationTypeAlert = 4;
  static const UIRemoteNotificationTypeNewsstandContentAvailability = 8;
}

enum UIBackgroundFetchResult {
  UIBackgroundFetchResultNewData(0),
  UIBackgroundFetchResultNoData(1),
  UIBackgroundFetchResultFailed(2);

  final int value;
  const UIBackgroundFetchResult(this.value);

  static UIBackgroundFetchResult fromValue(int value) => switch (value) {
    0 => UIBackgroundFetchResultNewData,
    1 => UIBackgroundFetchResultNoData,
    2 => UIBackgroundFetchResultFailed,
    _ => throw ArgumentError('Unknown value for UIBackgroundFetchResult: $value'),
  };
}

enum UIBackgroundRefreshStatus {
  UIBackgroundRefreshStatusRestricted(0),
  UIBackgroundRefreshStatusDenied(1),
  UIBackgroundRefreshStatusAvailable(2);

  final int value;
  const UIBackgroundRefreshStatus(this.value);

  static UIBackgroundRefreshStatus fromValue(int value) => switch (value) {
    0 => UIBackgroundRefreshStatusRestricted,
    1 => UIBackgroundRefreshStatusDenied,
    2 => UIBackgroundRefreshStatusAvailable,
    _ => throw ArgumentError('Unknown value for UIBackgroundRefreshStatus: $value'),
  };
}

enum UIApplicationState {
  UIApplicationStateActive(0),
  UIApplicationStateInactive(1),
  UIApplicationStateBackground(2);

  final int value;
  const UIApplicationState(this.value);

  static UIApplicationState fromValue(int value) => switch (value) {
    0 => UIApplicationStateActive,
    1 => UIApplicationStateInactive,
    2 => UIApplicationStateBackground,
    _ => throw ArgumentError('Unknown value for UIApplicationState: $value'),
  };
}

late final _class_UIApplication = objc.getClass("UIApplication");
late final _sel_sharedApplication = objc.registerName("sharedApplication");

/// WARNING: UIApplicationDelegate is a stub. To generate bindings for this class, include
/// UIApplicationDelegate in your config's objc-protocols list.
///
/// UIApplicationDelegate
interface class UIApplicationDelegate extends objc.ObjCProtocolBase implements objc.NSObjectProtocol {
  UIApplicationDelegate._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIApplicationDelegate] that points to the same underlying object as [other].
  UIApplicationDelegate.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIApplicationDelegate] that wraps the given raw object pointer.
  UIApplicationDelegate.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_beginIgnoringInteractionEvents = objc.registerName("beginIgnoringInteractionEvents");
late final _sel_endIgnoringInteractionEvents = objc.registerName("endIgnoringInteractionEvents");
late final _sel_isIgnoringInteractionEvents = objc.registerName("isIgnoringInteractionEvents");
late final _sel_isIdleTimerDisabled = objc.registerName("isIdleTimerDisabled");
late final _sel_setIdleTimerDisabled_ = objc.registerName("setIdleTimerDisabled:");
late final _sel_openURL_ = objc.registerName("openURL:");
late final _sel_canOpenURL_ = objc.registerName("canOpenURL:");
late final _sel_openURL_options_completionHandler_ = objc.registerName("openURL:options:completionHandler:");
final _objc_msgSend_18qun1e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_keyWindow = objc.registerName("keyWindow");
late final _sel_windows = objc.registerName("windows");
late final _sel_sendAction_to_from_forEvent_ = objc.registerName("sendAction:to:from:forEvent:");
final _objc_msgSend_175fj4e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
      )
    >();
late final _sel_isNetworkActivityIndicatorVisible = objc.registerName("isNetworkActivityIndicatorVisible");
late final _sel_setNetworkActivityIndicatorVisible_ = objc.registerName("setNetworkActivityIndicatorVisible:");
late final _sel_statusBarStyle = objc.registerName("statusBarStyle");
late final _sel_isStatusBarHidden = objc.registerName("isStatusBarHidden");
late final _sel_statusBarOrientation = objc.registerName("statusBarOrientation");
late final _sel_supportedInterfaceOrientationsForWindow_ = objc.registerName(
  "supportedInterfaceOrientationsForWindow:",
);
final _objc_msgSend_1369ey = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)
    >();
late final _sel_statusBarOrientationAnimationDuration = objc.registerName("statusBarOrientationAnimationDuration");
late final _sel_statusBarFrame = objc.registerName("statusBarFrame");
late final _sel_applicationIconBadgeNumber = objc.registerName("applicationIconBadgeNumber");
late final _sel_setApplicationIconBadgeNumber_ = objc.registerName("setApplicationIconBadgeNumber:");
late final _sel_applicationSupportsShakeToEdit = objc.registerName("applicationSupportsShakeToEdit");
late final _sel_setApplicationSupportsShakeToEdit_ = objc.registerName("setApplicationSupportsShakeToEdit:");
late final _sel_applicationState = objc.registerName("applicationState");
final _objc_msgSend_10g89zc = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_backgroundTimeRemaining = objc.registerName("backgroundTimeRemaining");
late final _sel_beginBackgroundTaskWithExpirationHandler_ = objc.registerName(
  "beginBackgroundTaskWithExpirationHandler:",
);
final _objc_msgSend_10mlopr = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_beginBackgroundTaskWithName_expirationHandler_ = objc.registerName(
  "beginBackgroundTaskWithName:expirationHandler:",
);
final _objc_msgSend_jkkt9d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_endBackgroundTask_ = objc.registerName("endBackgroundTask:");
late final _sel_setMinimumBackgroundFetchInterval_ = objc.registerName("setMinimumBackgroundFetchInterval:");
late final _sel_backgroundRefreshStatus = objc.registerName("backgroundRefreshStatus");
final _objc_msgSend_1499xyo = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isProtectedDataAvailable = objc.registerName("isProtectedDataAvailable");
late final _sel_userInterfaceLayoutDirection = objc.registerName("userInterfaceLayoutDirection");
late final _sel_preferredContentSizeCategory = objc.registerName("preferredContentSizeCategory");
late final _sel_connectedScenes = objc.registerName("connectedScenes");
late final _sel_openSessions = objc.registerName("openSessions");
late final _sel_supportsMultipleScenes = objc.registerName("supportsMultipleScenes");

/// WARNING: UISceneSession is a stub. To generate bindings for this class, include
/// UISceneSession in your config's objc-interfaces list.
///
/// UISceneSession
class UISceneSession extends objc.ObjCObjectBase {
  UISceneSession._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UISceneSession] that points to the same underlying object as [other].
  UISceneSession.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneSession] that wraps the given raw object pointer.
  UISceneSession.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

/// WARNING: UISceneActivationRequestOptions is a stub. To generate bindings for this class, include
/// UISceneActivationRequestOptions in your config's objc-interfaces list.
///
/// UISceneActivationRequestOptions
class UISceneActivationRequestOptions extends objc.NSObject {
  UISceneActivationRequestOptions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISceneActivationRequestOptions', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneActivationRequestOptions] that points to the same underlying object as [other].
  UISceneActivationRequestOptions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneActivationRequestOptions] that wraps the given raw object pointer.
  UISceneActivationRequestOptions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> fromFunction(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> listener(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError)> blocking(
    void Function(objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError)>`.
extension ObjCBlock_ffiVoid_NSError$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSError)> {
  void call(objc.NSError arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_requestSceneSessionActivation_userActivity_options_errorHandler_ = objc.registerName(
  "requestSceneSessionActivation:userActivity:options:errorHandler:",
);
final _objc_msgSend_m7tls4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// WARNING: UISceneDestructionRequestOptions is a stub. To generate bindings for this class, include
/// UISceneDestructionRequestOptions in your config's objc-interfaces list.
///
/// UISceneDestructionRequestOptions
class UISceneDestructionRequestOptions extends objc.NSObject {
  UISceneDestructionRequestOptions._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISceneDestructionRequestOptions', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UISceneDestructionRequestOptions] that points to the same underlying object as [other].
  UISceneDestructionRequestOptions.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISceneDestructionRequestOptions] that wraps the given raw object pointer.
  UISceneDestructionRequestOptions.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_requestSceneSessionDestruction_options_errorHandler_ = objc.registerName(
  "requestSceneSessionDestruction:options:errorHandler:",
);
late final _sel_requestSceneSessionRefresh_ = objc.registerName("requestSceneSessionRefresh:");
late final _sel_registerForRemoteNotifications = objc.registerName("registerForRemoteNotifications");
late final _sel_unregisterForRemoteNotifications = objc.registerName("unregisterForRemoteNotifications");
late final _sel_isRegisteredForRemoteNotifications = objc.registerName("isRegisteredForRemoteNotifications");
late final _sel_registerForRemoteNotificationTypes_ = objc.registerName("registerForRemoteNotificationTypes:");
final _objc_msgSend_46qpcw = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_enabledRemoteNotificationTypes = objc.registerName("enabledRemoteNotificationTypes");
final _objc_msgSend_z1zqgm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIRemoteNotifications
extension UIRemoteNotifications on UIApplication {
  /// enabledRemoteNotificationTypes
  int enabledRemoteNotificationTypes() {
    objc.checkOsVersionInternal('UIApplication.enabledRemoteNotificationTypes', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_z1zqgm(this.ref.pointer, _sel_enabledRemoteNotificationTypes);
  }

  /// isRegisteredForRemoteNotifications
  bool get isRegisteredForRemoteNotifications {
    objc.checkOsVersionInternal('UIApplication.isRegisteredForRemoteNotifications', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isRegisteredForRemoteNotifications);
  }

  /// registerForRemoteNotificationTypes:
  void registerForRemoteNotificationTypes(int types) {
    objc.checkOsVersionInternal('UIApplication.registerForRemoteNotificationTypes:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_46qpcw(this.ref.pointer, _sel_registerForRemoteNotificationTypes_, types);
  }

  /// registerForRemoteNotifications
  void registerForRemoteNotifications() {
    objc.checkOsVersionInternal('UIApplication.registerForRemoteNotifications', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_registerForRemoteNotifications);
  }

  /// unregisterForRemoteNotifications
  void unregisterForRemoteNotifications() {
    objc.checkOsVersionInternal('UIApplication.unregisterForRemoteNotifications', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_unregisterForRemoteNotifications);
  }
}

/// WARNING: UILocalNotification is a stub. To generate bindings for this class, include
/// UILocalNotification in your config's objc-interfaces list.
///
/// UILocalNotification
class UILocalNotification extends objc.ObjCObjectBase {
  UILocalNotification._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UILocalNotification] that points to the same underlying object as [other].
  UILocalNotification.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILocalNotification] that wraps the given raw object pointer.
  UILocalNotification.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

late final _sel_presentLocalNotificationNow_ = objc.registerName("presentLocalNotificationNow:");
late final _sel_scheduleLocalNotification_ = objc.registerName("scheduleLocalNotification:");
late final _sel_cancelLocalNotification_ = objc.registerName("cancelLocalNotification:");
late final _sel_cancelAllLocalNotifications = objc.registerName("cancelAllLocalNotifications");
late final _sel_scheduledLocalNotifications = objc.registerName("scheduledLocalNotifications");
late final _sel_setScheduledLocalNotifications_ = objc.registerName("setScheduledLocalNotifications:");

/// UILocalNotifications
extension UILocalNotifications on UIApplication {
  /// cancelAllLocalNotifications
  void cancelAllLocalNotifications() {
    objc.checkOsVersionInternal('UIApplication.cancelAllLocalNotifications', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_cancelAllLocalNotifications);
  }

  /// cancelLocalNotification:
  void cancelLocalNotification(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.cancelLocalNotification:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_cancelLocalNotification_, notification.ref.pointer);
  }

  /// presentLocalNotificationNow:
  void presentLocalNotificationNow(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.presentLocalNotificationNow:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_presentLocalNotificationNow_, notification.ref.pointer);
  }

  /// scheduleLocalNotification:
  void scheduleLocalNotification(UILocalNotification notification) {
    objc.checkOsVersionInternal('UIApplication.scheduleLocalNotification:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_scheduleLocalNotification_, notification.ref.pointer);
  }

  /// scheduledLocalNotifications
  objc.NSArray? get scheduledLocalNotifications {
    objc.checkOsVersionInternal('UIApplication.scheduledLocalNotifications', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_scheduledLocalNotifications);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// setScheduledLocalNotifications:
  set scheduledLocalNotifications(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIApplication.setScheduledLocalNotifications:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setScheduledLocalNotifications_, value?.ref.pointer ?? ffi.nullptr);
  }
}

/// WARNING: UIUserNotificationSettings$1 is a stub. To generate bindings for this class, include
/// UIUserNotificationSettings in your config's objc-interfaces list.
///
/// UIUserNotificationSettings
class UIUserNotificationSettings$1 extends objc.ObjCObjectBase {
  UIUserNotificationSettings$1._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super(pointer, retain: retain, release: release);

  /// Constructs a [UIUserNotificationSettings$1] that points to the same underlying object as [other].
  UIUserNotificationSettings$1.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIUserNotificationSettings$1] that wraps the given raw object pointer.
  UIUserNotificationSettings$1.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _sel_registerUserNotificationSettings_ = objc.registerName("registerUserNotificationSettings:");
late final _sel_currentUserNotificationSettings = objc.registerName("currentUserNotificationSettings");

/// UIUserNotificationSettings
extension UIUserNotificationSettings on UIApplication {
  /// currentUserNotificationSettings
  UIUserNotificationSettings$1? get currentUserNotificationSettings {
    objc.checkOsVersionInternal('UIApplication.currentUserNotificationSettings', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_currentUserNotificationSettings);
    return $ret.address == 0 ? null : UIUserNotificationSettings$1.castFromPointer($ret, retain: true, release: true);
  }

  /// registerUserNotificationSettings:
  void registerUserNotificationSettings(UIUserNotificationSettings$1 notificationSettings) {
    objc.checkOsVersionInternal('UIApplication.registerUserNotificationSettings:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_registerUserNotificationSettings_, notificationSettings.ref.pointer);
  }
}

late final _sel_beginReceivingRemoteControlEvents = objc.registerName("beginReceivingRemoteControlEvents");
late final _sel_endReceivingRemoteControlEvents = objc.registerName("endReceivingRemoteControlEvents");

/// UIRemoteControlEvents
extension UIRemoteControlEvents on UIApplication {
  /// beginReceivingRemoteControlEvents
  void beginReceivingRemoteControlEvents() {
    objc.checkOsVersionInternal('UIApplication.beginReceivingRemoteControlEvents', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_beginReceivingRemoteControlEvents);
  }

  /// endReceivingRemoteControlEvents
  void endReceivingRemoteControlEvents() {
    objc.checkOsVersionInternal('UIApplication.endReceivingRemoteControlEvents', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endReceivingRemoteControlEvents);
  }
}

late final _sel_setNewsstandIconImage_ = objc.registerName("setNewsstandIconImage:");

/// UINewsstand
extension UINewsstand on UIApplication {
  /// setNewsstandIconImage:
  void setNewsstandIconImage(UIImage? image) {
    objc.checkOsVersionInternal('UIApplication.setNewsstandIconImage:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setNewsstandIconImage_, image?.ref.pointer ?? ffi.nullptr);
  }
}

late final _sel_shortcutItems = objc.registerName("shortcutItems");
late final _sel_setShortcutItems_ = objc.registerName("setShortcutItems:");

/// UIShortcutItems
extension UIShortcutItems on UIApplication {
  /// setShortcutItems:
  set shortcutItems(objc.NSArray? value) {
    objc.checkOsVersionInternal('UIApplication.setShortcutItems:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShortcutItems_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// shortcutItems
  objc.NSArray? get shortcutItems {
    objc.checkOsVersionInternal('UIApplication.shortcutItems', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shortcutItems);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

late final _sel_supportsAlternateIcons = objc.registerName("supportsAlternateIcons");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSError$1 {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> fromFunction(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> listener(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSError?)> blocking(
    void Function(objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) =>
          fn(arg0.address == 0 ? null : objc.NSError.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSError$1$CallExtension on objc.ObjCBlock<ffi.Void Function(objc.NSError?)> {
  void call(objc.NSError? arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr);
}

late final _sel_setAlternateIconName_completionHandler_ = objc.registerName("setAlternateIconName:completionHandler:");
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_alternateIconName = objc.registerName("alternateIconName");

/// UIAlternateApplicationIcons
extension UIAlternateApplicationIcons on UIApplication {
  /// alternateIconName
  objc.NSString? get alternateIconName {
    objc.checkOsVersionInternal('UIApplication.alternateIconName', iOS: (false, (10, 3, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_alternateIconName);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// setAlternateIconName:completionHandler:
  void setAlternateIconName(
    objc.NSString? alternateIconName, {
    objc.ObjCBlock<ffi.Void Function(objc.NSError?)>? completionHandler,
  }) {
    objc.checkOsVersionInternal('UIApplication.setAlternateIconName:completionHandler:', iOS: (false, (10, 3, 0)));
    _objc_msgSend_o762yo(
      this.ref.pointer,
      _sel_setAlternateIconName_completionHandler_,
      alternateIconName?.ref.pointer ?? ffi.nullptr,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// supportsAlternateIcons
  bool get supportsAlternateIcons {
    objc.checkOsVersionInternal('UIApplication.supportsAlternateIcons', iOS: (false, (10, 3, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_supportsAlternateIcons);
  }
}

late final _sel_extendStateRestoration = objc.registerName("extendStateRestoration");
late final _sel_completeStateRestoration = objc.registerName("completeStateRestoration");
late final _sel_ignoreSnapshotOnNextApplicationLaunch = objc.registerName("ignoreSnapshotOnNextApplicationLaunch");
late final _sel_registerObjectForStateRestoration_restorationIdentifier_ = objc.registerName(
  "registerObjectForStateRestoration:restorationIdentifier:",
);

/// UIStateRestoration
extension UIStateRestoration$2 on UIApplication {
  /// completeStateRestoration
  void completeStateRestoration() {
    objc.checkOsVersionInternal('UIApplication.completeStateRestoration', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_completeStateRestoration);
  }

  /// extendStateRestoration
  void extendStateRestoration() {
    objc.checkOsVersionInternal('UIApplication.extendStateRestoration', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_extendStateRestoration);
  }

  /// ignoreSnapshotOnNextApplicationLaunch
  void ignoreSnapshotOnNextApplicationLaunch() {
    objc.checkOsVersionInternal('UIApplication.ignoreSnapshotOnNextApplicationLaunch', iOS: (false, (7, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_ignoreSnapshotOnNextApplicationLaunch);
  }

  /// registerObjectForStateRestoration:restorationIdentifier:
  static void registerObjectForStateRestoration(
    UIStateRestoring object, {
    required objc.NSString restorationIdentifier,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.registerObjectForStateRestoration:restorationIdentifier:',
      iOS: (false, (7, 0, 0)),
    );
    _objc_msgSend_pfv6jd(
      _class_UIApplication,
      _sel_registerObjectForStateRestoration_restorationIdentifier_,
      object.ref.pointer,
      restorationIdentifier.ref.pointer,
    );
  }
}

late final _sel_isProximitySensingEnabled = objc.registerName("isProximitySensingEnabled");
late final _sel_setProximitySensingEnabled_ = objc.registerName("setProximitySensingEnabled:");
late final _sel_setStatusBarHidden_animated_ = objc.registerName("setStatusBarHidden:animated:");
late final _sel_setStatusBarOrientation_ = objc.registerName("setStatusBarOrientation:");
late final _sel_setStatusBarOrientation_animated_ = objc.registerName("setStatusBarOrientation:animated:");
final _objc_msgSend_anbnk2 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_setStatusBarStyle_ = objc.registerName("setStatusBarStyle:");
final _objc_msgSend_k8qzn7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setStatusBarStyle_animated_ = objc.registerName("setStatusBarStyle:animated:");
final _objc_msgSend_qpqgi7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long, ffi.Bool)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int, bool)>();
late final _sel_setStatusBarHidden_ = objc.registerName("setStatusBarHidden:");
late final _sel_setStatusBarHidden_withAnimation_ = objc.registerName("setStatusBarHidden:withAnimation:");
final _objc_msgSend_1huazme = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Bool, ffi.Long)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, bool, int)>();
late final _sel_setKeepAliveTimeout_handler_ = objc.registerName("setKeepAliveTimeout:handler:");
final _objc_msgSend_170zngv = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Double,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        double,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_clearKeepAliveTimeout = objc.registerName("clearKeepAliveTimeout");

/// UIApplicationDeprecated
extension UIApplicationDeprecated on UIApplication {
  /// clearKeepAliveTimeout
  void clearKeepAliveTimeout() {
    objc.checkOsVersionInternal('UIApplication.clearKeepAliveTimeout', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearKeepAliveTimeout);
  }

  /// isProximitySensingEnabled
  bool get isProximitySensingEnabled {
    objc.checkOsVersionInternal('UIApplication.isProximitySensingEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isProximitySensingEnabled);
  }

  /// isStatusBarHidden
  bool get isStatusBarHidden$1 {
    objc.checkOsVersionInternal('UIApplication.isStatusBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isStatusBarHidden);
  }

  /// setKeepAliveTimeout:handler:
  bool setKeepAliveTimeout(double timeout, {objc.ObjCBlock<ffi.Void Function()>? handler}) {
    objc.checkOsVersionInternal('UIApplication.setKeepAliveTimeout:handler:', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_170zngv(
      this.ref.pointer,
      _sel_setKeepAliveTimeout_handler_,
      timeout,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// setProximitySensingEnabled:
  set isProximitySensingEnabled(bool value) {
    objc.checkOsVersionInternal('UIApplication.setProximitySensingEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setProximitySensingEnabled_, value);
  }

  /// setStatusBarHidden:
  set isStatusBarHidden$1(bool value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setStatusBarHidden_, value);
  }

  /// setStatusBarHidden:animated:
  void setStatusBarHidden(bool hidden, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setStatusBarHidden_animated_, hidden, animated);
  }

  /// setStatusBarHidden:withAnimation:
  void setStatusBarHidden$1(bool hidden, {required UIStatusBarAnimation withAnimation}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarHidden:withAnimation:', iOS: (false, (3, 2, 0)));
    _objc_msgSend_1huazme(this.ref.pointer, _sel_setStatusBarHidden_withAnimation_, hidden, withAnimation.value);
  }

  /// setStatusBarOrientation:
  set statusBarOrientation$1(UIInterfaceOrientation value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarOrientation:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13bsfjm(this.ref.pointer, _sel_setStatusBarOrientation_, value.value);
  }

  /// setStatusBarOrientation:animated:
  void setStatusBarOrientation(UIInterfaceOrientation interfaceOrientation, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarOrientation:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_anbnk2(
      this.ref.pointer,
      _sel_setStatusBarOrientation_animated_,
      interfaceOrientation.value,
      animated,
    );
  }

  /// setStatusBarStyle:
  set statusBarStyle$1(UIStatusBarStyle value) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarStyle:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_k8qzn7(this.ref.pointer, _sel_setStatusBarStyle_, value.value);
  }

  /// setStatusBarStyle:animated:
  void setStatusBarStyle(UIStatusBarStyle statusBarStyle, {required bool animated}) {
    objc.checkOsVersionInternal('UIApplication.setStatusBarStyle:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_qpqgi7(this.ref.pointer, _sel_setStatusBarStyle_animated_, statusBarStyle.value, animated);
  }

  /// statusBarOrientation
  UIInterfaceOrientation get statusBarOrientation$1 {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientation', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_statusBarOrientation);
    return UIInterfaceOrientation.fromValue($ret);
  }

  /// statusBarStyle
  UIStatusBarStyle get statusBarStyle$1 {
    objc.checkOsVersionInternal('UIApplication.statusBarStyle', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_statusBarStyle);
    return UIStatusBarStyle.fromValue($ret);
  }
}

/// UIApplication
class UIApplication extends UIResponder {
  UIApplication._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIApplication', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UIApplication] that points to the same underlying object as [other].
  UIApplication.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIApplication] that wraps the given raw object pointer.
  UIApplication.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIApplication].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIApplication);
  }

  /// alloc
  static UIApplication alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_alloc);
    return UIApplication.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIApplication allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIApplication, _sel_allocWithZone_, zone);
    return UIApplication.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIApplication new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_new);
    return UIApplication.castFromPointer($ret, retain: false, release: true);
  }

  /// sharedApplication
  static UIApplication getSharedApplication() {
    final $ret = _objc_msgSend_151sglz(_class_UIApplication, _sel_sharedApplication);
    return UIApplication.castFromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of UIApplication constructed with the default `new` method.
  factory UIApplication() => new$();
}

extension UIApplication$Methods on UIApplication {
  /// applicationIconBadgeNumber
  int get applicationIconBadgeNumber {
    objc.checkOsVersionInternal('UIApplication.applicationIconBadgeNumber', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_applicationIconBadgeNumber);
  }

  /// applicationState
  UIApplicationState get applicationState {
    objc.checkOsVersionInternal('UIApplication.applicationState', iOS: (false, (4, 0, 0)));
    final $ret = _objc_msgSend_10g89zc(this.ref.pointer, _sel_applicationState);
    return UIApplicationState.fromValue($ret);
  }

  /// applicationSupportsShakeToEdit
  bool get applicationSupportsShakeToEdit {
    objc.checkOsVersionInternal('UIApplication.applicationSupportsShakeToEdit', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_applicationSupportsShakeToEdit);
  }

  /// ! When background refresh is available for an application, it may launched or resumed in the background to handle significant
  /// location changes, remote notifications, background fetches, etc. Observe UIApplicationBackgroundRefreshStatusDidChangeNotification to
  /// be notified of changes.
  UIBackgroundRefreshStatus get backgroundRefreshStatus {
    objc.checkOsVersionInternal('UIApplication.backgroundRefreshStatus', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_1499xyo(this.ref.pointer, _sel_backgroundRefreshStatus);
    return UIBackgroundRefreshStatus.fromValue($ret);
  }

  /// backgroundTimeRemaining
  double get backgroundTimeRemaining {
    objc.checkOsVersionInternal('UIApplication.backgroundTimeRemaining', iOS: (false, (4, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_backgroundTimeRemaining)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_backgroundTimeRemaining);
  }

  /// beginBackgroundTaskWithExpirationHandler:
  int beginBackgroundTaskWithExpirationHandler(objc.ObjCBlock<ffi.Void Function()>? handler) {
    objc.checkOsVersionInternal('UIApplication.beginBackgroundTaskWithExpirationHandler:', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_10mlopr(
      this.ref.pointer,
      _sel_beginBackgroundTaskWithExpirationHandler_,
      handler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// beginBackgroundTaskWithName:expirationHandler:
  int beginBackgroundTaskWithName(objc.NSString? taskName, {objc.ObjCBlock<ffi.Void Function()>? expirationHandler}) {
    objc.checkOsVersionInternal(
      'UIApplication.beginBackgroundTaskWithName:expirationHandler:',
      iOS: (false, (7, 0, 0)),
    );
    return _objc_msgSend_jkkt9d(
      this.ref.pointer,
      _sel_beginBackgroundTaskWithName_expirationHandler_,
      taskName?.ref.pointer ?? ffi.nullptr,
      expirationHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// beginIgnoringInteractionEvents
  void beginIgnoringInteractionEvents() {
    objc.checkOsVersionInternal('UIApplication.beginIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_beginIgnoringInteractionEvents);
  }

  /// canOpenURL:
  bool canOpenURL(objc.NSURL url) {
    objc.checkOsVersionInternal('UIApplication.canOpenURL:', iOS: (false, (3, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_canOpenURL_, url.ref.pointer);
  }

  /// connectedScenes
  objc.NSSet get connectedScenes {
    objc.checkOsVersionInternal('UIApplication.connectedScenes', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_connectedScenes);
    return objc.NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// delegate
  UIApplicationDelegate? get delegate {
    objc.checkOsVersionInternal('UIApplication.delegate', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_delegate);
    return $ret.address == 0 ? null : UIApplicationDelegate.castFromPointer($ret, retain: true, release: true);
  }

  /// endBackgroundTask:
  void endBackgroundTask(int identifier) {
    objc.checkOsVersionInternal('UIApplication.endBackgroundTask:', iOS: (false, (4, 0, 0)));
    _objc_msgSend_1i9r4xy(this.ref.pointer, _sel_endBackgroundTask_, identifier);
  }

  /// endIgnoringInteractionEvents
  void endIgnoringInteractionEvents() {
    objc.checkOsVersionInternal('UIApplication.endIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_endIgnoringInteractionEvents);
  }

  /// init
  UIApplication init() {
    objc.checkOsVersionInternal('UIApplication.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIApplication.castFromPointer($ret, retain: false, release: true);
  }

  /// isIdleTimerDisabled
  bool get isIdleTimerDisabled {
    objc.checkOsVersionInternal('UIApplication.isIdleTimerDisabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isIdleTimerDisabled);
  }

  /// isIgnoringInteractionEvents
  bool get isIgnoringInteractionEvents {
    objc.checkOsVersionInternal('UIApplication.isIgnoringInteractionEvents', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isIgnoringInteractionEvents);
  }

  /// isNetworkActivityIndicatorVisible
  bool get isNetworkActivityIndicatorVisible {
    objc.checkOsVersionInternal('UIApplication.isNetworkActivityIndicatorVisible', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isNetworkActivityIndicatorVisible);
  }

  /// isProtectedDataAvailable
  bool get isProtectedDataAvailable {
    objc.checkOsVersionInternal('UIApplication.isProtectedDataAvailable', iOS: (false, (4, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isProtectedDataAvailable);
  }

  /// isStatusBarHidden
  bool get isStatusBarHidden {
    objc.checkOsVersionInternal('UIApplication.isStatusBarHidden', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isStatusBarHidden);
  }

  /// keyWindow
  UIWindow? get keyWindow {
    objc.checkOsVersionInternal('UIApplication.keyWindow', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_keyWindow);
    return $ret.address == 0 ? null : UIWindow.castFromPointer($ret, retain: true, release: true);
  }

  /// openSessions
  objc.NSSet get openSessions {
    objc.checkOsVersionInternal('UIApplication.openSessions', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_openSessions);
    return objc.NSSet.castFromPointer($ret, retain: true, release: true);
  }

  /// openURL:
  bool openURL(objc.NSURL url) {
    objc.checkOsVersionInternal('UIApplication.openURL:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_19nvye5(this.ref.pointer, _sel_openURL_, url.ref.pointer);
  }

  /// openURL:options:completionHandler:
  void openURL$1(
    objc.NSURL url, {
    required objc.NSDictionary options,
    objc.ObjCBlock<ffi.Void Function(ffi.Bool)>? completionHandler,
  }) {
    objc.checkOsVersionInternal('UIApplication.openURL:options:completionHandler:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_18qun1e(
      this.ref.pointer,
      _sel_openURL_options_completionHandler_,
      url.ref.pointer,
      options.ref.pointer,
      completionHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// preferredContentSizeCategory
  objc.NSString get preferredContentSizeCategory {
    objc.checkOsVersionInternal('UIApplication.preferredContentSizeCategory', iOS: (false, (7, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredContentSizeCategory);
    return objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// requestSceneSessionActivation:userActivity:options:errorHandler:
  void requestSceneSessionActivation(
    UISceneSession? sceneSession, {
    NSUserActivity? userActivity,
    UISceneActivationRequestOptions? options,
    objc.ObjCBlock<ffi.Void Function(objc.NSError)>? errorHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.requestSceneSessionActivation:userActivity:options:errorHandler:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_m7tls4(
      this.ref.pointer,
      _sel_requestSceneSessionActivation_userActivity_options_errorHandler_,
      sceneSession?.ref.pointer ?? ffi.nullptr,
      userActivity?.ref.pointer ?? ffi.nullptr,
      options?.ref.pointer ?? ffi.nullptr,
      errorHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// requestSceneSessionDestruction:options:errorHandler:
  void requestSceneSessionDestruction(
    UISceneSession sceneSession, {
    UISceneDestructionRequestOptions? options,
    objc.ObjCBlock<ffi.Void Function(objc.NSError)>? errorHandler,
  }) {
    objc.checkOsVersionInternal(
      'UIApplication.requestSceneSessionDestruction:options:errorHandler:',
      iOS: (false, (13, 0, 0)),
    );
    _objc_msgSend_18qun1e(
      this.ref.pointer,
      _sel_requestSceneSessionDestruction_options_errorHandler_,
      sceneSession.ref.pointer,
      options?.ref.pointer ?? ffi.nullptr,
      errorHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// requestSceneSessionRefresh:
  void requestSceneSessionRefresh(UISceneSession sceneSession) {
    objc.checkOsVersionInternal('UIApplication.requestSceneSessionRefresh:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_requestSceneSessionRefresh_, sceneSession.ref.pointer);
  }

  /// sendAction:to:from:forEvent:
  bool sendAction(
    ffi.Pointer<objc.ObjCSelector> action, {
    objc.ObjCObjectBase? to,
    objc.ObjCObjectBase? from,
    UIEvent? forEvent,
  }) {
    objc.checkOsVersionInternal('UIApplication.sendAction:to:from:forEvent:', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_175fj4e(
      this.ref.pointer,
      _sel_sendAction_to_from_forEvent_,
      action,
      to?.ref.pointer ?? ffi.nullptr,
      from?.ref.pointer ?? ffi.nullptr,
      forEvent?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// sendEvent:
  void sendEvent(UIEvent event) {
    objc.checkOsVersionInternal('UIApplication.sendEvent:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_sendEvent_, event.ref.pointer);
  }

  /// setApplicationIconBadgeNumber:
  set applicationIconBadgeNumber(int value) {
    objc.checkOsVersionInternal('UIApplication.setApplicationIconBadgeNumber:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setApplicationIconBadgeNumber_, value);
  }

  /// setApplicationSupportsShakeToEdit:
  set applicationSupportsShakeToEdit(bool value) {
    objc.checkOsVersionInternal('UIApplication.setApplicationSupportsShakeToEdit:', iOS: (false, (3, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setApplicationSupportsShakeToEdit_, value);
  }

  /// setDelegate:
  set delegate(UIApplicationDelegate? value) {
    objc.checkOsVersionInternal('UIApplication.setDelegate:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setDelegate_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setIdleTimerDisabled:
  set isIdleTimerDisabled(bool value) {
    objc.checkOsVersionInternal('UIApplication.setIdleTimerDisabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setIdleTimerDisabled_, value);
  }

  /// ! The system guarantees that it will not wake up your application for a background fetch more
  /// frequently than the interval provided. Set to UIApplicationBackgroundFetchIntervalMinimum to be
  /// woken as frequently as the system desires, or to UIApplicationBackgroundFetchIntervalNever (the
  /// default) to never be woken for a background fetch.
  ///
  /// This setter will have no effect unless your application has the "fetch"
  /// UIBackgroundMode. See the UIApplicationDelegate method
  /// `application:performFetchWithCompletionHandler:` for more.
  void setMinimumBackgroundFetchInterval(double minimumBackgroundFetchInterval) {
    objc.checkOsVersionInternal('UIApplication.setMinimumBackgroundFetchInterval:', iOS: (false, (7, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumBackgroundFetchInterval_, minimumBackgroundFetchInterval);
  }

  /// setNetworkActivityIndicatorVisible:
  set isNetworkActivityIndicatorVisible(bool value) {
    objc.checkOsVersionInternal('UIApplication.setNetworkActivityIndicatorVisible:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setNetworkActivityIndicatorVisible_, value);
  }

  /// statusBarFrame
  objc.CGRect get statusBarFrame {
    objc.checkOsVersionInternal('UIApplication.statusBarFrame', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret($ptr, this.ref.pointer, _sel_statusBarFrame)
        : $ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_statusBarFrame);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }

  /// statusBarOrientation
  UIInterfaceOrientation get statusBarOrientation {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientation', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_14s25dk(this.ref.pointer, _sel_statusBarOrientation);
    return UIInterfaceOrientation.fromValue($ret);
  }

  /// statusBarOrientationAnimationDuration
  double get statusBarOrientationAnimationDuration {
    objc.checkOsVersionInternal('UIApplication.statusBarOrientationAnimationDuration', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_statusBarOrientationAnimationDuration)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_statusBarOrientationAnimationDuration);
  }

  /// statusBarStyle
  UIStatusBarStyle get statusBarStyle {
    objc.checkOsVersionInternal('UIApplication.statusBarStyle', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_czyja3(this.ref.pointer, _sel_statusBarStyle);
    return UIStatusBarStyle.fromValue($ret);
  }

  /// supportedInterfaceOrientationsForWindow:
  int supportedInterfaceOrientationsForWindow(UIWindow? window) {
    objc.checkOsVersionInternal('UIApplication.supportedInterfaceOrientationsForWindow:', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_1369ey(
      this.ref.pointer,
      _sel_supportedInterfaceOrientationsForWindow_,
      window?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// supportsMultipleScenes
  bool get supportsMultipleScenes {
    objc.checkOsVersionInternal('UIApplication.supportsMultipleScenes', iOS: (false, (13, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_supportsMultipleScenes);
  }

  /// userInterfaceLayoutDirection
  UIUserInterfaceLayoutDirection get userInterfaceLayoutDirection {
    objc.checkOsVersionInternal('UIApplication.userInterfaceLayoutDirection', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_qj4fey(this.ref.pointer, _sel_userInterfaceLayoutDirection);
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// windows
  objc.NSArray get windows {
    objc.checkOsVersionInternal('UIApplication.windows', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_windows);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }
}

enum UISceneCollectionJoinBehavior {
  UISceneCollectionJoinBehaviorAutomatic(0),
  UISceneCollectionJoinBehaviorPreferred(1),
  UISceneCollectionJoinBehaviorDisallowed(2),
  UISceneCollectionJoinBehaviorPreferredWithoutActivating(3);

  final int value;
  const UISceneCollectionJoinBehavior(this.value);

  static UISceneCollectionJoinBehavior fromValue(int value) => switch (value) {
    0 => UISceneCollectionJoinBehaviorAutomatic,
    1 => UISceneCollectionJoinBehaviorPreferred,
    2 => UISceneCollectionJoinBehaviorDisallowed,
    3 => UISceneCollectionJoinBehaviorPreferredWithoutActivating,
    _ => throw ArgumentError('Unknown value for UISceneCollectionJoinBehavior: $value'),
  };
}

enum NSMenuPresentationStyle {
  NSMenuPresentationStyleRegular(0),
  NSMenuPresentationStylePalette(1);

  final int value;
  const NSMenuPresentationStyle(this.value);

  static NSMenuPresentationStyle fromValue(int value) => switch (value) {
    0 => NSMenuPresentationStyleRegular,
    1 => NSMenuPresentationStylePalette,
    _ => throw ArgumentError('Unknown value for NSMenuPresentationStyle: $value'),
  };
}

enum NSMenuSelectionMode {
  NSMenuSelectionModeAutomatic(0),
  NSMenuSelectionModeSelectOne(1),
  NSMenuSelectionModeSelectAny(2);

  final int value;
  const NSMenuSelectionMode(this.value);

  static NSMenuSelectionMode fromValue(int value) => switch (value) {
    0 => NSMenuSelectionModeAutomatic,
    1 => NSMenuSelectionModeSelectOne,
    2 => NSMenuSelectionModeSelectAny,
    _ => throw ArgumentError('Unknown value for NSMenuSelectionMode: $value'),
  };
}

sealed class NSMenuProperties {
  static const NSMenuPropertyItemTitle = 1;
  static const NSMenuPropertyItemAttributedTitle = 2;
  static const NSMenuPropertyItemKeyEquivalent = 4;
  static const NSMenuPropertyItemImage = 8;
  static const NSMenuPropertyItemEnabled = 16;
  static const NSMenuPropertyItemAccessibilityDescription = 32;
}

enum NSToolbarDisplayMode {
  NSToolbarDisplayModeDefault(0),
  NSToolbarDisplayModeIconAndLabel(1),
  NSToolbarDisplayModeIconOnly(2),
  NSToolbarDisplayModeLabelOnly(3);

  final int value;
  const NSToolbarDisplayMode(this.value);

  static NSToolbarDisplayMode fromValue(int value) => switch (value) {
    0 => NSToolbarDisplayModeDefault,
    1 => NSToolbarDisplayModeIconAndLabel,
    2 => NSToolbarDisplayModeIconOnly,
    3 => NSToolbarDisplayModeLabelOnly,
    _ => throw ArgumentError('Unknown value for NSToolbarDisplayMode: $value'),
  };
}

enum NSToolbarSizeMode {
  NSToolbarSizeModeDefault(0),
  NSToolbarSizeModeRegular(1),
  NSToolbarSizeModeSmall(2);

  final int value;
  const NSToolbarSizeMode(this.value);

  static NSToolbarSizeMode fromValue(int value) => switch (value) {
    0 => NSToolbarSizeModeDefault,
    1 => NSToolbarSizeModeRegular,
    2 => NSToolbarSizeModeSmall,
    _ => throw ArgumentError('Unknown value for NSToolbarSizeMode: $value'),
  };
}

/// WARNING: NSToolbar is a stub. To generate bindings for this class, include
/// NSToolbar in your config's objc-interfaces list.
///
/// NSToolbar
class NSToolbar extends objc.NSObject {
  NSToolbar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('NSToolbar', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [NSToolbar] that points to the same underlying object as [other].
  NSToolbar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [NSToolbar] that wraps the given raw object pointer.
  NSToolbar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);
}

enum NSToolbarItemStyle {
  NSToolbarItemStylePlain(0),
  NSToolbarItemStyleProminent(1);

  final int value;
  const NSToolbarItemStyle(this.value);

  static NSToolbarItemStyle fromValue(int value) => switch (value) {
    0 => NSToolbarItemStylePlain,
    1 => NSToolbarItemStyleProminent,
    _ => throw ArgumentError('Unknown value for NSToolbarItemStyle: $value'),
  };
}

enum UITitlebarSeparatorStyle {
  UITitlebarSeparatorStyleAutomatic(0),
  UITitlebarSeparatorStyleNone(1),
  UITitlebarSeparatorStyleLine(2),
  UITitlebarSeparatorStyleShadow(3);

  final int value;
  const UITitlebarSeparatorStyle(this.value);

  static UITitlebarSeparatorStyle fromValue(int value) => switch (value) {
    0 => UITitlebarSeparatorStyleAutomatic,
    1 => UITitlebarSeparatorStyleNone,
    2 => UITitlebarSeparatorStyleLine,
    3 => UITitlebarSeparatorStyleShadow,
    _ => throw ArgumentError('Unknown value for UITitlebarSeparatorStyle: $value'),
  };
}

enum UITitlebarTitleVisibility {
  UITitlebarTitleVisibilityVisible(0),
  UITitlebarTitleVisibilityHidden(1);

  final int value;
  const UITitlebarTitleVisibility(this.value);

  static UITitlebarTitleVisibility fromValue(int value) => switch (value) {
    0 => UITitlebarTitleVisibilityVisible,
    1 => UITitlebarTitleVisibilityHidden,
    _ => throw ArgumentError('Unknown value for UITitlebarTitleVisibility: $value'),
  };
}

enum UITitlebarToolbarStyle {
  UITitlebarToolbarStyleAutomatic(0),
  UITitlebarToolbarStyleExpanded(1),
  UITitlebarToolbarStylePreference(2),
  UITitlebarToolbarStyleUnified(3),
  UITitlebarToolbarStyleUnifiedCompact(4);

  final int value;
  const UITitlebarToolbarStyle(this.value);

  static UITitlebarToolbarStyle fromValue(int value) => switch (value) {
    0 => UITitlebarToolbarStyleAutomatic,
    1 => UITitlebarToolbarStyleExpanded,
    2 => UITitlebarToolbarStylePreference,
    3 => UITitlebarToolbarStyleUnified,
    4 => UITitlebarToolbarStyleUnifiedCompact,
    _ => throw ArgumentError('Unknown value for UITitlebarToolbarStyle: $value'),
  };
}

late final _class_UITitlebar = objc.getClass("UITitlebar");
late final _sel_titleVisibility = objc.registerName("titleVisibility");
final _objc_msgSend_1w8h4wm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTitleVisibility_ = objc.registerName("setTitleVisibility:");
final _objc_msgSend_91112w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_toolbarStyle = objc.registerName("toolbarStyle");
final _objc_msgSend_1p2m5do = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setToolbarStyle_ = objc.registerName("setToolbarStyle:");
final _objc_msgSend_jgznzi = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_separatorStyle = objc.registerName("separatorStyle");
final _objc_msgSend_15x21aw = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setSeparatorStyle_ = objc.registerName("setSeparatorStyle:");
final _objc_msgSend_rbhdpu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setToolbar_ = objc.registerName("setToolbar:");
late final _sel_autoHidesToolbarInFullScreen = objc.registerName("autoHidesToolbarInFullScreen");
late final _sel_setAutoHidesToolbarInFullScreen_ = objc.registerName("setAutoHidesToolbarInFullScreen:");
late final _sel_representedURL = objc.registerName("representedURL");
late final _sel_setRepresentedURL_ = objc.registerName("setRepresentedURL:");

/// UITitlebar
class UITitlebar extends objc.NSObject {
  UITitlebar._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release);

  /// Constructs a [UITitlebar] that points to the same underlying object as [other].
  UITitlebar.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UITitlebar] that wraps the given raw object pointer.
  UITitlebar.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UITitlebar].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UITitlebar);
  }

  /// alloc
  static UITitlebar alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UITitlebar, _sel_alloc);
    return UITitlebar.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UITitlebar allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UITitlebar, _sel_allocWithZone_, zone);
    return UITitlebar.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UITitlebar new$() {
    final $ret = _objc_msgSend_151sglz(_class_UITitlebar, _sel_new);
    return UITitlebar.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UITitlebar constructed with the default `new` method.
  factory UITitlebar() => new$();
}

extension UITitlebar$Methods on UITitlebar {
  /// autoHidesToolbarInFullScreen
  bool get autoHidesToolbarInFullScreen {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_autoHidesToolbarInFullScreen);
  }

  /// init
  UITitlebar init() {
    objc.checkOsVersionInternal('UITitlebar.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UITitlebar.castFromPointer($ret, retain: false, release: true);
  }

  /// representedURL
  objc.NSURL? get representedURL {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_representedURL);
    return $ret.address == 0 ? null : objc.NSURL.castFromPointer($ret, retain: true, release: true);
  }

  /// separatorStyle
  UITitlebarSeparatorStyle get separatorStyle {
    final $ret = _objc_msgSend_15x21aw(this.ref.pointer, _sel_separatorStyle);
    return UITitlebarSeparatorStyle.fromValue($ret);
  }

  /// setAutoHidesToolbarInFullScreen:
  set autoHidesToolbarInFullScreen(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAutoHidesToolbarInFullScreen_, value);
  }

  /// setRepresentedURL:
  set representedURL(objc.NSURL? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setRepresentedURL_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setSeparatorStyle:
  set separatorStyle(UITitlebarSeparatorStyle value) {
    _objc_msgSend_rbhdpu(this.ref.pointer, _sel_setSeparatorStyle_, value.value);
  }

  /// setTitleVisibility:
  set titleVisibility(UITitlebarTitleVisibility value) {
    _objc_msgSend_91112w(this.ref.pointer, _sel_setTitleVisibility_, value.value);
  }

  /// setToolbar:
  set toolbar(NSToolbar? value) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setToolbar_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setToolbarStyle:
  set toolbarStyle(UITitlebarToolbarStyle value) {
    _objc_msgSend_jgznzi(this.ref.pointer, _sel_setToolbarStyle_, value.value);
  }

  /// titleVisibility
  UITitlebarTitleVisibility get titleVisibility {
    final $ret = _objc_msgSend_1w8h4wm(this.ref.pointer, _sel_titleVisibility);
    return UITitlebarTitleVisibility.fromValue($ret);
  }

  /// toolbar
  NSToolbar? get toolbar {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_toolbar);
    return $ret.address == 0 ? null : NSToolbar.castFromPointer($ret, retain: true, release: true);
  }

  /// toolbarStyle
  UITitlebarToolbarStyle get toolbarStyle {
    final $ret = _objc_msgSend_1p2m5do(this.ref.pointer, _sel_toolbarStyle);
    return UITitlebarToolbarStyle.fromValue($ret);
  }
}

enum UIAlertActionStyle {
  UIAlertActionStyleDefault(0),
  UIAlertActionStyleCancel(1),
  UIAlertActionStyleDestructive(2);

  final int value;
  const UIAlertActionStyle(this.value);

  static UIAlertActionStyle fromValue(int value) => switch (value) {
    0 => UIAlertActionStyleDefault,
    1 => UIAlertActionStyleCancel,
    2 => UIAlertActionStyleDestructive,
    _ => throw ArgumentError('Unknown value for UIAlertActionStyle: $value'),
  };
}

enum UIAlertControllerStyle {
  UIAlertControllerStyleActionSheet(0),
  UIAlertControllerStyleAlert(1);

  final int value;
  const UIAlertControllerStyle(this.value);

  static UIAlertControllerStyle fromValue(int value) => switch (value) {
    0 => UIAlertControllerStyleActionSheet,
    1 => UIAlertControllerStyleAlert,
    _ => throw ArgumentError('Unknown value for UIAlertControllerStyle: $value'),
  };
}

late final _class_UIAlertAction = objc.getClass("UIAlertAction");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UIAlertAction)>`.
abstract final class ObjCBlock_ffiVoid_UIAlertAction {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> fromFunction(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> listener(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UIAlertAction)> blocking(
    void Function(UIAlertAction) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UIAlertAction.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UIAlertAction)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UIAlertAction)>`.
extension ObjCBlock_ffiVoid_UIAlertAction$CallExtension on objc.ObjCBlock<ffi.Void Function(UIAlertAction)> {
  void call(UIAlertAction arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_actionWithTitle_style_handler_ = objc.registerName("actionWithTitle:style:handler:");
final _objc_msgSend_cb5j6t = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
final _objc_msgSend_11gy616 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIAlertAction
class UIAlertAction extends objc.NSObject implements objc.NSCopying {
  UIAlertAction._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAlertAction', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIAlertAction] that points to the same underlying object as [other].
  UIAlertAction.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAlertAction] that wraps the given raw object pointer.
  UIAlertAction.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIAlertAction].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIAlertAction);
  }

  /// actionWithTitle:style:handler:
  static UIAlertAction actionWithTitle(
    objc.NSString? title, {
    required UIAlertActionStyle style,
    objc.ObjCBlock<ffi.Void Function(UIAlertAction)>? handler,
  }) {
    objc.checkOsVersionInternal('UIAlertAction.actionWithTitle:style:handler:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_cb5j6t(
      _class_UIAlertAction,
      _sel_actionWithTitle_style_handler_,
      title?.ref.pointer ?? ffi.nullptr,
      style.value,
      handler?.ref.pointer ?? ffi.nullptr,
    );
    return UIAlertAction.castFromPointer($ret, retain: true, release: true);
  }

  /// alloc
  static UIAlertAction alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIAlertAction, _sel_alloc);
    return UIAlertAction.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIAlertAction allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIAlertAction, _sel_allocWithZone_, zone);
    return UIAlertAction.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIAlertAction new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIAlertAction, _sel_new);
    return UIAlertAction.castFromPointer($ret, retain: false, release: true);
  }

  /// Returns a new instance of UIAlertAction constructed with the default `new` method.
  factory UIAlertAction() => new$();
}

extension UIAlertAction$Methods on UIAlertAction {
  /// autorelease
  UIAlertAction autorelease() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIAlertAction.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UIAlertAction init() {
    objc.checkOsVersionInternal('UIAlertAction.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIAlertAction.castFromPointer($ret, retain: false, release: true);
  }

  /// isEnabled
  bool get isEnabled {
    objc.checkOsVersionInternal('UIAlertAction.isEnabled', iOS: (false, (8, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// retain
  UIAlertAction retain() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIAlertAction.castFromPointer($ret, retain: true, release: true);
  }

  /// self
  UIAlertAction self() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIAlertAction.castFromPointer($ret, retain: true, release: true);
  }

  /// setEnabled:
  set isEnabled(bool value) {
    objc.checkOsVersionInternal('UIAlertAction.setEnabled:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// style
  UIAlertActionStyle get style {
    objc.checkOsVersionInternal('UIAlertAction.style', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_11gy616(this.ref.pointer, _sel_style);
    return UIAlertActionStyle.fromValue($ret);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIAlertAction.title', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UIAlertController = objc.getClass("UIAlertController");
late final _sel_alertControllerWithTitle_message_preferredStyle_ = objc.registerName(
  "alertControllerWithTitle:message:preferredStyle:",
);
final _objc_msgSend_1od9gyu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCObject>,
        int,
      )
    >();
late final _sel_addAction_ = objc.registerName("addAction:");
late final _sel_actions = objc.registerName("actions");
late final _sel_preferredAction = objc.registerName("preferredAction");
late final _sel_setPreferredAction_ = objc.registerName("setPreferredAction:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(UITextField$1)>`.
abstract final class ObjCBlock_ffiVoid_UITextField {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> fromFunction(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(UITextField$1)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: true, release: true)),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> listener(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_xtuoz7(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(UITextField$1)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(UITextField$1)> blocking(
    void Function(UITextField$1) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObject> arg0) => fn(UITextField$1.castFromPointer(arg0, retain: false, release: true)),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_xtuoz7(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(UITextField$1)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObject> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObject>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObject>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(UITextField$1)>`.
extension ObjCBlock_ffiVoid_UITextField$CallExtension on objc.ObjCBlock<ffi.Void Function(UITextField$1)> {
  void call(UITextField$1 arg0) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<objc.ObjCObject> arg0)>
      >()
      .asFunction<
        void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<objc.ObjCObject>)
      >()(ref.pointer, arg0.ref.pointer);
}

late final _sel_addTextFieldWithConfigurationHandler_ = objc.registerName("addTextFieldWithConfigurationHandler:");
late final _sel_textFields = objc.registerName("textFields");
late final _sel_message = objc.registerName("message");
late final _sel_setMessage_ = objc.registerName("setMessage:");
late final _sel_preferredStyle = objc.registerName("preferredStyle");
final _objc_msgSend_sx15g0 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();

/// UIAlertController
class UIAlertController extends UIViewController {
  UIAlertController._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIAlertController', iOS: (false, (8, 0, 0)));
  }

  /// Constructs a [UIAlertController] that points to the same underlying object as [other].
  UIAlertController.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIAlertController] that wraps the given raw object pointer.
  UIAlertController.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIAlertController].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIAlertController);
  }

  /// alertControllerWithTitle:message:preferredStyle:
  static UIAlertController alertControllerWithTitle(
    objc.NSString? title, {
    objc.NSString? message,
    required UIAlertControllerStyle preferredStyle,
  }) {
    objc.checkOsVersionInternal(
      'UIAlertController.alertControllerWithTitle:message:preferredStyle:',
      iOS: (false, (8, 0, 0)),
    );
    final $ret = _objc_msgSend_1od9gyu(
      _class_UIAlertController,
      _sel_alertControllerWithTitle_message_preferredStyle_,
      title?.ref.pointer ?? ffi.nullptr,
      message?.ref.pointer ?? ffi.nullptr,
      preferredStyle.value,
    );
    return UIAlertController.castFromPointer($ret, retain: true, release: true);
  }
}

extension UIAlertController$Methods on UIAlertController {
  /// actions
  objc.NSArray get actions {
    objc.checkOsVersionInternal('UIAlertController.actions', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_actions);
    return objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// addAction:
  void addAction(UIAlertAction action) {
    objc.checkOsVersionInternal('UIAlertController.addAction:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_addAction_, action.ref.pointer);
  }

  /// addTextFieldWithConfigurationHandler:
  void addTextFieldWithConfigurationHandler(objc.ObjCBlock<ffi.Void Function(UITextField$1)>? configurationHandler) {
    objc.checkOsVersionInternal('UIAlertController.addTextFieldWithConfigurationHandler:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_f167m6(
      this.ref.pointer,
      _sel_addTextFieldWithConfigurationHandler_,
      configurationHandler?.ref.pointer ?? ffi.nullptr,
    );
  }

  /// initWithCoder:
  UIAlertController? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIAlertController.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithNibName:bundle:
  UIAlertController initWithNibName(objc.NSString? nibNameOrNil, {objc.NSBundle? bundle}) {
    objc.checkOsVersionInternal('UIAlertController.initWithNibName:bundle:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      this.ref.retainAndReturnPointer(),
      _sel_initWithNibName_bundle_,
      nibNameOrNil?.ref.pointer ?? ffi.nullptr,
      bundle?.ref.pointer ?? ffi.nullptr,
    );
    return UIAlertController.castFromPointer($ret, retain: false, release: true);
  }

  /// message
  objc.NSString? get message {
    objc.checkOsVersionInternal('UIAlertController.message', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_message);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredAction
  UIAlertAction? get preferredAction {
    objc.checkOsVersionInternal('UIAlertController.preferredAction', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_preferredAction);
    return $ret.address == 0 ? null : UIAlertAction.castFromPointer($ret, retain: true, release: true);
  }

  /// preferredStyle
  UIAlertControllerStyle get preferredStyle {
    objc.checkOsVersionInternal('UIAlertController.preferredStyle', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_sx15g0(this.ref.pointer, _sel_preferredStyle);
    return UIAlertControllerStyle.fromValue($ret);
  }

  /// setMessage:
  set message(objc.NSString? value) {
    objc.checkOsVersionInternal('UIAlertController.setMessage:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setMessage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setPreferredAction:
  set preferredAction(UIAlertAction? value) {
    objc.checkOsVersionInternal('UIAlertController.setPreferredAction:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setPreferredAction_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTitle:
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UIAlertController.setTitle:', iOS: (false, (8, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// textFields
  objc.NSArray? get textFields {
    objc.checkOsVersionInternal('UIAlertController.textFields', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textFields);
    return $ret.address == 0 ? null : objc.NSArray.castFromPointer($ret, retain: true, release: true);
  }

  /// title
  objc.NSString? get title {
    objc.checkOsVersionInternal('UIAlertController.title', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }
}

/// WARNING: UIBarButtonItemStateAppearance is a stub. To generate bindings for this class, include
/// UIBarButtonItemStateAppearance in your config's objc-interfaces list.
///
/// UIBarButtonItemStateAppearance
class UIBarButtonItemStateAppearance extends objc.NSObject {
  UIBarButtonItemStateAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemStateAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemStateAppearance] that points to the same underlying object as [other].
  UIBarButtonItemStateAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemStateAppearance] that wraps the given raw object pointer.
  UIBarButtonItemStateAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);
}

late final _class_UIBarButtonItemAppearance = objc.getClass("UIBarButtonItemAppearance");
late final _sel_initWithStyle_ = objc.registerName("initWithStyle:");
final _objc_msgSend_1f28exy = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_configureWithDefaultForStyle_ = objc.registerName("configureWithDefaultForStyle:");
late final _sel_normal = objc.registerName("normal");
late final _sel_highlighted = objc.registerName("highlighted");
late final _sel_disabled = objc.registerName("disabled");
late final _sel_focused = objc.registerName("focused");

/// UIBarButtonItemAppearance
class UIBarButtonItemAppearance extends objc.NSObject implements objc.NSCopying, objc.NSSecureCoding {
  UIBarButtonItemAppearance._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance', iOS: (false, (13, 0, 0)));
  }

  /// Constructs a [UIBarButtonItemAppearance] that points to the same underlying object as [other].
  UIBarButtonItemAppearance.castFrom(objc.ObjCObjectBase other)
    : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UIBarButtonItemAppearance] that wraps the given raw object pointer.
  UIBarButtonItemAppearance.castFromPointer(
    ffi.Pointer<objc.ObjCObject> other, {
    bool retain = false,
    bool release = false,
  }) : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UIBarButtonItemAppearance].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UIBarButtonItemAppearance);
  }

  /// alloc
  static UIBarButtonItemAppearance alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItemAppearance, _sel_alloc);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UIBarButtonItemAppearance allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UIBarButtonItemAppearance, _sel_allocWithZone_, zone);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// new
  static UIBarButtonItemAppearance new$() {
    final $ret = _objc_msgSend_151sglz(_class_UIBarButtonItemAppearance, _sel_new);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_UIBarButtonItemAppearance, _sel_supportsSecureCoding);
  }

  /// Returns a new instance of UIBarButtonItemAppearance constructed with the default `new` method.
  factory UIBarButtonItemAppearance() => new$();
}

extension UIBarButtonItemAppearance$Methods on UIBarButtonItemAppearance {
  /// autorelease
  UIBarButtonItemAppearance autorelease() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// Reset this appearance to that of a given style.
  void configureWithDefaultForStyle(UIBarButtonItemStyle style) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.configureWithDefaultForStyle:', iOS: (false, (13, 0, 0)));
    _objc_msgSend_11ist7u(this.ref.pointer, _sel_configureWithDefaultForStyle_, style.value);
  }

  /// copy
  UIBarButtonItemAppearance copy() {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.copy', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_copy);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// The appearance when the bar button item is in the disabled control state. If unspecified, then synthesized from the normal state.
  UIBarButtonItemStateAppearance get disabled {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.disabled', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_disabled);
    return UIBarButtonItemStateAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// The appearance when the bar button item is in the focused control state. If unspecified, then synthesized from the highlighted state.
  UIBarButtonItemStateAppearance get focused {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.focused', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_focused);
    return UIBarButtonItemStateAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// The appearance when the bar button item is in the highlighted control state. If unspecified, then synthesized from the normal state.
  UIBarButtonItemStateAppearance get highlighted {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.highlighted', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_highlighted);
    return UIBarButtonItemStateAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UIBarButtonItemAppearance init() {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UIBarButtonItemAppearance? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// Construct an appearance with default values for the given style.
  UIBarButtonItemAppearance initWithStyle(UIBarButtonItemStyle style) {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.initWithStyle:', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_1f28exy(this.ref.retainAndReturnPointer(), _sel_initWithStyle_, style.value);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: false, release: true);
  }

  /// The appearance when the bar button item is in the normal control state.
  UIBarButtonItemStateAppearance get normal {
    objc.checkOsVersionInternal('UIBarButtonItemAppearance.normal', iOS: (false, (13, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_normal);
    return UIBarButtonItemStateAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// retain
  UIBarButtonItemAppearance retain() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: true, release: true);
  }

  /// self
  UIBarButtonItemAppearance self() {
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return UIBarButtonItemAppearance.castFromPointer($ret, retain: true, release: true);
  }
}

late final _class_UILabel = objc.getClass("UILabel");
late final _sel_text = objc.registerName("text");
late final _sel_setText_ = objc.registerName("setText:");
late final _sel_font = objc.registerName("font");
late final _sel_setFont_ = objc.registerName("setFont:");
late final _sel_textColor = objc.registerName("textColor");
late final _sel_setTextColor_ = objc.registerName("setTextColor:");
late final _sel_shadowOffset = objc.registerName("shadowOffset");
late final _sel_setShadowOffset_ = objc.registerName("setShadowOffset:");
late final _sel_textAlignment = objc.registerName("textAlignment");
final _objc_msgSend_buxwfm = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setTextAlignment_ = objc.registerName("setTextAlignment:");
final _objc_msgSend_12huos = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_lineBreakMode = objc.registerName("lineBreakMode");
final _objc_msgSend_ybsdio = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLineBreakMode_ = objc.registerName("setLineBreakMode:");
final _objc_msgSend_1kdet46 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_attributedText = objc.registerName("attributedText");
late final _sel_setAttributedText_ = objc.registerName("setAttributedText:");
late final _sel_highlightedTextColor = objc.registerName("highlightedTextColor");
late final _sel_setHighlightedTextColor_ = objc.registerName("setHighlightedTextColor:");
late final _sel_numberOfLines = objc.registerName("numberOfLines");
late final _sel_setNumberOfLines_ = objc.registerName("setNumberOfLines:");
late final _sel_adjustsFontSizeToFitWidth = objc.registerName("adjustsFontSizeToFitWidth");
late final _sel_setAdjustsFontSizeToFitWidth_ = objc.registerName("setAdjustsFontSizeToFitWidth:");
late final _sel_baselineAdjustment = objc.registerName("baselineAdjustment");
final _objc_msgSend_1fz8ybf = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setBaselineAdjustment_ = objc.registerName("setBaselineAdjustment:");
final _objc_msgSend_1j9etgn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_minimumScaleFactor = objc.registerName("minimumScaleFactor");
late final _sel_setMinimumScaleFactor_ = objc.registerName("setMinimumScaleFactor:");
late final _sel_allowsDefaultTighteningForTruncation = objc.registerName("allowsDefaultTighteningForTruncation");
late final _sel_setAllowsDefaultTighteningForTruncation_ = objc.registerName(
  "setAllowsDefaultTighteningForTruncation:",
);
late final _sel_lineBreakStrategy = objc.registerName("lineBreakStrategy");
final _objc_msgSend_fcsyxu = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setLineBreakStrategy_ = objc.registerName("setLineBreakStrategy:");
final _objc_msgSend_1eahgd8 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_textRectForBounds_limitedToNumberOfLines_ = objc.registerName(
  "textRectForBounds:limitedToNumberOfLines:",
);
final _objc_msgSend_o8h5mj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, ffi.Long)
      >
    >()
    .asFunction<objc.CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, objc.CGRect, int)>();
final _objc_msgSend_o8h5mjStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.CGRect>,
          ffi.Pointer<objc.ObjCObject>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.CGRect,
          ffi.Long,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.CGRect>,
        ffi.Pointer<objc.ObjCObject>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.CGRect,
        int,
      )
    >();
late final _sel_drawTextInRect_ = objc.registerName("drawTextInRect:");
late final _sel_preferredMaxLayoutWidth = objc.registerName("preferredMaxLayoutWidth");
late final _sel_setPreferredMaxLayoutWidth_ = objc.registerName("setPreferredMaxLayoutWidth:");
late final _sel_enablesMarqueeWhenAncestorFocused = objc.registerName("enablesMarqueeWhenAncestorFocused");
late final _sel_setEnablesMarqueeWhenAncestorFocused_ = objc.registerName("setEnablesMarqueeWhenAncestorFocused:");
late final _sel_showsExpansionTextWhenTruncated = objc.registerName("showsExpansionTextWhenTruncated");
late final _sel_setShowsExpansionTextWhenTruncated_ = objc.registerName("setShowsExpansionTextWhenTruncated:");
late final _sel_minimumFontSize = objc.registerName("minimumFontSize");
late final _sel_setMinimumFontSize_ = objc.registerName("setMinimumFontSize:");
late final _sel_adjustsLetterSpacingToFitWidth = objc.registerName("adjustsLetterSpacingToFitWidth");
late final _sel_setAdjustsLetterSpacingToFitWidth_ = objc.registerName("setAdjustsLetterSpacingToFitWidth:");
late final _sel_adjustsFontForContentSizeCategory = objc.registerName("adjustsFontForContentSizeCategory");
late final _sel_setAdjustsFontForContentSizeCategory_ = objc.registerName("setAdjustsFontForContentSizeCategory:");

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_bool {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> castFromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> listener(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapListenerBlock_10lndml(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> blocking(
    void Function(ffi.Pointer<ffi.Void>, bool) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0, bool arg1) => fn(arg0, arg1),
      keepIsolateAlive,
    );
    final wrapper = _NativeLibrary_wrapBlockingBlock_10lndml(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    bool arg1,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Bool)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) => block
      .ref
      .target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>, bool)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, bool arg1) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>, bool))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Bool)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)>`.
extension ObjCBlock_ffiVoid_ffiVoid_bool$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Bool)> {
  void call(ffi.Pointer<ffi.Void> arg0, bool arg1) =>
      ref.pointer.ref.invoke
          .cast<
            ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Bool arg1)
            >
          >()
          .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, bool)>()(
        ref.pointer,
        arg0,
        arg1,
      );
}

/// UILabel
class UILabel extends UIView implements objc.NSCoding, UIContentSizeCategoryAdjusting {
  UILabel._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UILabel', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UILabel] that points to the same underlying object as [other].
  UILabel.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UILabel] that wraps the given raw object pointer.
  UILabel.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UILabel].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UILabel);
  }

  /// alloc
  static UILabel alloc() {
    final $ret = _objc_msgSend_151sglz(_class_UILabel, _sel_alloc);
    return UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static UILabel allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_UILabel, _sel_allocWithZone_, zone);
    return UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// appearance
  static UILabel appearance() {
    final $ret = _objc_msgSend_151sglz(_class_UILabel, _sel_appearance);
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:
  static UILabel appearanceForTraitCollection(UITraitCollection trait) {
    objc.checkOsVersionInternal('UILabel.appearanceForTraitCollection:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_UILabel, _sel_appearanceForTraitCollection_, trait.ref.pointer);
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedIn:
  static UILabel appearanceForTraitCollection$1(UITraitCollection trait, {UIAppearanceContainer? whenContainedIn}) {
    objc.checkOsVersionInternal('UILabel.appearanceForTraitCollection:whenContainedIn:', iOS: (false, (8, 0, 0)));
    final $ret = _objc_msgSend_15qeuct(
      _class_UILabel,
      _sel_appearanceForTraitCollection_whenContainedIn_,
      trait.ref.pointer,
      whenContainedIn?.ref.pointer ?? ffi.nullptr,
    );
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceForTraitCollection:whenContainedInInstancesOfClasses:
  static UILabel appearanceForTraitCollection$2(
    UITraitCollection trait, {
    required objc.NSArray whenContainedInInstancesOfClasses,
  }) {
    objc.checkOsVersionInternal(
      'UILabel.appearanceForTraitCollection:whenContainedInInstancesOfClasses:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_15qeuct(
      _class_UILabel,
      _sel_appearanceForTraitCollection_whenContainedInInstancesOfClasses_,
      trait.ref.pointer,
      whenContainedInInstancesOfClasses.ref.pointer,
    );
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedIn:
  static UILabel appearanceWhenContainedIn(UIAppearanceContainer? ContainerClass) {
    objc.checkOsVersionInternal('UILabel.appearanceWhenContainedIn:', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UILabel,
      _sel_appearanceWhenContainedIn_,
      ContainerClass?.ref.pointer ?? ffi.nullptr,
    );
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// appearanceWhenContainedInInstancesOfClasses:
  static UILabel appearanceWhenContainedInInstancesOfClasses(objc.NSArray containerTypes) {
    objc.checkOsVersionInternal('UILabel.appearanceWhenContainedInInstancesOfClasses:', iOS: (false, (9, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      _class_UILabel,
      _sel_appearanceWhenContainedInInstancesOfClasses_,
      containerTypes.ref.pointer,
    );
    return UILabel.castFromPointer($ret, retain: true, release: true);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UILabel.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UILabel, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// new
  static UILabel new$() {
    final $ret = _objc_msgSend_151sglz(_class_UILabel, _sel_new);
    return UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UILabel.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UILabel,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UILabel.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UILabel,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// Returns a new instance of UILabel constructed with the default `new` method.
  factory UILabel() => new$();
}

extension UILabel$Methods on UILabel {
  /// adjustsFontForContentSizeCategory
  bool get adjustsFontForContentSizeCategory {
    objc.checkOsVersionInternal('UILabel.adjustsFontForContentSizeCategory', iOS: (false, (10, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsFontForContentSizeCategory);
  }

  /// adjustsFontSizeToFitWidth
  bool get adjustsFontSizeToFitWidth {
    objc.checkOsVersionInternal('UILabel.adjustsFontSizeToFitWidth', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsFontSizeToFitWidth);
  }

  /// adjustsLetterSpacingToFitWidth
  bool get adjustsLetterSpacingToFitWidth {
    objc.checkOsVersionInternal('UILabel.adjustsLetterSpacingToFitWidth', iOS: (false, (6, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_adjustsLetterSpacingToFitWidth);
  }

  /// allowsDefaultTighteningForTruncation
  bool get allowsDefaultTighteningForTruncation {
    objc.checkOsVersionInternal('UILabel.allowsDefaultTighteningForTruncation', iOS: (false, (9, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsDefaultTighteningForTruncation);
  }

  /// attributedText
  objc.NSAttributedString? get attributedText {
    objc.checkOsVersionInternal('UILabel.attributedText', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributedText);
    return $ret.address == 0 ? null : objc.NSAttributedString.castFromPointer($ret, retain: true, release: true);
  }

  /// baselineAdjustment
  UIBaselineAdjustment get baselineAdjustment {
    objc.checkOsVersionInternal('UILabel.baselineAdjustment', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_1fz8ybf(this.ref.pointer, _sel_baselineAdjustment);
    return UIBaselineAdjustment.fromValue($ret);
  }

  /// drawTextInRect:
  void drawTextInRect(objc.CGRect rect) {
    objc.checkOsVersionInternal('UILabel.drawTextInRect:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1okkq16(this.ref.pointer, _sel_drawTextInRect_, rect);
  }

  /// enablesMarqueeWhenAncestorFocused
  bool get enablesMarqueeWhenAncestorFocused {
    objc.checkOsVersionInternal('UILabel.enablesMarqueeWhenAncestorFocused', iOS: (true, null));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_enablesMarqueeWhenAncestorFocused);
  }

  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// font
  UIFont get font {
    objc.checkOsVersionInternal('UILabel.font', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_font);
    return UIFont.castFromPointer($ret, retain: true, release: true);
  }

  /// highlightedTextColor
  UIColor? get highlightedTextColor {
    objc.checkOsVersionInternal('UILabel.highlightedTextColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_highlightedTextColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// init
  UILabel init() {
    objc.checkOsVersionInternal('UILabel.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithCoder:
  UILabel? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UILabel initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UILabel.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UILabel.castFromPointer($ret, retain: false, release: true);
  }

  /// isEnabled
  bool get isEnabled {
    objc.checkOsVersionInternal('UILabel.isEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// isHighlighted
  bool get isHighlighted {
    objc.checkOsVersionInternal('UILabel.isHighlighted', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isHighlighted);
  }

  /// isUserInteractionEnabled
  bool get isUserInteractionEnabled {
    objc.checkOsVersionInternal('UILabel.isUserInteractionEnabled', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isUserInteractionEnabled);
  }

  /// lineBreakMode
  NSLineBreakMode get lineBreakMode {
    objc.checkOsVersionInternal('UILabel.lineBreakMode', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_ybsdio(this.ref.pointer, _sel_lineBreakMode);
    return NSLineBreakMode.fromValue($ret);
  }

  /// lineBreakStrategy
  int get lineBreakStrategy {
    objc.checkOsVersionInternal('UILabel.lineBreakStrategy', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_fcsyxu(this.ref.pointer, _sel_lineBreakStrategy);
  }

  /// minimumFontSize
  double get minimumFontSize {
    objc.checkOsVersionInternal('UILabel.minimumFontSize', iOS: (false, (2, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumFontSize)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumFontSize);
  }

  /// minimumScaleFactor
  double get minimumScaleFactor {
    objc.checkOsVersionInternal('UILabel.minimumScaleFactor', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_minimumScaleFactor)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_minimumScaleFactor);
  }

  /// numberOfLines
  int get numberOfLines {
    objc.checkOsVersionInternal('UILabel.numberOfLines', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_numberOfLines);
  }

  /// preferredMaxLayoutWidth
  double get preferredMaxLayoutWidth {
    objc.checkOsVersionInternal('UILabel.preferredMaxLayoutWidth', iOS: (false, (6, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_preferredMaxLayoutWidth)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_preferredMaxLayoutWidth);
  }

  /// setAdjustsFontForContentSizeCategory:
  set adjustsFontForContentSizeCategory(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsFontForContentSizeCategory:', iOS: (false, (10, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsFontForContentSizeCategory_, value);
  }

  /// setAdjustsFontSizeToFitWidth:
  set adjustsFontSizeToFitWidth(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsFontSizeToFitWidth:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsFontSizeToFitWidth_, value);
  }

  /// setAdjustsLetterSpacingToFitWidth:
  set adjustsLetterSpacingToFitWidth(bool value) {
    objc.checkOsVersionInternal('UILabel.setAdjustsLetterSpacingToFitWidth:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAdjustsLetterSpacingToFitWidth_, value);
  }

  /// setAllowsDefaultTighteningForTruncation:
  set allowsDefaultTighteningForTruncation(bool value) {
    objc.checkOsVersionInternal('UILabel.setAllowsDefaultTighteningForTruncation:', iOS: (false, (9, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setAllowsDefaultTighteningForTruncation_, value);
  }

  /// setAttributedText:
  set attributedText(objc.NSAttributedString? value) {
    objc.checkOsVersionInternal('UILabel.setAttributedText:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setAttributedText_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setBaselineAdjustment:
  set baselineAdjustment(UIBaselineAdjustment value) {
    objc.checkOsVersionInternal('UILabel.setBaselineAdjustment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1j9etgn(this.ref.pointer, _sel_setBaselineAdjustment_, value.value);
  }

  /// setEnabled:
  set isEnabled(bool value) {
    objc.checkOsVersionInternal('UILabel.setEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// setEnablesMarqueeWhenAncestorFocused:
  set enablesMarqueeWhenAncestorFocused(bool value) {
    objc.checkOsVersionInternal('UILabel.setEnablesMarqueeWhenAncestorFocused:', iOS: (true, null));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnablesMarqueeWhenAncestorFocused_, value);
  }

  /// setFont:
  set font(UIFont value) {
    objc.checkOsVersionInternal('UILabel.setFont:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setFont_, value.ref.pointer);
  }

  /// setHighlighted:
  set isHighlighted(bool value) {
    objc.checkOsVersionInternal('UILabel.setHighlighted:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setHighlighted_, value);
  }

  /// setHighlightedTextColor:
  set highlightedTextColor(UIColor? value) {
    objc.checkOsVersionInternal('UILabel.setHighlightedTextColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setHighlightedTextColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setLineBreakMode:
  set lineBreakMode(NSLineBreakMode value) {
    objc.checkOsVersionInternal('UILabel.setLineBreakMode:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1kdet46(this.ref.pointer, _sel_setLineBreakMode_, value.value);
  }

  /// setLineBreakStrategy:
  set lineBreakStrategy(int value) {
    objc.checkOsVersionInternal('UILabel.setLineBreakStrategy:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1eahgd8(this.ref.pointer, _sel_setLineBreakStrategy_, value);
  }

  /// setMinimumFontSize:
  set minimumFontSize(double value) {
    objc.checkOsVersionInternal('UILabel.setMinimumFontSize:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumFontSize_, value);
  }

  /// setMinimumScaleFactor:
  set minimumScaleFactor(double value) {
    objc.checkOsVersionInternal('UILabel.setMinimumScaleFactor:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setMinimumScaleFactor_, value);
  }

  /// setNumberOfLines:
  set numberOfLines(int value) {
    objc.checkOsVersionInternal('UILabel.setNumberOfLines:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_4sp4xj(this.ref.pointer, _sel_setNumberOfLines_, value);
  }

  /// setPreferredMaxLayoutWidth:
  set preferredMaxLayoutWidth(double value) {
    objc.checkOsVersionInternal('UILabel.setPreferredMaxLayoutWidth:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_hwm8nu(this.ref.pointer, _sel_setPreferredMaxLayoutWidth_, value);
  }

  /// setShadowColor:
  set shadowColor(UIColor? value) {
    objc.checkOsVersionInternal('UILabel.setShadowColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setShadowColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setShadowOffset:
  set shadowOffset(objc.CGSize value) {
    objc.checkOsVersionInternal('UILabel.setShadowOffset:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_13lgpwz(this.ref.pointer, _sel_setShadowOffset_, value);
  }

  /// Indicates whether expansion text will be shown when the view is too small to show all the contents. Defaults to NO.
  set showsExpansionTextWhenTruncated(bool value) {
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setShowsExpansionTextWhenTruncated_, value);
  }

  /// setText:
  set text(objc.NSString? value) {
    objc.checkOsVersionInternal('UILabel.setText:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setText_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setTextAlignment:
  set textAlignment(NSTextAlignment value) {
    objc.checkOsVersionInternal('UILabel.setTextAlignment:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_12huos(this.ref.pointer, _sel_setTextAlignment_, value.value);
  }

  /// setTextColor:
  set textColor(UIColor value) {
    objc.checkOsVersionInternal('UILabel.setTextColor:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTextColor_, value.ref.pointer);
  }

  /// setUserInteractionEnabled:
  set isUserInteractionEnabled(bool value) {
    objc.checkOsVersionInternal('UILabel.setUserInteractionEnabled:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setUserInteractionEnabled_, value);
  }

  /// shadowColor
  UIColor? get shadowColor {
    objc.checkOsVersionInternal('UILabel.shadowColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_shadowColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// shadowOffset
  objc.CGSize get shadowOffset {
    objc.checkOsVersionInternal('UILabel.shadowOffset', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret($ptr, this.ref.pointer, _sel_shadowOffset)
        : $ptr.ref = _objc_msgSend_1vdfken(this.ref.pointer, _sel_shadowOffset);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGSize>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGSize>($finalizable);
  }

  /// Indicates whether expansion text will be shown when the view is too small to show all the contents. Defaults to NO.
  bool get showsExpansionTextWhenTruncated {
    return _objc_msgSend_91o635(this.ref.pointer, _sel_showsExpansionTextWhenTruncated);
  }

  /// text
  objc.NSString? get text {
    objc.checkOsVersionInternal('UILabel.text', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_text);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }

  /// textAlignment
  NSTextAlignment get textAlignment {
    objc.checkOsVersionInternal('UILabel.textAlignment', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_buxwfm(this.ref.pointer, _sel_textAlignment);
    return NSTextAlignment.fromValue($ret);
  }

  /// textColor
  UIColor get textColor {
    objc.checkOsVersionInternal('UILabel.textColor', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_textColor);
    return UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// textRectForBounds:limitedToNumberOfLines:
  objc.CGRect textRectForBounds(objc.CGRect bounds, {required int limitedToNumberOfLines}) {
    objc.checkOsVersionInternal('UILabel.textRectForBounds:limitedToNumberOfLines:', iOS: (false, (2, 0, 0)));
    final $ptr = pkg_ffi.calloc<objc.CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_o8h5mjStret(
            $ptr,
            this.ref.pointer,
            _sel_textRectForBounds_limitedToNumberOfLines_,
            bounds,
            limitedToNumberOfLines,
          )
        : $ptr.ref = _objc_msgSend_o8h5mj(
            this.ref.pointer,
            _sel_textRectForBounds_limitedToNumberOfLines_,
            bounds,
            limitedToNumberOfLines,
          );
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.CGRect>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.CGRect>($finalizable);
  }
}

enum UIGestureRecognizerState {
  UIGestureRecognizerStatePossible(0),
  UIGestureRecognizerStateBegan(1),
  UIGestureRecognizerStateChanged(2),
  UIGestureRecognizerStateEnded(3),
  UIGestureRecognizerStateCancelled(4),
  UIGestureRecognizerStateFailed(5);

  static const UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded;

  final int value;
  const UIGestureRecognizerState(this.value);

  static UIGestureRecognizerState fromValue(int value) => switch (value) {
    0 => UIGestureRecognizerStatePossible,
    1 => UIGestureRecognizerStateBegan,
    2 => UIGestureRecognizerStateChanged,
    3 => UIGestureRecognizerStateEnded,
    4 => UIGestureRecognizerStateCancelled,
    5 => UIGestureRecognizerStateFailed,
    _ => throw ArgumentError('Unknown value for UIGestureRecognizerState: $value'),
  };

  @override
  String toString() {
    if (this == UIGestureRecognizerStateEnded)
      return "UIGestureRecognizerState.UIGestureRecognizerStateEnded, UIGestureRecognizerState.UIGestureRecognizerStateRecognized";
    return super.toString();
  }
}

sealed class UIScrollTypeMask {
  static const UIScrollTypeMaskDiscrete = 1;
  static const UIScrollTypeMaskContinuous = 2;
  static const UIScrollTypeMaskAll = 3;
}

/// !
/// UINavigationController manages a stack of view controllers and a navigation bar.
/// It performs horizontal view transitions for pushed and popped views while keeping the navigation bar in sync.
///
/// Most clients will not need to subclass UINavigationController.
///
/// If a navigation controller is nested in a tab bar controller, it uses the title and toolbar attributes of the bottom view controller on the stack.
///
/// UINavigationController is rotatable if its top view controller is rotatable.
/// Navigation between controllers with non-uniform rotatability is currently not supported.
enum UINavigationControllerOperation {
  UINavigationControllerOperationNone(0),
  UINavigationControllerOperationPush(1),
  UINavigationControllerOperationPop(2);

  final int value;
  const UINavigationControllerOperation(this.value);

  static UINavigationControllerOperation fromValue(int value) => switch (value) {
    0 => UINavigationControllerOperationNone,
    1 => UINavigationControllerOperationPush,
    2 => UINavigationControllerOperationPop,
    _ => throw ArgumentError('Unknown value for UINavigationControllerOperation: $value'),
  };
}

enum UISwitchStyle {
  UISwitchStyleAutomatic(0),
  UISwitchStyleCheckbox(1),
  UISwitchStyleSliding(2);

  final int value;
  const UISwitchStyle(this.value);

  static UISwitchStyle fromValue(int value) => switch (value) {
    0 => UISwitchStyleAutomatic,
    1 => UISwitchStyleCheckbox,
    2 => UISwitchStyleSliding,
    _ => throw ArgumentError('Unknown value for UISwitchStyle: $value'),
  };
}

late final _class_UISwitch = objc.getClass("UISwitch");
late final _sel_onTintColor = objc.registerName("onTintColor");
late final _sel_setOnTintColor_ = objc.registerName("setOnTintColor:");
late final _sel_thumbTintColor = objc.registerName("thumbTintColor");
late final _sel_setThumbTintColor_ = objc.registerName("setThumbTintColor:");
late final _sel_onImage = objc.registerName("onImage");
late final _sel_setOnImage_ = objc.registerName("setOnImage:");
late final _sel_offImage = objc.registerName("offImage");
late final _sel_setOffImage_ = objc.registerName("setOffImage:");
final _objc_msgSend_ums1js = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setPreferredStyle_ = objc.registerName("setPreferredStyle:");
final _objc_msgSend_1bkwtnu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isOn = objc.registerName("isOn");
late final _sel_setOn_ = objc.registerName("setOn:");
late final _sel_setOn_animated_ = objc.registerName("setOn:animated:");

/// UISwitch
class UISwitch extends UIControl implements objc.NSCoding {
  UISwitch._(ffi.Pointer<objc.ObjCObject> pointer, {bool retain = false, bool release = false})
    : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('UISwitch', iOS: (false, (2, 0, 0)));
  }

  /// Constructs a [UISwitch] that points to the same underlying object as [other].
  UISwitch.castFrom(objc.ObjCObjectBase other) : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [UISwitch] that wraps the given raw object pointer.
  UISwitch.castFromPointer(ffi.Pointer<objc.ObjCObject> other, {bool retain = false, bool release = false})
    : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [UISwitch].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_UISwitch);
  }

  /// layerClass
  static objc.ObjCObjectBase getLayerClass() {
    objc.checkOsVersionInternal('UISwitch.layerClass', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_151sglz(_class_UISwitch, _sel_layerClass);
    return objc.ObjCObjectBase($ret, retain: true, release: true);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute(
    UISemanticContentAttribute attribute,
  ) {
    objc.checkOsVersionInternal(
      'UISwitch.userInterfaceLayoutDirectionForSemanticContentAttribute:',
      iOS: (false, (9, 0, 0)),
    );
    final $ret = _objc_msgSend_racczx(
      _class_UISwitch,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_,
      attribute.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }

  /// userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:
  static UIUserInterfaceLayoutDirection userInterfaceLayoutDirectionForSemanticContentAttribute$1(
    UISemanticContentAttribute semanticContentAttribute, {
    required UIUserInterfaceLayoutDirection relativeToLayoutDirection,
  }) {
    objc.checkOsVersionInternal(
      'UISwitch.userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:',
      iOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_tz4p54(
      _class_UISwitch,
      _sel_userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection_,
      semanticContentAttribute.value,
      relativeToLayoutDirection.value,
    );
    return UIUserInterfaceLayoutDirection.fromValue($ret);
  }
}

extension UISwitch$Methods on UISwitch {
  /// encodeWithCoder:
  void encodeWithCoder(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  UISwitch? initWithCoder(objc.NSCoder coder) {
    final $ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(), _sel_initWithCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : UISwitch.castFromPointer($ret, retain: false, release: true);
  }

  /// initWithFrame:
  UISwitch initWithFrame(objc.CGRect frame) {
    objc.checkOsVersionInternal('UISwitch.initWithFrame:', iOS: (false, (2, 0, 0)));
    final $ret = _objc_msgSend_15yz4e6(this.ref.retainAndReturnPointer(), _sel_initWithFrame_, frame);
    return UISwitch.castFromPointer($ret, retain: false, release: true);
  }

  /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
  UISwitch initWithFrame$1(objc.CGRect frame, {UIAction? primaryAction}) {
    objc.checkOsVersionInternal('UISwitch.initWithFrame:primaryAction:', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_gxusyk(
      this.ref.retainAndReturnPointer(),
      _sel_initWithFrame_primaryAction_,
      frame,
      primaryAction?.ref.pointer ?? ffi.nullptr,
    );
    return UISwitch.castFromPointer($ret, retain: false, release: true);
  }

  /// isOn
  bool get isOn {
    objc.checkOsVersionInternal('UISwitch.isOn', iOS: (false, (2, 0, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOn);
  }

  /// offImage
  UIImage? get offImage {
    objc.checkOsVersionInternal('UISwitch.offImage', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_offImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// onImage
  UIImage? get onImage {
    objc.checkOsVersionInternal('UISwitch.onImage', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_onImage);
    return $ret.address == 0 ? null : UIImage.castFromPointer($ret, retain: true, release: true);
  }

  /// onTintColor
  UIColor? get onTintColor {
    objc.checkOsVersionInternal('UISwitch.onTintColor', iOS: (false, (5, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_onTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// Request a style for the switch. If the style changed, then the switch may resize.
  UISwitchStyle get preferredStyle {
    objc.checkOsVersionInternal('UISwitch.preferredStyle', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_ums1js(this.ref.pointer, _sel_preferredStyle);
    return UISwitchStyle.fromValue($ret);
  }

  /// setOffImage:
  set offImage(UIImage? value) {
    objc.checkOsVersionInternal('UISwitch.setOffImage:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOffImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setOn:
  set isOn(bool value) {
    objc.checkOsVersionInternal('UISwitch.setOn:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setOn_, value);
  }

  /// setOn:animated:
  void setOn(bool on$, {required bool animated}) {
    objc.checkOsVersionInternal('UISwitch.setOn:animated:', iOS: (false, (2, 0, 0)));
    _objc_msgSend_14iqu8t(this.ref.pointer, _sel_setOn_animated_, on$, animated);
  }

  /// setOnImage:
  set onImage(UIImage? value) {
    objc.checkOsVersionInternal('UISwitch.setOnImage:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOnImage_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// setOnTintColor:
  set onTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UISwitch.setOnTintColor:', iOS: (false, (5, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setOnTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// Request a style for the switch. If the style changed, then the switch may resize.
  set preferredStyle(UISwitchStyle value) {
    objc.checkOsVersionInternal('UISwitch.setPreferredStyle:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_1bkwtnu(this.ref.pointer, _sel_setPreferredStyle_, value.value);
  }

  /// setThumbTintColor:
  set thumbTintColor(UIColor? value) {
    objc.checkOsVersionInternal('UISwitch.setThumbTintColor:', iOS: (false, (6, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setThumbTintColor_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The title displayed alongside the switch, positioned appropriately for the @c UIUserInterfaceIdiom.
  /// @note This property is only supported for Catalyst in the Mac idiom.
  set title(objc.NSString? value) {
    objc.checkOsVersionInternal('UISwitch.setTitle:', iOS: (false, (14, 0, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setTitle_, value?.ref.pointer ?? ffi.nullptr);
  }

  /// The switch's display style. This property always returns a concrete, resolved style (never UISwitchStyleAutomatic).
  UISwitchStyle get style {
    objc.checkOsVersionInternal('UISwitch.style', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_ums1js(this.ref.pointer, _sel_style);
    return UISwitchStyle.fromValue($ret);
  }

  /// thumbTintColor
  UIColor? get thumbTintColor {
    objc.checkOsVersionInternal('UISwitch.thumbTintColor', iOS: (false, (6, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_thumbTintColor);
    return $ret.address == 0 ? null : UIColor.castFromPointer($ret, retain: true, release: true);
  }

  /// The title displayed alongside the switch, positioned appropriately for the @c UIUserInterfaceIdiom.
  /// @note This property is only supported for Catalyst in the Mac idiom.
  objc.NSString? get title {
    objc.checkOsVersionInternal('UISwitch.title', iOS: (false, (14, 0, 0)));
    final $ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_title);
    return $ret.address == 0 ? null : objc.NSString.castFromPointer($ret, retain: true, release: true);
  }
}

enum UITabBarItemAppearanceStyle {
  UITabBarItemAppearanceStyleStacked(0),
  UITabBarItemAppearanceStyleInline(1),
  UITabBarItemAppearanceStyleCompactInline(2);

  final int value;
  const UITabBarItemAppearanceStyle(this.value);

  static UITabBarItemAppearanceStyle fromValue(int value) => switch (value) {
    0 => UITabBarItemAppearanceStyleStacked,
    1 => UITabBarItemAppearanceStyleInline,
    2 => UITabBarItemAppearanceStyleCompactInline,
    _ => throw ArgumentError('Unknown value for UITabBarItemAppearanceStyle: $value'),
  };
}
